<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"global.html":{"id":"global.html","title":"Global","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Global Members BOOMR_lstart :TimeStamp This variable is added to the global scope (window) until Boomerang loads, at which point it is removed. Time the loader script started fetching boomerang.js (if the asynchronous loader snippet is used). Type: TimeStamp BOOMR_onload :TimeStamp This variable is added to the global scope (window). Time the window.onload event fired (if using the asynchronous loader snippet). This timestamp is logged in the case boomerang.js loads after the onload event for browsers that don't support NavigationTiming. Type: TimeStamp BOOMR_start :TimeStamp This variable is added to the global scope (window) until Boomerang loads, at which point it is removed. Timestamp the boomerang.js script started executing. This has to be global so that we don't wait for this entire script to download and execute before measuring the time. We also declare it without var so that we can later delete it. This is the only way that works on Internet Explorer. Type: TimeStamp Methods BOOMR_check_doc_domain(domain) This function is added to the global scope (window). Check the value of document.domain and fix it if incorrect. This function is run at the top of boomerang, and then whenever BOOMR.init is called. If boomerang is running within an IFRAME, this function checks to see if it can access elements in the parent IFRAME. If not, it will fudge around with document.domain until it finds a value that works. This allows site owners to change the value of document.domain at any point within their page's load process, and we will adapt to it. Parameters: Name Type Description domain string Domain name as retrieved from page URL Type Definitions TimeStamp A Unix Epoch timestamp (milliseconds since 1970) created by BOOMR.now(). If DOMHighResTimeStamp (performance.now()) is supported, it is a DOMHighResTimeStamp (with microsecond resolution in the fractional), otherwise, it is Date.now(). Type: number × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Classes Classes BOOMR browser constants plugins AutoXHR BW CACHE_RELOAD Clicks ConsentInlinedPlugin Continuity CT DNS Early Errors EventTiming GUID History IFrameDelay IPv6 Memory Mobile NavigationTiming PaintTiming ResourceTiming RT SPA TPAnalytics UserTiming session utils Compression BOOMR_mq MutationHandler ProxyXHRImplementation Events beacon Boomerang event, subscribe via BOOMR.subscribe. Fired when a beacon was sent. The beacon variables cannot be modified at this point. Any calls to BOOMR.addVar or BOOMR.removeVar will apply to the next beacon. Also known as onbeacon. Properties: Name Type Description vars object Beacon variables before_beacon Boomerang event, subscribe via BOOMR.subscribe. Fired when a beacon is about to be sent. The subscriber can still add variables to the beacon at this point, either by modifying the vars paramter or calling BOOMR.addVar. Properties: Name Type Description vars object Beacon variables before_early_beacon Boomerang event, subscribe via BOOMR.subscribe. Fired when an early beacon is about to be sent. The subscriber can still add variables to the early beacon at this point by calling BOOMR.addVar. This event will only happen if BOOMR.plugins.Early is enabled. Properties: Name Type Description data object Event data before_unload Boomerang event, subscribe via BOOMR.subscribe. Fired before the document is about to be unloaded. window.beforeunload will trigger this. See: https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload click Boomerang event, subscribe via BOOMR.subscribe. Fired when the click event has happened on the document. See: https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onclick config Boomerang event, subscribe via BOOMR.subscribe. Fired whenever new configuration data is applied via BOOMR.init. Also known as onconfig. Properties: Name Type Description data object Configuration data dom_loaded Boomerang event, subscribe via BOOMR.subscribe. Fired on document.DOMContentLoaded. The DOMContentLoaded event is fired when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading See: https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded error Boomerang event, subscribe via BOOMR.subscribe. Fired whenever a page error has happened. This event will only happen if BOOMR.plugins.Errors is enabled. Also known as onerror. Properties: Name Type Description err object Error form_submit Boomerang event, subscribe via BOOMR.subscribe. Fired when any FORM element is submitted. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/submit netinfo Boomerang event, subscribe via BOOMR.subscribe. Fired whenever connection information changes via the Network Information API. This event will only happen if BOOMR.plugins.Mobile is enabled. Properties: Name Type Description connection object navigator.connection page_load_beacon Boomerang event, subscribe via BOOMR.subscribe. Fired when the page load beacon has been sent. This event should only happen once on a page. It does not apply to SPA soft navigations. Properties: Name Type Description vars object Beacon variables page_ready Boomerang event, subscribe via BOOMR.subscribe. Fired when the page is usable by the user. By default this is fired when window.onload fires, but if you set autorun to false when calling BOOMR.init, then you must explicitly fire this event by calling BOOMR#event:page_ready. Properties: Name Type Argument Description event Event &lt;optional&gt; Event triggering the page_ready See: https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload page_unload Boomerang event, subscribe via BOOMR.subscribe. Fired just before the browser unloads the page. The first event of window.pagehide, window.beforeunload, or window.unload will trigger this. See: https://developer.mozilla.org/en-US/docs/Web/Events/pagehide https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onunload prerender_to_visible Boomerang event, subscribe via BOOMR.subscribe. Fired when the visibilityState of the document has changed from prerender to visible See: https://developer.mozilla.org/en-US/docs/Web/Events/visibilitychange rage_click Boomerang event, subscribe via BOOMR.subscribe. Fired whenever a Rage Click is detected. This event will only happen if BOOMR.plugins.Continuity is enabled. Properties: Name Type Description e Event Event spa_cancel Boomerang event, subscribe via BOOMR.subscribe. Fired whenever a SPA navigation is cancelled. spa_init Boomerang event, subscribe via BOOMR.subscribe. Fired whenever a SPA plugin is about to track a new navigation. Properties: Name Type Description navType string Navigation type (spa or spa_hard) param object SPA navigation parameters spa_navigation Boomerang event, subscribe via BOOMR.subscribe. Fired whenever a SPA navigation is complete. visibility_changed Boomerang event, subscribe via BOOMR.subscribe. Fired on document.visibilitychange. The visibilitychange event is fired when the content of a tab has become visible or has been hidden. See: https://developer.mozilla.org/en-US/docs/Web/Events/visibilitychange xhr_error Boomerang event, subscribe via BOOMR.subscribe. Fired whenever and XMLHttpRequest has an error (if its status is set). This event will only happen if BOOMR.plugins.AutoXHR is enabled. Also known as onxhrerror. Properties: Name Type Description data object XHR data xhr_init Boomerang event, subscribe via BOOMR.subscribe. Fired whenever XMLHttpRequest.open is called. This event will only happen if BOOMR.plugins.AutoXHR is enabled. Properties: Name Type Description type string XHR type (\"xhr\") xhr_load Boomerang event, subscribe via BOOMR.subscribe. Fired when an XMLHttpRequest has finished, or, if something calls BOOMR.responseEnd. Properties: Name Type Description data object Event data xhr_send Boomerang event, subscribe via BOOMR.subscribe. Fired whenever XMLHttpRequest.send is called. This event will only happen if BOOMR.plugins.AutoXHR is enabled. Properties: Name Type Description xhr object XMLHttpRequest object onBeforeBoomerangBeacon Public event (fired on document), and can be subscribed via document.addEventListener(\"onBeforeBoomerangBeacon\", ...) or document.attachEvent(\"onpropertychange\", ...). Maps to BOOMR#event:before_beacon Properties: Name Type Description vars object Beacon variables onBoomerangBeacon Public event (fired on document), and can be subscribed via document.addEventListener(\"onBoomerangBeacon\", ...) or document.attachEvent(\"onpropertychange\", ...). Maps to BOOMR#event:before_beacon Properties: Name Type Description vars object Beacon variables onBoomerangLoaded Public event (fired on document), and can be subscribed via document.addEventListener(\"onBoomerangLoaded\", ...) or document.attachEvent(\"onpropertychange\", ...). Fired when BOOMR has loaded and can be used. × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Tutorials Classes BOOMR browser constants plugins AutoXHR BW CACHE_RELOAD Clicks ConsentInlinedPlugin Continuity CT DNS Early Errors EventTiming GUID History IFrameDelay IPv6 Memory Mobile NavigationTiming PaintTiming ResourceTiming RT SPA TPAnalytics UserTiming session utils Compression BOOMR_mq MutationHandler ProxyXHRImplementation Events beacon Boomerang event, subscribe via BOOMR.subscribe. Fired when a beacon was sent. The beacon variables cannot be modified at this point. Any calls to BOOMR.addVar or BOOMR.removeVar will apply to the next beacon. Also known as onbeacon. Properties: Name Type Description vars object Beacon variables before_beacon Boomerang event, subscribe via BOOMR.subscribe. Fired when a beacon is about to be sent. The subscriber can still add variables to the beacon at this point, either by modifying the vars paramter or calling BOOMR.addVar. Properties: Name Type Description vars object Beacon variables before_early_beacon Boomerang event, subscribe via BOOMR.subscribe. Fired when an early beacon is about to be sent. The subscriber can still add variables to the early beacon at this point by calling BOOMR.addVar. This event will only happen if BOOMR.plugins.Early is enabled. Properties: Name Type Description data object Event data before_unload Boomerang event, subscribe via BOOMR.subscribe. Fired before the document is about to be unloaded. window.beforeunload will trigger this. See: https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload click Boomerang event, subscribe via BOOMR.subscribe. Fired when the click event has happened on the document. See: https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onclick config Boomerang event, subscribe via BOOMR.subscribe. Fired whenever new configuration data is applied via BOOMR.init. Also known as onconfig. Properties: Name Type Description data object Configuration data dom_loaded Boomerang event, subscribe via BOOMR.subscribe. Fired on document.DOMContentLoaded. The DOMContentLoaded event is fired when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading See: https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded error Boomerang event, subscribe via BOOMR.subscribe. Fired whenever a page error has happened. This event will only happen if BOOMR.plugins.Errors is enabled. Also known as onerror. Properties: Name Type Description err object Error form_submit Boomerang event, subscribe via BOOMR.subscribe. Fired when any FORM element is submitted. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/submit netinfo Boomerang event, subscribe via BOOMR.subscribe. Fired whenever connection information changes via the Network Information API. This event will only happen if BOOMR.plugins.Mobile is enabled. Properties: Name Type Description connection object navigator.connection page_load_beacon Boomerang event, subscribe via BOOMR.subscribe. Fired when the page load beacon has been sent. This event should only happen once on a page. It does not apply to SPA soft navigations. Properties: Name Type Description vars object Beacon variables page_ready Boomerang event, subscribe via BOOMR.subscribe. Fired when the page is usable by the user. By default this is fired when window.onload fires, but if you set autorun to false when calling BOOMR.init, then you must explicitly fire this event by calling BOOMR#event:page_ready. Properties: Name Type Argument Description event Event &lt;optional&gt; Event triggering the page_ready See: https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload page_unload Boomerang event, subscribe via BOOMR.subscribe. Fired just before the browser unloads the page. The first event of window.pagehide, window.beforeunload, or window.unload will trigger this. See: https://developer.mozilla.org/en-US/docs/Web/Events/pagehide https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onunload prerender_to_visible Boomerang event, subscribe via BOOMR.subscribe. Fired when the visibilityState of the document has changed from prerender to visible See: https://developer.mozilla.org/en-US/docs/Web/Events/visibilitychange rage_click Boomerang event, subscribe via BOOMR.subscribe. Fired whenever a Rage Click is detected. This event will only happen if BOOMR.plugins.Continuity is enabled. Properties: Name Type Description e Event Event spa_cancel Boomerang event, subscribe via BOOMR.subscribe. Fired whenever a SPA navigation is cancelled. spa_init Boomerang event, subscribe via BOOMR.subscribe. Fired whenever a SPA plugin is about to track a new navigation. Properties: Name Type Description navType string Navigation type (spa or spa_hard) param object SPA navigation parameters spa_navigation Boomerang event, subscribe via BOOMR.subscribe. Fired whenever a SPA navigation is complete. visibility_changed Boomerang event, subscribe via BOOMR.subscribe. Fired on document.visibilitychange. The visibilitychange event is fired when the content of a tab has become visible or has been hidden. See: https://developer.mozilla.org/en-US/docs/Web/Events/visibilitychange xhr_error Boomerang event, subscribe via BOOMR.subscribe. Fired whenever and XMLHttpRequest has an error (if its status is set). This event will only happen if BOOMR.plugins.AutoXHR is enabled. Also known as onxhrerror. Properties: Name Type Description data object XHR data xhr_init Boomerang event, subscribe via BOOMR.subscribe. Fired whenever XMLHttpRequest.open is called. This event will only happen if BOOMR.plugins.AutoXHR is enabled. Properties: Name Type Description type string XHR type (\"xhr\") xhr_load Boomerang event, subscribe via BOOMR.subscribe. Fired when an XMLHttpRequest has finished, or, if something calls BOOMR.responseEnd. Properties: Name Type Description data object Event data xhr_send Boomerang event, subscribe via BOOMR.subscribe. Fired whenever XMLHttpRequest.send is called. This event will only happen if BOOMR.plugins.AutoXHR is enabled. Properties: Name Type Description xhr object XMLHttpRequest object onBeforeBoomerangBeacon Public event (fired on document), and can be subscribed via document.addEventListener(\"onBeforeBoomerangBeacon\", ...) or document.attachEvent(\"onpropertychange\", ...). Maps to BOOMR#event:before_beacon Properties: Name Type Description vars object Beacon variables onBoomerangBeacon Public event (fired on document), and can be subscribed via document.addEventListener(\"onBoomerangBeacon\", ...) or document.attachEvent(\"onpropertychange\", ...). Maps to BOOMR#event:before_beacon Properties: Name Type Description vars object Beacon variables onBoomerangLoaded Public event (fired on document), and can be subscribed via document.addEventListener(\"onBoomerangLoaded\", ...) or document.attachEvent(\"onpropertychange\", ...). Fired when BOOMR has loaded and can be used. × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start boomerangjs 1.737.0 Copyright (c) 2011, Yahoo! Inc. All rights reserved. Copyright (c) 2011-2012, Log-Normal Inc. All rights reserved. Copyright (c) 2012-2017 SOASTA, Inc. All rights reserved. Copyright (c) 2017-2019, Akamai Technologies, Inc. All rights reserved. Copyrights licensed under the BSD License. See the accompanying LICENSE.txt file for terms. boomerang always comes back, except when it hits something. Summary boomerang is a JavaScript library that measures the page load time experienced by real users, commonly called RUM (Real User Measurement). It has the ability to send this data back to your server for further analysis. With boomerang, you find out exactly how fast your users think your site is. Apart from page load time, boomerang measures performance timings, metrics and characteristics of your user's web browsing experience. All you have to do is include it in your web pages and call the BOOMR.init() method. Once the performance data is captured, it will be beaconed to your chosen URL. boomerang is designed to be a performant and flexible library that can be adapted to your site's needs. It has an extensive plugin architecture, and works with both traditional and modern websites (including Single Page Apps). boomerang's goal is to not affect the load time of the page (avoiding the Observer Effect). It can be loaded in an asynchronous way that will not delay the page load even if boomerang.js is unavailable. Features Supports: IE 6+, Edge, all major versions of Firefox, Chrome, Opera, and Safari Desktop and mobile devices Captures (all optional): Page characteristics such as the URL and Referrer Overall page load times (via NavigationTiming if available) DNS, TCP, Request and Response timings (via NavigationTiming) Browser characteristics such as screen size, orientation, memory usage, visibility state DOM characteristics such as the number of nodes, HTML length, number of images, scripts, etc ResourceTiming data (to reconstruct the page's Waterfall) Bandwidth Mobile connection data DNS latency JavaScript Errors XMLHttpRequest instrumentation Third-Party analytics providers IDs Single Page App interactions Usage boomerang can be included on your page in one of two ways: synchronously or asynchronously. The asynchronous method is recommended. The simple synchronous way &lt;script src=\"boomerang.js\"&gt;&lt;/script&gt; &lt;script src=\"plugins/rt.js\"&gt;&lt;/script&gt; &lt;!-- any other plugins you want to include --&gt; &lt;script&gt; BOOMR.init({ beacon_url: \"http://yoursite.com/beacon/\" }); &lt;/script&gt; Note: You must include at least one plugin (it doesn't have to be RT) or else the beacon will never fire. Each plugin has its own configuration as well -- these configuration options should be included in the BOOMR.init() call: BOOMR.init({ beacon_url: \"http://yoursite.com/beacon/\", ResourceTiming: { enabled: true, clearOnBeacon: true } }); The faster, more involved, asynchronous way Loading boomerang asynchronously ensures that even if boomerang.js is unavailable (or loads slowly), your host page will not be affected. 1. Add a plugin to init your code Create a plugin (or use the sample zzz-last-plugin.js) with a call to BOOMR.init: BOOMR.init({ config: parameters, ... }); BOOMR.t_end = new Date().getTime(); You could also include any other code you need. For example, you could include a timer to measure when boomerang has finished loading (as above). 2. Build boomerang The build process bundles boomerang.js and all of the plugins listed in plugins.json (in that order). To build boomerang with all of your desired plugins, you would run: grunt clean build This creates a deployable boomerang in the build directory, e.g. build/boomerang-&lt;version&gt;.min.js. Install this file on your web server or origin server where your CDN can pick it up. Set a far future max-age header for it. This file will never change. 3. Asynchronously include the script on your page There are two methods of asynchronously including boomerang on your page: by adding it to your main document, or via the IFRAME/Preload method. The former method could block your onload event (affecting the measured performance of your page), so the later method is recommended. 3.1. Adding it to the main document Include the following code at the top of your HTML document: &lt;script&gt; (function(d, s) { var js = d.createElement(s), sc = d.getElementsByTagName(s)[0]; js.src=\"http://your-cdn.host.com/path/to/boomerang-&lt;version&gt;.js\"; sc.parentNode.insertBefore(js, sc); }(document, \"script\")); &lt;/script&gt; Best practices will suggest including all scripts at the bottom of your page. However, that only applies to scripts that block downloading of other resources. Including a script this way will not block other resources, however it will block onload. Including the script at the top of your page gives it a good chance of loading before the rest of your page does, thereby reducing the probability of it blocking the onload event. If you don't want to block onload either, use the following IFRAME/Preload method: 3.2. Adding it via an IFRAME/Preload The method described in 3.1 will still block onload on most browsers. To avoid blocking onload, we can load boomerang in an asynchronous IFRAME or via LINK preload (for browsers that support it). The general process is documented on in this blog post. For boomerang, the asynchronous loader snippet you'll use is: &lt;script&gt; (function() { // Boomerang Loader Snippet version 14 if (window.BOOMR &amp;&amp; (window.BOOMR.version || window.BOOMR.snippetExecuted)) { return; } window.BOOMR = window.BOOMR || {}; window.BOOMR.snippetStart = new Date().getTime(); window.BOOMR.snippetExecuted = true; window.BOOMR.snippetVersion = 14; // NOTE: Set Boomerang URL here window.BOOMR.url = \"\"; var // document.currentScript is supported in all browsers other than IE where = document.currentScript || document.getElementsByTagName(\"script\")[0], // Parent element of the script we inject parentNode = where.parentNode, // Whether or not Preload method has worked promoted = false, // How long to wait for Preload to work before falling back to iframe method LOADER_TIMEOUT = 3000; // Tells the browser to execute the Preloaded script by adding it to the DOM function promote() { if (promoted) { return; } var script = document.createElement(\"script\"); script.id = \"boomr-scr-as\"; script.src = window.BOOMR.url; // Not really needed since dynamic scripts are async by default and the script is already in cache at this point, // but some naive parsers will see a missing async attribute and think we're not async script.async = true; parentNode.appendChild(script); promoted = true; } // Non-blocking iframe loader (fallback for non-Preload scenarios) for all recent browsers. // For IE 6/7, falls back to dynamic script node. function iframeLoader(wasFallback) { promoted = true; var dom, doc = document, bootstrap, iframe, iframeStyle, win = window; window.BOOMR.snippetMethod = wasFallback ? \"if\" : \"i\"; // Adds Boomerang within the iframe bootstrap = function(parent, scriptId) { var script = doc.createElement(\"script\"); script.id = scriptId || \"boomr-if-as\"; script.src = window.BOOMR.url; BOOMR_lstart = new Date().getTime(); parent = parent || doc.body; parent.appendChild(script); }; // For IE 6/7, we'll just load the script in the current frame, as those browsers don't support 'about:blank' // for an iframe src (it triggers warnings on secure sites). This means loading on IE 6/7 may cause SPoF. if (!window.addEventListener &amp;&amp; window.attachEvent &amp;&amp; navigator.userAgent.match(/MSIE [67]\\./)) { window.BOOMR.snippetMethod = \"s\"; bootstrap(parentNode, \"boomr-async\"); return; } // The rest of this function is IE8+ and other browsers that don't support Preload hints but will work with CSP &amp; iframes iframe = document.createElement(\"IFRAME\"); // An empty frame iframe.src = \"about:blank\"; // We set title and role appropriately to play nicely with screen readers and other assistive technologies iframe.title = \"\"; iframe.role = \"presentation\"; // Ensure we're not loaded lazily iframe.loading = \"eager\"; // Hide the iframe iframeStyle = (iframe.frameElement || iframe).style; iframeStyle.width = 0; iframeStyle.height = 0; iframeStyle.border = 0; iframeStyle.display = \"none\"; // Append to the end of the current block parentNode.appendChild(iframe); // Try to get the iframe's document object try { win = iframe.contentWindow; doc = win.document.open(); } catch (e) { // document.domain has been changed and we're on an old version of IE, so we got an access denied. // Note: the only browsers that have this problem also do not have CSP support. // Get document.domain of the parent window dom = document.domain; // Set the src of the iframe to a JavaScript URL that will immediately set its document.domain to match the parent. // This lets us access the iframe document long enough to inject our script. // Our script may need to do more domain massaging later. iframe.src = \"javascript:var d=document.open();d.domain='\" + dom + \"';void 0;\"; win = iframe.contentWindow; doc = win.document.open(); } if (dom) { // Unsafe version for IE8 compatibility. If document.domain has changed, we can't use win, but we can use doc. doc._boomrl = function() { this.domain = dom; bootstrap(); }; // Run our function at load. // Split the string so HTML code injectors don't get confused and add code here. doc.write(\"&lt;bo\" + \"dy onload='document._boomrl();'&gt;\"); } else { // document.domain hasn't changed, regular method should be OK win._boomrl = function() { bootstrap(); }; if (win.addEventListener) { win.addEventListener(\"load\", win._boomrl, false); } else if (win.attachEvent) { win.attachEvent(\"onload\", win._boomrl); } } // Finish the document doc.close(); } // See if Preload is supported or not var link = document.createElement(\"link\"); if (link.relList &amp;&amp; typeof link.relList.supports === \"function\" &amp;&amp; link.relList.supports(\"preload\") &amp;&amp; (\"as\" in link)) { window.BOOMR.snippetMethod = \"p\"; // Set attributes to trigger a Preload link.href = window.BOOMR.url; link.rel = \"preload\"; link.as = \"script\"; // Add our script tag if successful, fallback to iframe if not link.addEventListener(\"load\", promote); link.addEventListener(\"error\", function() { iframeLoader(true); }); // Have a fallback in case Preload does nothing or is slow setTimeout(function() { if (!promoted) { iframeLoader(true); } }, LOADER_TIMEOUT); // Note the timestamp we started trying to Preload BOOMR_lstart = new Date().getTime(); // Append our link tag parentNode.appendChild(link); } else { // No Preload support, use iframe loader iframeLoader(false); } // Save when the onload event happened, in case this is a non-NavigationTiming browser function boomerangSaveLoadTime(e) { window.BOOMR_onload = (e &amp;&amp; e.timeStamp) || new Date().getTime(); } if (window.addEventListener) { window.addEventListener(\"load\", boomerangSaveLoadTime, false); } else if (window.attachEvent) { window.attachEvent(\"onload\", boomerangSaveLoadTime); } })(); &lt;/script&gt; Minified: &lt;script&gt;(function(){if(window.BOOMR&amp;&amp;(window.BOOMR.version||window.BOOMR.snippetExecuted)){return}window.BOOMR=window.BOOMR||{};window.BOOMR.snippetStart=(new Date).getTime();window.BOOMR.snippetExecuted=true;window.BOOMR.snippetVersion=14;window.BOOMR.url=\"\";var e=document.currentScript||document.getElementsByTagName(\"script\")[0],a=e.parentNode,s=false,t=3e3;function n(){if(s){return}var e=document.createElement(\"script\");e.id=\"boomr-scr-as\";e.src=window.BOOMR.url;e.async=true;a.appendChild(e);s=true}function o(e){s=true;var t,o=document,n,i,d,r=window;window.BOOMR.snippetMethod=e?\"if\":\"i\";n=function(e,t){var n=o.createElement(\"script\");n.id=t||\"boomr-if-as\";n.src=window.BOOMR.url;BOOMR_lstart=(new Date).getTime();e=e||o.body;e.appendChild(n)};if(!window.addEventListener&amp;&amp;window.attachEvent&amp;&amp;navigator.userAgent.match(/MSIE [67]\\./)){window.BOOMR.snippetMethod=\"s\";n(a,\"boomr-async\");return}i=document.createElement(\"IFRAME\");i.src=\"about:blank\";i.title=\"\";i.role=\"presentation\";i.loading=\"eager\";d=(i.frameElement||i).style;d.width=0;d.height=0;d.border=0;d.display=\"none\";a.appendChild(i);try{r=i.contentWindow;o=r.document.open()}catch(e){t=document.domain;i.src=\"javascript:var d=document.open();d.domain='\"+t+\"';void 0;\";r=i.contentWindow;o=r.document.open()}if(t){o._boomrl=function(){this.domain=t;n()};o.write(\"&lt;bo\"+\"dy onload='document._boomrl();'&gt;\")}else{r._boomrl=function(){n()};if(r.addEventListener){r.addEventListener(\"load\",r._boomrl,false)}else if(r.attachEvent){r.attachEvent(\"onload\",r._boomrl)}}o.close()}var i=document.createElement(\"link\");if(i.relList&amp;&amp;typeof i.relList.supports===\"function\"&amp;&amp;i.relList.supports(\"preload\")&amp;&amp;\"as\"in i){window.BOOMR.snippetMethod=\"p\";i.href=window.BOOMR.url;i.rel=\"preload\";i.as=\"script\";i.addEventListener(\"load\",n);i.addEventListener(\"error\",function(){o(true)});setTimeout(function(){if(!s){o(true)}},t);BOOMR_lstart=(new Date).getTime();a.appendChild(i)}else{o(false)}function d(e){window.BOOMR_onload=e&amp;&amp;e.timeStamp||(new Date).getTime()}if(window.addEventListener){window.addEventListener(\"load\",d,false)}else if(window.attachEvent){window.attachEvent(\"onload\",d)}})();&lt;/script&gt; Change the boomerangUrl to the location of Boomerang on your server. The id of the script node created by this code MUST be boomr-if-as (for IFRAME mode) or boomr-scr-as (for Preload mode) as boomerang looks for those ids to determine if it's running within an IFRAME and to determine the URL of the script. boomerang will still export the BOOMR object to the parent window if running inside an IFRAME, so the rest of your code should remain unchanged. 3.3. Identifying when boomerang has loaded If you load boomerang asynchronously, there's some uncertainty in when boomerang has completed loading. To get around this, you can subscribe to the onBoomerangLoaded Custom Event on the document object: // Modern browsers if (document.addEventListener) { document.addEventListener(\"onBoomerangLoaded\", function(e) { // e.detail.BOOMR is a reference to the BOOMR global object }); } // IE 6, 7, 8 we use onPropertyChange and look for propertyName === \"onBoomerangLoaded\" else if (document.attachEvent) { document.attachEvent(\"onpropertychange\", function(e) { if (!e) e=event; if (e.propertyName === \"onBoomerangLoaded\") { // e.detail.BOOMR is a reference to the BOOMR global object } }); } Note that this only works on browsers that support the CustomEvent interface, which is Chrome (including Android), Firefox 6+ (including Android), Opera (including Android, but not Opera Mini), Safari (including iOS), IE 6+ (but see the code above for the special way to listen for the event on IE6, 7 &amp; 8). boomerang also fires the onBeforeBoomerangBeacon and onBoomerangBeacon events just before and during beaconing. Installation There are several ways of including Boomerang in your project: Boomerang can be downloaded from the official Boomerang Github repository. NPM: npm install boomerangjs Bower: bower install boomerang Once fetched, see Building Boomerang for more details on how to include the plugins you require. Documentation Documentation is in the docs/ directory. Boomerang documentation is written in Markdown and is built via JSDoc. You can build the current documentation by running Grunt: grunt jsdoc HTML files will be built under build/docs. Open-source Boomerang Documentation is currently published at akamai.github.io/boomerang/. The team at Akamai works on mPulse Boomerang, which contains a few mPulse-specific plugins and may have additional changes being tested before being backported to the open-source Boomerang. mPulse Boomerang usage documentation is available at docs.soasta.com/boomerang/ and mPulse Boomerang API documentation is at developer.akamai.com/tools/boomerang/docs/. Additional documentation: API Documentation: The BOOMR API Building Boomerang: How to build boomerang with plugins Contributing: Contributing to the open-source project Creating Plugins: Creating a plugin Methodology: How boomerang works internally How-Tos: Short recipes on how to do a bunch of things with boomerang Source code The boomerang source code is primarily on GitHub at github.com/akamai/boomerang. Feel free to fork it and contribute to it. You can also get a check out the releases or download a tarball or zip of the code. Support We use GitHub Issues for discussions, feature requests and bug reports. Get in touch at github.com/akamai/boomerang/issues. boomerang is supported by the developers at Akamai, and the awesome community of open-source developers that use and hack it. That's you. Thank you! Contributions Boomerang is brought to you by: the former Exceptional Performance team at the company once known as Yahoo!, aided by the Yahoo! Developer Network, the folks at LogNormal, continued by the mPulse team at SOASTA, ongoing by the mPulse team at Akamai, and many independent contributors whose contributions are cemented in our git history To help out, please read our contributing page. × Search results Close "},"BOOMR.html":{"id":"BOOMR.html","title":"Class: BOOMR","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR boomerang measures various performance characteristics of your user's browsing experience and beacons it back to your server. To use this you'll need a web site, lots of users and the ability to do something with the data you collect. How you collect the data is up to you, but we have a few ideas. Everything in boomerang is accessed through the BOOMR object, which is available on window.BOOMR. It contains the public API, utility functions (BOOMR.utils) and all of the plugins (BOOMR.plugins). Each plugin has its own API, but is reachable through BOOMR.plugins. Beacon Parameters The core boomerang object will add the following parameters to the beacon. Note that each individual plugin will add its own parameters as well. v: Boomerang version sv: Boomerang Loader Snippet version sm: Boomerang Loader Snippet method u: The page's URL (for most beacons), or the XMLHttpRequest URL n: The beacon number pgu: The page's URL (for XMLHttpRequest beacons) pid: Page ID (8 characters) r: Navigation referrer (from document.location) vis.pre: 1 if the page transitioned from prerender to visible vis.st: Document's visibility state when beacon was sent vis.lh: Timestamp when page was last hidden vis.lv: Timestamp when page was last visible xhr.pg: The XMLHttpRequest page group errors: Error messages of errors detected in Boomerang code, separated by a newline rt.si: Session ID rt.ss: Session start timestamp rt.sl: Session length (number of pages), can be increased by XHR beacons as well ua.plt: navigator.platform ua.vnd: navigator.vendor Classes browser constants plugins session utils Members boomerang_frame :Window The Boomerang frame: If Boomerang was loaded in an IFRAME, this is the IFRAME If Boomerang was loaded inline, this is the current window Type: Window boomr.t_lstart :TimeStamp Time the loader script started fetching boomerang.js (if using the asynchronous loader snippet) (BOOMR_lstart) Type: TimeStamp boomr.t_onload :TimeStamp Time the window.onload event fired (if using the asynchronous loader snippet). This timestamp is logged in the case boomerang.js loads after the onload event for browsers that don't support NavigationTiming. Type: TimeStamp config_url :string (Optional) URL of configuration file Type: string lastVisibilityEvent :object An mapping of visibliity event states to the latest time they happened Type: object loadedLate :boolean Whether or not Boomerang was loaded after the onload event. Type: boolean t_end :TimeStamp When the Boomerang plugins have all run. This value is generally set in zzz-last-plugin.js. Type: TimeStamp t_start :TimeStamp The timestamp when boomerang.js showed up on the page. This is the value of BOOMR_start we set earlier. Type: TimeStamp url :string URL of boomerang.js. Type: string version :string Boomerang version, formatted as major.minor.patchlevel. This variable is replaced during build (grunt build). Type: string window :Window The main document window. If Boomerang was loaded in an IFRAME, this is the parent window If Boomerang was loaded inline, this is the current window Type: Window xhr_excludes URLs to exclude from automatic XMLHttpRequest instrumentation. You can put any of the following in it: A full URL A hostname A path Example BOOMR = window.BOOMR || {}; BOOMR.xhr_excludes = { \"mysite.com\": true, \"/dashboard/\": true, \"https://mysite.com/dashboard/\": true }; Methods addError(err [, src] [, extra]) Logs an internal Boomerang error. If the BOOMR.plugins.Errors plugin is enabled, this data will be compressed on the err beacon parameter. If not, it will be included in uncompressed form on the errors parameter. Parameters: Name Type Argument Description err string | object Error src string &lt;optional&gt; Source extra object &lt;optional&gt; Extra data addVar(name, val, singleBeacon) Add one or more parameters to the beacon. This method may either be called with a single object containing key/value pairs, or with two parameters, the first is the variable name and the second is its value. All names should be strings usable in a URL's query string. We recommend only using alphanumeric characters and underscores, but you can use anything you like. Values should be strings (or numbers), and have the same restrictions as names. Parameters will be on all subsequent beacons unless singleBeacon is set. Early beacons will not clear vars that were set with singleBeacon. Parameters: Name Type Description name string Variable name val string | object Value singleBeacon boolean Whether or not to add to a single beacon or all beacons. Returns: Type: BOOMR Boomerang object Example BOOMR.addVar(\"page_id\", 123); BOOMR.addVar({\"page_id\": 123, \"user_id\": \"Person1\"}); appendVar(name, val) Appends data to a beacon. If the value already exists, a comma is added and the new data is applied. Parameters: Name Type Description name string Variable name val string Value Returns: Type: BOOMR Boomerang object attach_page_ready(cb) Attach a callback to the pageshow or onload event if onload has not been fired otherwise queue it to run immediately Parameters: Name Type Description cb function Callback to run when onload fires or page is visible (pageshow) debug(m [, s]) Logs debug messages to the console Debug messages are stripped out of production builds. Parameters: Name Type Argument Description m string Message s string &lt;optional&gt; Source disable() Disables boomerang from doing anything further: Clears event handlers (such as onload) Clears all event listeners error(m [, s]) Logs error messages to the console Parameters: Name Type Argument Description m string Message s string &lt;optional&gt; Source fireEvent(e_name, data) Fires a Boomerang event Parameters: Name Type Description e_name string Event name data object Event payload Returns: Type: BOOMR Boomerang object forceSameSiteCookieNone() Allows us to force SameSite=None from a Boomerang plugin or a third party code. When this function is called then Boomerang won't honor \"same_site_cookie\" configuration key and won't attempt to return the default value of SameSite=Lax . getPerformance() Gets the window.performance object of the root window. Checks vendor prefixes for older browsers (e.g. IE9). Returns: Type: Performance | undefined window.performance if it exists getResourceTiming(url [, sort] [, filter]) Gets the latest ResourceTiming entry for the specified URL. Default sort order is chronological startTime. Parameters: Name Type Argument Description url string Resource URL sort function &lt;optional&gt; Sort the entries before returning the last one filter function &lt;optional&gt; Filter the entries. Will be applied before sorting Returns: Type: PerformanceEntry | undefined Entry, or undefined if ResourceTiming is not supported or if the entry doesn't exist getUriEncodedVar(name, value) Gets a URI-encoded name/value pair. Parameters: Name Type Description name string Name value string Value Returns: Type: string URI-encoded string getVar(name) Gets the specified variable. Parameters: Name Type Description name string Variable name Returns: Type: object | undefined Variable, or undefined if it isn't set getVarsOfPriority(vars, pri) Gets all variables of the specified priority Parameters: Name Type Description vars object Variables (will be modified for pri -1 and 1) pri number Priority (-1, 0, or 1) Returns: Type: Array.&lt;string&gt; Array of URI-encoded vars hasSentPageLoadBeacon() Determines whether or not a Page Load beacon has been sent. Returns: Type: boolean True if a Page Load beacon has been sent. hasVar(name) Determines whether or not the beacon has the specified variable. Parameters: Name Type Description name string Variable name Returns: Type: boolean True if the variable is set. info(m [, s]) Logs info messages to the console Parameters: Name Type Argument Description m string Message s string &lt;optional&gt; Source init(config [, ]) Initializes Boomerang by applying the specified configuration. All plugins' init() functions will be called with the same config as well. Parameters: Name Type Argument Description config object Configuration object Properties Name Type Argument Description autorun boolean &lt;optional&gt; By default, boomerang runs automatically and attaches its page_ready handler to the window.onload event. If you set autorun to false, this will not happen and you will need to call BOOMR.page_ready yourself. beacon_auth_key string Beacon authorization key value beacon_auth_token string Beacon authorization token. beacon_with_credentials boolean Sends beacon with credentials beacon_disable_sendbeacon boolean Disables navigator.sendBeacon() support beacon_url string The URL to beacon results back to. If not set, no beacon will be sent. beacon_url_force_https boolean Forces protocol-relative Beacon URLs to HTTPS beacon_type string GET, POST or AUTO site_domain string &lt;optional&gt; The domain that all cookies should be set on Boomerang will try to auto-detect this, but unless your site is of the foo.com format, it will probably get it wrong. It's a good idea to set this to whatever part of your domain you'd like to share bandwidth and performance measurements across. Set this to a falsy value to disable all cookies. strip_query_string boolean &lt;optional&gt; Whether or not to strip query strings from all URLs (e.g. u, pgu, etc.) user_ip string &lt;optional&gt; Despite its name, this is really a free-form string used to uniquely identify the user's current internet connection. It's used primarily by the bandwidth test to determine whether it should re-measure the user's bandwidth or just use the value stored in the cookie. You may use IPv4, IPv6 or anything else that you think can be used to identify the user's network connection. same_site_cookie string &lt;optional&gt; Used for creating cookies with SameSite with one of the following values: None, Lax or Strict. secure_cookie boolean &lt;optional&gt; When true all cookies will be created with Secure flag. log function &lt;optional&gt; Logger to use. Set to null to disable logging. function &lt;optional&gt; Each plugin has its own section Returns: Type: BOOMR Boomerang object instrumentFetch() Instrument all requests made via fetch to send beacons. This is implemented in plugins/auto-xhr.js BOOMR.plugins.AutoXHR. instrumentXHR() Instrument all requests made via XMLHttpRequest to send beacons. This is implemented in plugins/auto-xhr.js BOOMR.plugins.AutoXHR. isCrossOriginError(err) Determines if the specified Error is a Cross-Origin error. Parameters: Name Type Description err string | object Error Returns: Type: boolean True if the Error is a Cross-Origin error. log(m, l [, s]) Logs the message to the console Parameters: Name Type Argument Description m string Message l string Log level s string &lt;optional&gt; Source now() Gets the current time in milliseconds since the Unix Epoch (Jan 1 1970). In browsers that support DOMHighResTimeStamp, this will be replaced by a function that adds performance.now() to navigationStart (with milliseconds.microseconds resolution). Returns: Type: TimeStamp Milliseconds since Unix Epoch onloadFired() Determines whether or not the page's onload event has fired, or if autorun is false, whether BOOMR.page_ready was called. Returns: Type: boolean True if onload or BOOMR.page_ready were called page_ready( [ev], auto) Method that fires the BOOMR#event:page_ready event. Call this only if you've set autorun to false when calling the BOOMR.init method. You should call this method when you determine that your page is ready to be used by your user. This will be the end-time used in the page load time measurement. Optionally, you can pass a Unix Epoch timestamp as a parameter or set the global BOOMR_page_ready var that will be used as the end-time instead. Parameters: Name Type Argument Description ev Event | number &lt;optional&gt; Ready event or optional load event end timestamp if called manually auto boolean True if called by page_ready_autorun Returns: Type: BOOMR Boomerang object Example BOOMR.init({ autorun: false, ... }); // wait until the page is ready, i.e. your view has loaded BOOMR.page_ready(); page_ready_autorun(ev) Sends the page_ready event only if autorun is still true after BOOMR.init is called. Parameters: Name Type Description ev Event Event readyToSend() Determines if Boomerang can send a beacon. Queryies all plugins to see if they implement readyToSend(), and if so, that they return true. If not, the beacon cannot be sent. Returns: Type: boolean True if Boomerang can send a beacon real_sendBeacon() Sends all beacon data. This function should be called directly any time a \"new\" beacon is about to be constructed. For example, if you're creating a new XHR or other custom beacon, you should ensure the existing beacon data is flushed by calling BOOMR.real_sendBeacon(); first. registerEvent(e_name) Registers a Boomerang event. Parameters: Name Type Description e_name string Event name Returns: Type: BOOMR Boomerang object removeVar(name) Removes one or more variables from the beacon URL. This is useful within a plugin to reset the values of parameters that it is about to set. Plugins can also use this in the BOOMR#event:beacon event to clear any variables that should only live on a single beacon. This method accepts either a list of variable names, or a single array containing a list of variable names. Parameters: Name Type Description name Array.&lt;string&gt; | string Variable name or list Returns: Type: BOOMR Boomerang object requestStart(name) Starts a timer for a dynamic request. Once the named request has completed, call loaded() to send a beacon with the duration. Parameters: Name Type Description name string Timer name Returns: Type: object An object with a .loaded() function that you can call when the dynamic timer is complete. Example var timer = BOOMR.requestStart(\"my-timer\"); // do stuff timer.loaded(); responseEnd(name, t_start, data, t_end) Sends a beacon for a dynamic request. Parameters: Name Type Description name string | object Timer name or timer object data. Properties Name Type Argument Description initiator string &lt;optional&gt; Initiator, such as xhr or spa url string &lt;optional&gt; URL of the request t_start TimeStamp Start time data object Request data t_end TimeStamp End time sendBeacon( [beacon_url_override]) Request boomerang to send its beacon with all queued beacon data (via BOOMR.addVar). Boomerang may ignore this request. When this method is called, boomerang checks all plugins. If any plugin has not completed its checks (ie, the plugin's is_complete() method returns false, then this method does nothing. If all plugins have completed, then this method fires the BOOMR#event:before_beacon event with all variables that will be sent on the beacon. After all BOOMR#event:before_beacon handlers return, this method checks if a beacon_url has been configured and if there are any beacon parameters to be sent. If both are true, it fires the beacon. The BOOMR#event:beacon event is then fired. sendBeacon() should be called any time a plugin goes from is_complete() = false to is_complete = true so the beacon is sent. The actual beaconing is handled in BOOMR.real_sendBeacon after a short delay (via BOOMR.setImmediate). If other calls to sendBeacon happen before BOOMR.real_sendBeacon is called, those calls will be discarded (so it's OK to call this in quick succession). Parameters: Name Type Argument Description beacon_url_override string &lt;optional&gt; Beacon URL override sendXhrPostBeacon(xhr [, paramsJoined]) Sends a beacon via XMLHttpRequest Parameters: Name Type Argument Description xhr object XMLHttpRequest object paramsJoined object &lt;optional&gt; XMLHttpRequest.send() argument setImmediate(fn [, data] [, cb_data] [, cb_scope]) Defer the function fn until the next instant the browser is free from user tasks. Parameters: Name Type Argument Description fn BOOMR~setImmediateCallback The callback function. data object &lt;optional&gt; Any data to pass to the callback function cb_data object &lt;optional&gt; Any passthrough data for the callback function. This differs from data when setImmediate is called via an event handler and data is the Event object cb_scope object &lt;optional&gt; The scope of the callback function if it is a method of an object Returns: nothing setReferrer(r) Sets the Referrers variable. Parameters: Name Type Description r string Referrer from the document.referrer setVarPriority(name, pri) Sets a variable's priority in the beacon URL. -1 = beginning of the URL 0 = middle of the URL (default) 1 = end of the URL Parameters: Name Type Description name string Variable name pri number Priority (-1 or 1) Returns: Type: BOOMR Boomerang object subscribe(e_name, fn, cb_data, cb_scope, once) Subscribes to a Boomerang event Parameters: Name Type Description e_name string Event name, i.e. BOOMR#event:page_ready. fn BOOMR~subscribeCallback Callback function cb_data object Callback data, passed as the second parameter to the callback function cb_scope object Callback scope. If set to an object, then the callback function is called as a method of this object, and all references to this within the callback function will refer to cb_scope. once boolean Whether or not this callback should only be run once Returns: Type: BOOMR Boomerang object uninstrumentFetch() Undo fetch instrumentation and reset the original fetch function This is implemented in plugins/auto-xhr.js BOOMR.plugins.AutoXHR. uninstrumentXHR() Undo XMLHttpRequest instrumentation and reset the original XMLHttpRequest object This is implemented in plugins/auto-xhr.js BOOMR.plugins.AutoXHR. visibilityState() Gets the document.visibilityState, or visible if Page Visibility is not supported. Returns: Type: string Visibility state warn(m [, s]) Logs warning messages to the console Parameters: Name Type Argument Description m string Message s string &lt;optional&gt; Source Type Definitions addObserverCallback(mutations, callback_data) The callback function may return a falsy value to disconnect the observer after it returns, or a truthy value to keep watching for mutations. If the return value is numeric and greater than 0, then this will be the new timeout. If it is boolean instead, then the timeout will not fire any more so the caller MUST call disconnect() at some point. Parameters: Name Type Description mutations Array.&lt;object&gt; List of mutations detected by the observer or undefined if the observer timed out callback_data object Is the passed in callback_data parameter without modifications setImmediateCallback(data, cb_data, callstack) The callback function may return a falsy value to disconnect the observer after it returns, or a truthy value to keep watching for mutations. If the return value is numeric and greater than 0, then this will be the new timeout. If it is boolean instead, then the timeout will not fire any more so the caller MUST call disconnect() at some point Parameters: Name Type Description data object The passed in data object cb_data object The passed in cb_data object callstack Error An Error object that holds the callstack for when setImmediate was called, used to determine what called the callback subscribeCallback(eventData, cb_data) Parameters: Name Type Description eventData object Event data cb_data object Callback data Events beacon Boomerang event, subscribe via BOOMR.subscribe. Fired when a beacon was sent. The beacon variables cannot be modified at this point. Any calls to BOOMR.addVar or BOOMR.removeVar will apply to the next beacon. Also known as onbeacon. Properties: Name Type Description vars object Beacon variables before_beacon Boomerang event, subscribe via BOOMR.subscribe. Fired when a beacon is about to be sent. The subscriber can still add variables to the beacon at this point, either by modifying the vars paramter or calling BOOMR.addVar. Properties: Name Type Description vars object Beacon variables before_early_beacon Boomerang event, subscribe via BOOMR.subscribe. Fired when an early beacon is about to be sent. The subscriber can still add variables to the early beacon at this point by calling BOOMR.addVar. This event will only happen if BOOMR.plugins.Early is enabled. Properties: Name Type Description data object Event data before_unload Boomerang event, subscribe via BOOMR.subscribe. Fired before the document is about to be unloaded. window.beforeunload will trigger this. See: https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload click Boomerang event, subscribe via BOOMR.subscribe. Fired when the click event has happened on the document. See: https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onclick config Boomerang event, subscribe via BOOMR.subscribe. Fired whenever new configuration data is applied via BOOMR.init. Also known as onconfig. Properties: Name Type Description data object Configuration data dom_loaded Boomerang event, subscribe via BOOMR.subscribe. Fired on document.DOMContentLoaded. The DOMContentLoaded event is fired when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading See: https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded error Boomerang event, subscribe via BOOMR.subscribe. Fired whenever a page error has happened. This event will only happen if BOOMR.plugins.Errors is enabled. Also known as onerror. Properties: Name Type Description err object Error form_submit Boomerang event, subscribe via BOOMR.subscribe. Fired when any FORM element is submitted. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/submit netinfo Boomerang event, subscribe via BOOMR.subscribe. Fired whenever connection information changes via the Network Information API. This event will only happen if BOOMR.plugins.Mobile is enabled. Properties: Name Type Description connection object navigator.connection page_load_beacon Boomerang event, subscribe via BOOMR.subscribe. Fired when the page load beacon has been sent. This event should only happen once on a page. It does not apply to SPA soft navigations. Properties: Name Type Description vars object Beacon variables page_ready Boomerang event, subscribe via BOOMR.subscribe. Fired when the page is usable by the user. By default this is fired when window.onload fires, but if you set autorun to false when calling BOOMR.init, then you must explicitly fire this event by calling BOOMR#event:page_ready. Properties: Name Type Argument Description event Event &lt;optional&gt; Event triggering the page_ready See: https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload page_unload Boomerang event, subscribe via BOOMR.subscribe. Fired just before the browser unloads the page. The first event of window.pagehide, window.beforeunload, or window.unload will trigger this. See: https://developer.mozilla.org/en-US/docs/Web/Events/pagehide https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onunload prerender_to_visible Boomerang event, subscribe via BOOMR.subscribe. Fired when the visibilityState of the document has changed from prerender to visible See: https://developer.mozilla.org/en-US/docs/Web/Events/visibilitychange rage_click Boomerang event, subscribe via BOOMR.subscribe. Fired whenever a Rage Click is detected. This event will only happen if BOOMR.plugins.Continuity is enabled. Properties: Name Type Description e Event Event spa_cancel Boomerang event, subscribe via BOOMR.subscribe. Fired whenever a SPA navigation is cancelled. spa_init Boomerang event, subscribe via BOOMR.subscribe. Fired whenever a SPA plugin is about to track a new navigation. Properties: Name Type Description navType string Navigation type (spa or spa_hard) param object SPA navigation parameters spa_navigation Boomerang event, subscribe via BOOMR.subscribe. Fired whenever a SPA navigation is complete. visibility_changed Boomerang event, subscribe via BOOMR.subscribe. Fired on document.visibilitychange. The visibilitychange event is fired when the content of a tab has become visible or has been hidden. See: https://developer.mozilla.org/en-US/docs/Web/Events/visibilitychange xhr_error Boomerang event, subscribe via BOOMR.subscribe. Fired whenever and XMLHttpRequest has an error (if its status is set). This event will only happen if BOOMR.plugins.AutoXHR is enabled. Also known as onxhrerror. Properties: Name Type Description data object XHR data xhr_init Boomerang event, subscribe via BOOMR.subscribe. Fired whenever XMLHttpRequest.open is called. This event will only happen if BOOMR.plugins.AutoXHR is enabled. Properties: Name Type Description type string XHR type (\"xhr\") xhr_load Boomerang event, subscribe via BOOMR.subscribe. Fired when an XMLHttpRequest has finished, or, if something calls BOOMR.responseEnd. Properties: Name Type Description data object Event data xhr_send Boomerang event, subscribe via BOOMR.subscribe. Fired whenever XMLHttpRequest.send is called. This event will only happen if BOOMR.plugins.AutoXHR is enabled. Properties: Name Type Description xhr object XMLHttpRequest object × Search results Close "},"BOOMR.browser.html":{"id":"BOOMR.browser.html","title":"Class: browser","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR. browser Browser feature detection flags. × Search results Close "},"BOOMR.constants.html":{"id":"BOOMR.constants.html","title":"Class: constants","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR. constants Constants visible to the world Members BEACON_TYPE_SPAS :Array.&lt;string&gt; SPA beacon types Type: Array.&lt;string&gt; MAX_GET_LENGTH :number Maximum GET URL length. Using 2000 here as a de facto maximum URL length based on: https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers Type: number × Search results Close "},"BOOMR.plugins.html":{"id":"BOOMR.plugins.html","title":"Class: plugins","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR. plugins Boomerang plugin namespace. All plugins should add their plugin object to BOOMR.plugins. A plugin should have, at minimum, the following exported functions: init(config) is_complete() See Creating Plugins for details. Classes AutoXHR BW CACHE_RELOAD Clicks ConsentInlinedPlugin Continuity CT DNS Early Errors EventTiming GUID History IFrameDelay IPv6 Memory Mobile NavigationTiming PaintTiming ResourceTiming RT SPA TPAnalytics UserTiming × Search results Close "},"BOOMR.plugins.AutoXHR.html":{"id":"BOOMR.plugins.AutoXHR.html","title":"Class: AutoXHR","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. AutoXHR Instrument and measure XMLHttpRequest (AJAX) requests. With this plugin, sites can measure the performance of XMLHttpRequests (XHRs) and other in-page interactions after the page has been loaded. This plugin also monitors DOM manipulations following a XHR to filter out \"background\" XHRs. This plugin provides the backbone for the BOOMR.plugins.SPA plugin. Single Page App navigations use XHR and DOM monitoring to determine when the SPA navigations are complete. This plugin has a corresponding Header Snippets that helps monitor XHRs prior to Boomerang loading. For information on how to include this plugin, see the Building tutorial. What is Measured When AutoXHR is enabled, this plugin will monitor several events: XMLHttpRequest requests Fetch API requests Clicks window.History changes indirectly through SPA plugins (History, Angular, etc.) When any of these events occur, AutoXHR will start monitoring the page for other events, DOM manipulations and other networking activity. As long as the event isn't determined to be background activity (i.e an XHR that didn't change the DOM at all), the event will be measured until all networking activity has completed. This means if your click generated an XHR that triggered an updated view to fetch more HTML that added images to the page, the entire event will be measured from the click to the last image completing. Usage To enable AutoXHR, you should set instrument_xhr to true: BOOMR.init({ instrument_xhr: true }); Once enabled and initialized, the window.XMLHttpRequest object will be replaced with a \"proxy\" object that instruments all XHRs. Monitoring XHRs After AutoXHR is enabled, any XMLHttpRequest.send will be monitored: xhr = new XMLHttpRequest(); xhr.open(\"GET\", \"/api/foo\"); xhr.send(null); If this XHR triggers DOM changes, a beacon will eventually be sent. This beacon will have http.initiator=xhr and the beacon parameters will differ from a Page Load beacon. See BOOMR.plugins.RT and BOOMR.plugins.NavigationTiming for details. Combining XHR Beacons By default AutoXHR groups all XHR activity that happens in the same event together. If you have one XHR that immediately triggers a second XHR, you will get a single XHR beacon. The u (URL) will be of the first XHR. If you don't want this behavior, and want to measure every XHR on the page, you can enable alwaysSendXhr=true. When set, every distinct XHR will get its own XHR beacon. BOOMR.init({ AutoXHR: { alwaysSendXhr: true } }); alwaysSendXhr can also be a list of strings (matching URLs), regular expressions (matching URLs), or a function which returns true for URLs to always send XHRs for. BOOMR.init({ AutoXHR: { alwaysSendXhr: [ \"domain.com\", /regexmatch/, ] } }); // or BOOMR.init({ AutoXHR: { alwaysSendXhr: function(url) { return url.indexOf(\"domain.com\") !== -1; } } }); Compatibility and Browser Support Currently supported Browsers and platforms that AutoXHR will work on: IE 9+ (not in quirks mode) Chrome 38+ Firefox 25+ In general we support all browsers that support MutationObserver and XMLHttpRequest. We will not use MutationObserver in IE 11 due to several browser bugs. See BOOMR.utils.isMutationObserverSupported for details. Excluding Certain Requests or DOM Elements From Instrumentation Whenever Boomerang intercepts an XMLHttpRequest (or Fetch), it will check if that request matches anything in the XHR exclude list. If it does, Boomerang will not instrument, time, send a beacon for that request, or include it in the BOOMR.plugins.SPA calculations. There are two methods of excluding XHRs: Defining the BOOMR.xhr_excludes array, or using the excludeFilters option. The BOOMR.xhr_excludes XHR excludes list is defined by creating a map, and adding URL parts that you would like to exclude from instrumentation. You can put any of the following in BOOMR.xhr_excludes: A full HREF A hostname A path Example: BOOMR = window.BOOMR || {}; BOOMR.xhr_excludes = { \"www.mydomain.com\": true, \"a.anotherdomain.net\": true, \"/api/v1/foobar\": true, \"https://mydomain.com/dashboard/\": true }; The excludeFilters gives you more control by allowing you to specify one or more callbacks that will be run for each XHR/Fetch. If any callback returns true, the XHR/Fetch will not be instrumented. BOOMR.init({ AutoXHR: { excludeFilters: [ function(anchor) { return anchor.href.match(/non-trackable/); } ] } }); Finally, the domExcludeFilters DOM filters can be used to filter out specific DOM elements from being tracked (marked as \"uninteresting\"). BOOMR.init({ AutoXHR: { domExcludeFilters: [ function(elem) { return elem.id === \"ignore\"; } ] } }); Beacon Parameters XHR beacons have different parameters in general than Page Load beacons. Many of the timestamps will differ, see BOOMR.plugins.RT All of the nt_* parameters are ResourceTiming, see BOOMR.plugins.NavigationTiming u: the URL of the resource that was fetched pgu: The URL of the page the resource was fetched on http.initiator: xhr for both XHR and Fetch requests Interesting Nodes A MutationObserver is used to detect \"interesting\" nodes. Interesting nodes are new IMG/IMAGE/IFRAME/LINK (rel=stylesheet) nodes or existing nodes that are changing their source URL. We consider the following \"uninteresting\" nodes: Nodes that have either a width or height &lt;= 1px. Nodes with either a width or height of 0px. Nodes that have display:none. Nodes that have visibility:hidden. Nodes with an opacity:0. Nodes that update their source URL to the same value. Nodes that have a blank source URL. Images with a loading=\"lazy\" attribute Nodes that have a source URL starting with about:, javascript: or data:. SCRIPT nodes because there is no consistent way to detect when they have loaded. Existing IFRAME nodes that are changing their source URL because is no consistent way to detect when they have loaded. Nodes that have a source URL that matches a AutoXHR exclude filter rule. Nodes that have been manually excluded Algorithm Here's how the general AutoXHR algorithm works: 0.0 SPA hard route change (page navigation) Monitor for XHR resource requests and interesting Mutation resource requests for 1s or at least until page onload. We extend our 1s timeout after all interesting resource requests have completed. 0.1 SPA soft route change from a synchronous call (eg. History changes as a result of a pushState or replaceState call) In this case we get the new URL when the developer calls pushState or replaceState. We create a pending event with the start time and the new URL. We do not know if they plan to make an XHR call or use a dynamic script node, or do nothing interesting (eg: just make a div visible/invisible). We also do not know if they will do this before or after they've called pushState/replaceState. Our best bet is to monitor if either a XHR resource requests or interesting Mutation resource requests will happen in the next 1s. When interesting resources are detected, we wait until they complete. We restart our 1s timeout after all interesting resources have completed. If something uninteresting happens, we set the timeout for 1 second if it wasn't already started. We'll only do this once per event since we don't want to continuously extend the timeout with each uninteresting event. If nothing happens during the additional timeout, we stop watching and fire the event. The event end time will be end time of the last tracked resource. If nothing interesting was detected during the first timeout and the URL has not changed then we drop the event. 0.2 SPA soft route change from an asynchronous call (eg. History changes as a result of the user hitting Back/Forward and we get a window.popstate event) In this case we get the new URL from location.href when our event listener runs. We do not know if this event change will result in some interesting network activity or not. We do not know if the developer's event listener has already run before ours or if it will run in the future or even if they do have an event listener. Our best bet is the same as 0.1 above. 0.3 SPA soft route change from a click that triggers a XHR before the state is changed (when spaStartFromClick is enabled). We store the time of the click If any additional XHRs come next, we track those When a pushState comes after the XHRs (before the timeout), we will \"migrate\" the click to a SPA event 1 Click initiated (Only available when no SPA plugins are enabled) User clicks on something. We create a pending event with the start time and no URL. We turn on DOM observer, and wait up to 50 milliseconds for activity. If nothing happens during the first timeout, we stop watching and clear the event without firing it. Else if something uninteresting happens, we set the timeout for 1s if it wasn't already started. We'll only do this once per event since we don't want to continuously extend the timeout with each uninteresting event. Else if an interesting node is added, we add load and error listeners and turn off the timeout but keep watching. Once all listeners have fired, we start waiting again up to 50ms for activity. If nothing happens during the additional timeout, we stop watching and fire the event. 2 XHR/Fetch initiated XHR or Fetch request is sent. We create a pending event with the start time and the request URL. We watch for all changes in XHR state (for async requests) and for load (for all requests). We turn on DOM observer at XHR Onload or when the Fetch Promise resolves. We then wait up to 50 milliseconds for activity. If nothing happens during the first timeout, we stop watching and clear the event without firing it. If something uninteresting happens, we set the timeout for 1 second if it wasn't already started. We'll only do this once per event since we don't want to continuously extend the timeout with each uninteresting event. Else if an interesting node is added, we add load and error listeners and turn off the timeout. Once all listeners have fired, we start waiting again up to 50ms for activity. If nothing happens during the additional timeout, we stop watching and fire the event. What about overlap? 3.1 XHR/Fetch initiated while a click event is pending If first click watcher has not detected anything interesting or does not have a URL, abort it If the click watcher has detected something interesting and has a URL, then Proceed with 2 above. Concurrently, click stops watching for new resources Once all resources click is waiting for have completed then fire the event. 3.2 Click initiated while XHR/Fetch event is pending Ignore click 3.3 Click initiated while a click event is pending If first click watcher has not detected anything interesting or does not have a URL, abort it. Else proceed with parallel event steps from 3.1 above. 3.4 XHR/Fetch initiated while an XHR/Fetch event is pending Add the second XHR/Fetch as an interesting resource to be tracked by the XHR pending event in progress. 3.5 XHR/Fetch initiated while SPA event is pending Add the second XHR/Fetch as an interesting resource to be tracked by the XHR pending event in progress. 3.6 SPA event initiated while an XHR event is pending Proceed with 0 above. Concurrently, XHR event stops watching for new resources. Once all resources the XHR event is waiting for have completed, fire the event. 3.7 SPA event initiated while a SPA event is pending If the pending SPA event had detected something interesting then send an aborted SPA beacon. If not, drop the pending event. Proceed with 0 above. Methods addDomExcludeFilter(cb, ctx [, name]) Add a DOM filter function to the list of functions to run to validate if an DOM element should be instrumented. Parameters: Name Type Argument Description cb BOOMR.plugins.AutoXHR.htmlElementCallback Callback to run to validate filtering of an XHR Request ctx Object Context to run {@param cb} in name string &lt;optional&gt; Optional name for the filter, called out when running exclude filters for debugging purposes Example BOOMR.plugins.AutoXHR.addDomExcludeFilter(function(elem) { return elem.id === \"ignore\"; }, null, \"exampleFilter\"); addExcludeFilter(cb, ctx [, name]) Add a XHR filter function to the list of functions to run to validate if an XHR should be instrumented. Parameters: Name Type Argument Description cb BOOMR.plugins.AutoXHR.htmlElementCallback Callback to run to validate filtering of an XHR Request ctx Object Context to run {@param cb} in name string &lt;optional&gt; Optional name for the filter, called out when running exclude filters for debugging purposes Example BOOMR.plugins.AutoXHR.addExcludeFilter(function(anchor) { var m = anchor.href.match(/some-page\\.html/g); // If matching flag to not instrument if (m &amp;&amp; m.length &gt; 0) { return true; } return false; }, null, \"exampleFilter\"); enableAutoXhr() Enables AutoXHR if not already enabled. getMutationHandler() Gets the MutationHandler Returns: Type: MutationHandler Handler getPathName(anchor) Tries to resolve href links from relative URLs. This implementation takes into account a bug in the way IE handles relative paths on anchors and resolves this by assigning a.href to itself which triggers the URL resolution in IE and will fix missing leading slashes if necessary. Parameters: Name Type Description anchor string The anchor object to resolve Returns: Type: string The unrelativized URL href init(config) Initializes the plugin. Parameters: Name Type Description config object Configuration Properties Name Type Argument Default Description instrument_xhr boolean &lt;optional&gt; Whether or not to instrument XHR AutoXHR.spaBackEndResources Array.&lt;string&gt; &lt;optional&gt; Default resources to count as Back-End during a SPA nav AutoXHR.monitorFetch boolean &lt;optional&gt; Whether or not to instrument fetch() AutoXHR.fetchBodyUsedWait number &lt;optional&gt; If the fetch response's bodyUsed flag is false, we'll wait this amount of ms before checking RT for an entry. Setting to 0 will disable this feature AutoXHR.alwaysSendXhr boolean | Array.&lt;string&gt; | Array.&lt;RegExp&gt; | Array.&lt;function()&gt; &lt;optional&gt; Whether or not to send XHR beacons for every XHR. captureXhrRequestResponse boolean &lt;optional&gt; Whether or not to capture an XHR's request and response bodies on for the xhr_load event. AutoXHR.spaIdleTimeout number &lt;optional&gt; 1000 Timeout for Single Page Applications after the final resource fetch has completed before calling the SPA navigation complete. Default is 1000ms. AutoXHR.xhrIdleTimeout number &lt;optional&gt; 50 Timeout for XHRs after final resource fetch has completed before calling the XHR complete. Default is 50ms. AutoXHR.xhrRequireChanges boolean &lt;optional&gt; true Whether or not a XHR beacon will only be triggered if there were DOM changes. AutoXHR.spaStartFromClick boolean &lt;optional&gt; false In Single Page Apps, start tracking the SPA Soft Navigation from any preceeding clicks. If false, will start from the most recent pushState. Returns: BOOMR.plugins.AutoXHR The AutoXHR plugin for chaining is_complete() This plugin is always complete (ready to send a beacon) Returns: Type: boolean true loadFinished(resource) Mark this as the time load ended via resources loadEventEnd property, if this resource has been added to the MutationHandler already notify that the resource has finished. Otherwise add this call to the lise of Events that occured. Parameters: Name Type Description resource object Resource shouldExcludeXhr(anchor) Based on the contents of BOOMR.xhr_excludes check if the URL that we instrumented as XHR request matches any of the URLs we are supposed to not send a beacon about. Parameters: Name Type Description anchor HTMLAnchorElement HTML anchor element with URL of the element checked against BOOMR.xhr_excludes Returns: Type: boolean true if intended to be excluded, false if it is not in the list of excludables Type Definitions htmlElementCallback(elem) A callback with a HTML element. Parameters: Name Type Description elem HTMLAnchorElement HTML element × Search results Close "},"BOOMR.plugins.BW.html":{"id":"BOOMR.plugins.BW.html","title":"Class: BW","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. BW The bandwidth plugin measures the bandwidth and latency of the user's network connection to your server. Please note that bandwidth detection through JavaScript is not accurate. If the user's network is lossy or is shared with other users, or network traffic is bursty, real bandwidth can vary over time. The measurement Boomerang takes is based over a short period of time, and this may not be representative of the best or worst cases. Boomerang tries to account for that by measuring not just the bandwidth, but also the error value in that measurement. For information on how to include this plugin, see the Building tutorial. Setup The bandwidth images are located in the images/ folder. You need to copy all of these images to a location on your HTTP server. You may put these images on your CDN, but be aware that this could result in increased CDN charges. You will need to configure your CDN to ignore the query string when caching these images. Usage Once Boomerang has been added to your page and BOOMR.init has been called, the bandwidth test will start once the page loads. See the list of BW options for required BOOMR.init configuration, e.g. BW.base_url. If you want the page load beacon to include the results of the bandwidth test, setting BW.block_beacon to true will force boomerang to wait for the test to complete before sending the beacon. If you do not turn on the BW.block_beacon option, you will only receive bandwidth results if they were cached in a cookie by a previous test run. IPv4 optimisations While visitor's IP address information isn't available to JavaScript, if your server can communicate the IP address to JavaScript (e.g. via HTML injection), Boomerang will use it to detect if the visitor has changed networks. See BW.user_ip for details. If your visitor has an IPv4 address, then Boomerang will also strip out the last part of the IP and use that rather than the entire IP address. This helps if visitors use DHCP on the same ISP where their IP address changes frequently, but they stay within the same subnet. If the visitor has an IPv6 address, we use the entire address. Cookie The bandwidth results are stored within a cookie. This helps ensure the bandwidth test isn't repeated for the same user repeatedly (slowing down their experience). You can customise the name of the cookie where the bandwidth will be stored via the BW.cookie option. By default this is set to BA. This cookie is set to expire in 7 days. You can change its lifetime using the BW.cookie_exp option. During that time, you can also read the value of the cookie on the server side. Its format is as follows: BA=ba=nnnnnnn&amp;be=nnn.nn&amp;l=nnnn&amp;le=nn.nn&amp;ip=iiiiii&amp;t=sssssss; The parameters are defined as: ba [integer] [bytes/s] The user's bandwidth to your server be [float] [bytes/s] The 95% confidence interval margin of error in measuring the user's bandwidth l [float] [ms] The HTTP latency between the user's computer and your server le [float] [ms] The 95% confidence interval margin of error in measuring the user's latency ip [ip address] The user's IPv4 or IPv6 address that was passed as the user_ip parameter to the init() method t [timestamp] The browser time (in seconds since the epoch) when the cookie was set Disabling the bandwidth check Finally, there may be cases when you want to completely disable the bandwidth test -- perhaps you know that your user is on a slow network, or pays by the byte (the andwidth test uses a lot of bandwidth), or is on a mobile device that cannot handle the load. In such cases you have two options: Delete the bandwdith plugin (delete BOOMR.plugins.BW) Set the BW.enabled parameter to false Methodology Bandwidth and latency are measured by downloading fixed-size images from a server and measuring the time it took to download them. We run it in the following order: First, download a 32 byte gif 10 times serially. This is used to measure latency. We discard the first measurement because that pays the price for the TCP handshake (3 packets) and TCP slow-start (4 more packets). All other image requests take two TCP packets (one for the request and one for the response). This gives us a good idea of how much time it takes to make a HTTP request from the browser to our server. Once done, we calculate the arithmetic mean, standard deviation and standard error at 95% confidence for the 9 download times that we have. This is the latency number (lat) and confidence intervl (lat_err) that we beacon back to our server. Next, download images of increasing size until one of the times out We choose image sizes so that we can narrow down on a bandwidth range as soon as possible. Image timeouts are set at between 1.2 and 1.5 seconds. If an image times out, we stop downloading larger images, and retry the largest image 4 more times. We then calculate the bandwidth for the largest 3 images that we downloaded. This should result in 7 readings unless the test timed out before that. We calculate the median, standard deviation and standard error from these values and this is the bandwidth (bw) and confidence interval (bw_err) that we beacon back to our server. Beacon Parameters This plugin adds the following parameters to the beacon: bw: User's measured bandwidth in bytes per second bw_err: 95% confidence interval margin of error in measuring user's bandwidth lat: User's measured HTTP latency in milliseconds lat_err: 95% confidence interval margin of error in measuring user's latency bw_time Timestamp (seconds since the epoch) on the user's browser when the bandwidth and latency was measured bw_debug Debug information Methods abort() Stops the bandwidth test immediately and attempts to calculate bandwidth and latency from values that it has already gathered. This method is called automatically if the bandwidth test times out. It is better to set the timeout value appropriately when calling the BOOMR.init method. init(config) Initializes the plugin. Parameters: Name Type Description config object Configuration Properties Name Type Argument Description BW.base_url string &lt;optional&gt; By default, this is set to the empty string, which has the effect of disabling the bandwidth plugin. Set the base_url parameter to the HTTP path of the directory that contains the bandwidth images to enable this test. This can be an absolute or a relative URL. If it's relative, remember that it's relative to the page that boomerang is included in and not to the javascript file. The trailing / is required. BW.cookie boolean &lt;optional&gt; The name of the cookie in which to store the measured bandwidth and latency of the user's network connection. The default name is BA. BW.cookie_exp boolean &lt;optional&gt; The lifetime in seconds of the bandwidth cookie. The default is set to 7 days. This specifies how long it will be before we run the bandwidth test again for a user, assuming their IP address doesn't change within this time. You probably do not need to change this setting at all since the bandwidth of a given network connection typically does not change by an order of magnitude on a regular basis. Note that if you're doing some kind of real-time streaming, then chances are that this bandwidth test isn't right for you, so setting this cookie to a shorter value isn't the right solution. BW.timeout number &lt;optional&gt; The timeout in seconds for the entire bandwidth test. The default is set to 15 seconds. The bandwidth test can run for a long time, and sometimes, due to network errors, it might never complete. The timeout forces the test to complete at that time. This is a hard limit. If the timeout fires, we stop further iterations of the test and attempt to calculate bandwidth with the data that we've collected at that point. Increasing the timeout can get you more data and increase the accuracy of the test, but at the same time increases the risk of the test not completing before the user leaves the page. BW.nruns number &lt;optional&gt; The number of times the bandwidth test should run. The default is set to 5. The first test is always a pilot to figure out the best way to proceed with the remaining tests. Increasing this number will increase the tests accuracy, but at the same time increases the risk that the test will timeout. It should take about 2-4 seconds per run, so consider this value along with the timeout value above. BW.test_https boolean &lt;optional&gt; By default, boomerang will skip the bandwidth test over an HTTPS connection. Establishing an SSL connection takes time, which could skew the bandwidth results. If all your traffic is sent over SSL, then running the test over SSL probably gets you what you want. If you set test_https to true, boomerang will run the test instead of skipping. BW.block_beacon boolean &lt;optional&gt; By default, the bandwidth plugin will not block boomerang from sending a beacon, so the results will not be included in the broadcast with default settings. If you set block_beacon to true, boomerang will wait for the results of the test before sending the beacon. BW.user_ip string &lt;optional&gt; The user's IP address, for detecting if networks change. Returns: BOOMR.plugins.BW The BW plugin for chaining is_complete() Whether or not this plugin is complete Returns: Type: boolean true if the plugin is complete run() Starts the bandwidth test. This method is called automatically when boomerang's BOOMR#event:page_ready event fires, so you won't need to call it yourself. Returns: BOOMR.plugins.BW The BW plugin for chaining × Search results Close "},"BOOMR.plugins.CACHE_RELOAD.html":{"id":"BOOMR.plugins.CACHE_RELOAD.html","title":"Class: CACHE_RELOAD","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. CACHE_RELOAD The cache reload plugin forces the browser to update its cached copy of boomerang. The file at url should look like the sample below. For information on how to include this plugin, see the Building tutorial. Beacon Parameters This plugin adds no parameters to the beacon. See: http://www.lognormal.com/blog/2012/06/05/updating-cached-boomerang/ http://www.lognormal.com/blog/2012/06/17/more-on-updating-boomerang/ Example &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;script src=\"boomerang.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; // required version needs to be passed in as a query string parameter // like v=0.9.123456789 var boom_ver = BOOMR.version.split('.'), var reqd_ver = location.search.replace(/.*v=([0-9\\.]+)/, '$1').split('.'); if ((boom_ver[0] &lt; reqd_ver[0]) || (boom_ver[0] == reqd_ver[0] &amp;&amp; boom_ver[1] &lt; reqd_ver[1]) || (boom_ver[0] == reqd_ver[0] &amp;&amp; boom_ver[1] == reqd_ver[1] &amp;&amp; boom_ver[2] &lt; reqd_ver[2]) ) { location.reload(true); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Methods init(config) Initializes the plugin. Parameters: Name Type Description config object Configuration Properties Name Type Argument Description CACHE_RELOAD.url string &lt;optional&gt; By default, this is set to the empty string, which has the effect of disabling the Cache Reload plugin. Set the url parameter to the URL that will do handle forcing the reload. See the example for what this URL's output should look like. Returns: BOOMR.plugins.CACHE_RELOAD The CACHE_RELOAD plugin for chaining is_complete() This plugin is always complete (ready to send a beacon) Returns: Type: boolean true is_complete() This plugin is always complete (ready to send a beacon) Returns: Type: boolean true × Search results Close "},"BOOMR.plugins.Clicks.html":{"id":"BOOMR.plugins.Clicks.html","title":"Class: Clicks","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. Clicks The Clicks plugin tracks all mouse clicks on a page and beacons them to a dedicated endpoint on your server. For information on how to include this plugin, see the Building tutorial. Beacon Parameters The following parameters are sent when a click event is triggered. element: The nodeName of the element that has been clicked (ie. A, BUTTON, NAV, etc.) id: The id of the element if specified class: The class attribute of the element document_height: The height of the document document_width: The width of the document viewport_height: The height of the viewport when the click event was triggered viewport_width: The width of the viewport when the click event was triggered Methods init(config) Initializes the plugin. Parameters: Name Type Description config object Configuration Properties Name Type Argument Description Clicks.click_url string The URL the click events will be beaconed to. Clicks.onbeforeunload boolean &lt;optional&gt; A boolean value for when to send click events. If this is true, clicks will be sent when the page is unloaded. Otherwise, click events are sent immediately as they occur. Returns: BOOMR.plugins.Clicks The Clicks plugin for chaining is_complete() This plugin is always complete (ready to send a beacon) Returns: Type: boolean true × Search results Close "},"BOOMR.plugins.ConsentInlinedPlugin.html":{"id":"BOOMR.plugins.ConsentInlinedPlugin.html","title":"Class: ConsentInlinedPlugin","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. ConsentInlinedPlugin The Consent Inlined Plugin enables website visitors to allow or disallow Boomerang to send performance monitoring data to a remote server. This plugin comes handy because Boomerang is considered in some countries in the EU and Asia as “cookie technology” and triggers certain data protection requirements. In the Boomerang opt-out/opt-in tutorial we discuss various cases how this plugin could be instrumented. How it works? There are 2 popular scenarios: Opt-out allowed: Beacons will be sent until visitor does opt-out. This plugin exposes public function window.BOOMR_OPT_OUT() and Boomerang will stop sending beacons after window.BOOMR_OPT_OUT() is called. Opt-out usually happens when a visitor doesn't agree with website's Cookie, Privacy and 3rd party policies. Opt-in required: No beacons wil be sent until visitor does opt-in. This plugin exposes public function window.BOOMR_OPT_IN() and Boomerang will hold all beacons until window.BOOMR_OPT_IN() is not called. window.BOOMR_OPT_IN() should be called after visitor accepts and agrees with website's Cookie, Privacy and 3rd party policies. Setup Currently this plugin and it's configuration are not part of Boomerang build and they must be included on the page before Boomerang loader snippet. Order It's mandatory that we follow this order in order to include and configure the plugin properly: Inject plugin configuration. Inject Consent Plugin code. Inject Boomerang loaded snippet. Example: &lt;script&gt; // 1. Inject plugin configuration. window.BOOMR_CONSENT_CONFIG = { enabled: true }; &lt;/script&gt; &lt;script&gt; // 2. Inject Consent Plugin code. ... &lt;/script&gt; &lt;script&gt; // 3. Inject Boomerang loaded snippet. ... &lt;/script&gt; Opt-out allowed In order to allow visitors to opt-out from Boomerang we need to follow 2 steps: Inject the following following configuration before ConsentInlinedPlugin code: &lt;script&gt; window.BOOMR_CONSENT_CONFIG = { enabled: true }; &lt;/script&gt; Call window.BOOMR_OPT_OUT() when a visitor doesn't agree with website's Cookie, Privacy and 3rd party policies. Opt-in required Inject the following following configuration before ConsentInlinedPlugin code: &lt;script&gt; window.BOOMR_CONSENT_CONFIG = { enabled: true, optInRequired: true }; &lt;/script&gt; Call window.BOOMR_OPT_IN() when a visitor agrees with website's Cookie, Privacy and 3rd party policies. Beacon Parameters: The following parameters are sent only on the first beacon when a visitor opts-in for first time. cip.in: Equals 1 and indicates that visitor opted-in. cip.v: Indicates the version of ConsentInlinedPlugin. It's useful to track who is using which version of the plugin because this plugin is not part of Boomerang build. Members BOOMR_OPT_IN() If opt-in to Boomerang was required and this functions is called then Boomerang will start sending beacons. BOOMR_OPT_OUT() Boomerang will not send more beacons after this function is called. × Search results Close "},"BOOMR.plugins.Continuity.html":{"id":"BOOMR.plugins.Continuity.html","title":"Class: Continuity","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. Continuity The Continuity plugin measures performance and user experience metrics beyond just the traditional Page Load timings. This plugin has a corresponding Header Snippets that helps measure events prior to Boomerang loading. Approach The goal of the Continuity plugin is to capture the important aspects of your visitor's overall user experience during page load and beyond. For example, the plugin measures when the site appeared Visually Ready, and when it was Interactive. In addition, the Continuity plugin captures in-page interactions (such as keys, clicks and scrolls), and monitors how the site performed when responding to these inputs. Finally, the Continuity plugin is utilizing cutting-edge browser performance APIs like LongTasks to get important insights into how the browser is performing. Here are some of the metrics that the Continuity plugin captures: Timers: Time to Visually Ready: When did the user feel like they could interact with the site? When did it look ready? (see below for details) Time to Interactive: After the page was Visually Ready, when was the first time the user could have interacted with the site, and had a good (performant) experience? (see below for details) Time to First Interaction: When was the first time the user tried to interact (key, click or scroll) with the site? First Input Delay: For the first interaction on the page, how responsive was it? Interaction metrics: Interactions: Keys, mouse movements, clicks, and scrolls (counts and an event log) Delayed Interactions: How often was the user's interaction delayed more than 50ms? Rage Clicks: Did the user repeatedly clicked on the same element/region? Page performance metrics: Frame Rate data: FPS during page load, minimum FPS, number of long frames Long Task data: Number of Long Tasks, how much time they took, attribution to what caused them Page Busy: Measurement of the page's busyness This data is captured during the page load, as well as when the user later interacts with the site (if configured via afterOnload). These metrics are reported at regular intervals, so you can see how they change over time. If configured, the Continuity plugin can send additional beacons after a page interaction happens (via monitorInteractions). Configuration The Continuity plugin has a variety of options to configure what it does (and what it doesn't do): Monitoring Long Tasks If monitorLongTasks is turned on, the Continuity plugin will monitor Long Tasks (if the browser supports it). Long Tasks represent work being done on the browser's UI thread that monopolize the UI thread and block other critical tasks from being executed (such as reacting to user input). Long Tasks can be caused by anything from JavaScript execution, to parsing, to layout. The browser fires LongTask events (via the PerformanceObserver) when a task takes over 50 milliseconds to execute. Long Tasks are important to measure as a Long Task will block all other user input (e.g. clicks, keys and scrolls). Long Tasks are powerful because they can give attribution about what component caused the task, i.e. the source JavaScript file. If monitorLongTasks is enabled: A PerformanceObserver will be turned on to capture all Long Tasks that happen on the page. Long Tasks will be used to calculate Time to Interactive A log (c.lt), timeline (c.t.longtask) and other Long Task metrics (c.lt.*) will be added to the beacon (see Beacon Parameters details below) The log c.lt is a JSON (or JSURL) object of compressed LongTask data. See the source code for what each attribute maps to. Long Tasks are currently a cutting-edge browser feature and will not be available in older browsers. Enabling Long Tasks should not have a performance impact on the page load experience, as collecting of the tasks are via the lightweight PerformanceObserver interface. Monitoring Page Busy If monitorPageBusy is turned on, the Continuity plugin will measure Page Busy. Page Busy is a way of measuring how much work was being done on the page (how \"busy\" it was). Page Busy is calculated via setInterval() polling: a timeout is scheduled on the page at a regular interval, and busyness is detected if that timeout does not fire at the time it was expected to. Page Busy is a percentage -- 100% means that the browser was entirely busy doing other things, while 0% means the browser was idle. Page Busy is just an estimate, as it uses sampling. As an example, if you have a high number of small tasks that execute frequently, Page Busy might run at a frequency that it either detects 100% (busy) or 0% (idle). Page Busy is not the most efficient way of measuring what the browser is doing, but since it is calculated via setInterval(), it is supported in all browsers. The Continuity plugin currently measures Page Busy by polling every 32 milliseconds. Page Busy is disabled if Long Tasks are supported in the browser. Page Busy can be an indicator of how likely the user will have a good experience when they interact with it. If Page Busy is 100%, the user may see the page lag behind their input. If monitorPageBusy is enabled: The Page Busy monitor will be active (polling every 32 milliseconds) (unless Long Tasks is supported and enabled) Page Busy will be used to calculate Time to Interactive A timeline (c.t.busy) and the overall Page Busy % (c.b) will be added to the beacon (see Beacon Parameters details below) Enabling Page Busy monitoring should not have a noticeable effect on the page load experience. The 32-millisecond polling is lightweight and should barely register on JavaScript CPU profiles. Monitoring Frame Rate If monitorFrameRate is turned on, the Continuity plugin will measure the Frame Rate of the page via requestAnimationFrame. requestAnimationFrame is a browser API that can be used to schedule animations that run at the device's refresh rate. It can also be used to measure how many frames were actually delivered to the screen, which can be an indicator of how good the user's experience is. requestAnimationFrame is available in all modern browsers. If monitorFrameRate is enabled: requestAnimationFrame will be used to measure Frame Rate Frame Rate will be used to calculate Time to Interactive A timeline (c.t.fps) and many Frame Rate metrics (c.f.*) will be added to the beacon (see Beacon Parameters details below) Enabling Frame Rate monitoring should not have a noticeable effect on the page load experience. The frame callback may happen up to the device's refresh rate (which is often 60 FPS), and the work done in the callback should be barely visible in JavaScript CPU profiles (often less than 5ms over a page load). Monitoring Interactions If monitorInteractions is turned on, the Continuity plugin will measure user interactions during the page load and beyond. Interactions include: Mouse Clicks: Where the user clicked on the screen Rage Clicks: Clicks to the same area repeatedly Mouse Movement: Rough mouse movement will be tracked, but these interactions will not send a beacon on their own, nor be used for Time to First Interaction calculations. Keyboard Presses: Individual key codes are not captured Scrolls: How frequently and far the user scrolled Distinct Scrolls: Scrolls that happened over 2 seconds since the last scroll Page Visibility changes Orientation changes Pointer Down and Up, Mouse Down and Touch Start: Timestamp of these events is used to track and calculate interaction metrics like First Input Delay These interactions are monitored and instrumented throughout the page load. By using the event's timeStamp, we can detect how long it took for the physical event (e.g. mouse click) to execute the JavaScript listening handler (in the Continuity plugin). If there is a delay, this is tracked as an Interaction Delay. Interaction Delays can be an indicator that the user is having a degraded experience. The very first interaction delay will be added to the beacon as the First Input Delay - this is tracked as the user's first experience with your site is important. In addition, if afterOnLoad is enabled, these interactions (except Mouse Movements) can also trigger an interaction beacon after the Page Load. afterOnLoadMaxLength can be used to control how many milliseconds after Page Load interactions will be measured for. After a post-Load interaction occurs, the plugin will wait for afterOnLoadMinWait milliseconds before sending the interaction beacon. If another interaction happens within that timeframe, the plugin will wait another afterOnLoadMinWait milliseconds. This is to ensure that groups of interactions will be batched together. The plugin will wait up to 60 seconds to batch groups of interactions together, at which point a beacon will be sent immediately. If monitorInteractions is enabled: Passive event handlers will be added to monitor clicks, keys, etc. A log and many interaction metrics (c.i.*, c.ttfi) will be added to the beacon (see Beacon Parameters details below) For interaction beacons, the following will be set: rt.tstart will be the timestamp of the first interaction rt.end will be the timestamp of the last interaction rt.start = 'manual' http.initiator = 'interaction' Enabling interaction monitoring will add lightweight passive event handlers to scroll, click, mousemove and keydown events. These event handlers should not delay the user's interaction, and are used to measure delays and keep a log of interaction events. Monitoring Page Statistics If monitorStats is turned on, the Continuity plugin will measure statistics about the page and browser over time. These statistics include: Memory Usage: usedJSHeapSize (Chrome-only) Battery Level DOM Size: Number of bytes of HTML in the root frame DOM Length: Number of DOM nodes in the root frame Mutations: How often and how much the page is changing If monitorStats is enabled: Events and polls will be setup to monitor the above statistics A timeline (c.t.*) of these statistics will be added to the beacon (see details below) Enabling Page Statistic monitoring adds a poll to the page every second, gathering the above statistics. These statistics should take less than 5ms JavaScript CPU on a desktop browser each poll, but this monitoring is probably the most expensive of the Continuity plugin monitors. This option is off by default, and can be turned on via the monitorStats config option. Monitoring Layout Shifts If monitorLayoutShifts is turned on, the Continuity plugin will measure visual instability via the Layout Instability API, and will calculate the Cumulative Layout Shift (CLS) score. The Cumulative Layout Shift (CLS) score approximates the severity of visual layout changes by monitoring how DOM nodes shift during the user experience. A CLS of 0 indicates a stable view where no DOM nodes shifted. Each time an unexpected layout shifts occur, the CLS increases. CLS is represented in decimal form, with a value of 0.1 indicating a fraction of the screen's elements were affected. CLS values can be larger than 1.0 if the layout shifts multiple times. See web.dev/cls for a more detailed explanation. CLS is included on the beacon as c.cls, and resets each beacon, so represents the CLS since the last beacon. This option is on by default, and can be disabled via the monitorLayoutShifts config option. New Timers There are 4 new timers from the Continuity plugin that center around user interactions: Time to Visually Ready (VR) Time to Interactive (TTI) Time to First Interaction (TTFI) First Input Delay (FID) Time to Interactive (TTI), at it's core, is a measurement (timestamp) of when the page was interact-able. In other words, at what point does the user both believe the page could be interacted with, and if they happened to try to interact with it then, would they have a good experience? To calculate Time to Interactive, we need to figure out two things: Does the page appear to the visitor to be interactable? We'll use one or more Visually Ready Signals to determine this If so, what's the first time a user could interact with the page and have a good experience? We'll use several Time to Interactive Signals to determine this Visually Ready For the first question, \"does the page appear to be interactable?\", we need to determine when the page would look to the user like they could interact with it. It's only after this point that TTI could happen. Think of Visually Ready (VR) as the anchor point of TTI -- it's the earliest possible timestamp in the page's lifecycle that TTI could happen. We have a few signals that might be appropriate to use as Visually Ready: First Paint (if available) We should wait at least for the first paint on the page i.e. IE's msFirstPaint or Chrome's firstPaintTime These might just be paints of white, so they're not the only signal we should use First Contentful Paint (if available) Via PaintTiming Largest Contentful Paint (if available) Via Largest Contentful Paint API domContentLoadedEventEnd \"The DOMContentLoaded event is fired when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading\" This happens after domInteractive Available in NavigationTiming browsers via a timestamp and all other browser if we're on the page in time to listen for readyState change events Hero Images (if defined) Instead of tracking all Above-the-Fold images, it could be useful to know which specific images are important to the site owner Defined via a simple CSS selector (e.g. .hero-images) Can be measured via ResourceTiming Will add Hero Images Ready c.tti.hi to the beacon \"My Framework is Ready\" (if defined) A catch-all for other things that we can't automatically track This would be an event or callback from the page author saying their page is ready They could fire this for whatever is important to them, i.e. when their page's click handlers have all registered Will add Framework Ready c.tti.fr to the beacon Once the last of all of the above have happened, Visually Ready has occurred. Visually Ready will add c.tti.vr to the beacon. Visually Ready is only included on regular Page Load and Single Page App Hard navigation beacons. It is not suitable for Single Page App Soft navigation beacons as the page has already been visually ready at the start of the soft navigation. Controlling Visually Ready via Framework Ready There are two additional options for controlling when Visually Ready happens: via Framework Ready or Hero Images. If you want to wait for your framework to be ready (e.g. your SPA has loaded or a button has a click handler registered), you can add an option ttiWaitForFrameworkReady. Once enabled, TTI won't be calculated until the following is called: // my framework is ready if (BOOMR &amp;&amp; BOOMR.plugins &amp;&amp; BOOMR.plugins.Continuity) { BOOMR.plugins.Continuity.frameworkReady(); } Controlling Visually Ready via Hero Images If you want to wait for your hero/main images to be loaded before Visually Ready is measured, you can give the plugin a CSS selector via ttiWaitForHeroImages. If set, Visually Ready will be delayed until all IMGs that match that selector have loaded, e.g.: BOOMR.init({ ... Continuity: { enabled: true, ttiWaitForHeroImages: \".hero-image\" } }); Note this only works in ResourceTiming-supported browsers (and won't be used in older browsers). If no images match the CSS selector at Page Load, this setting will be ignored (the plugin will not wait for a match). Time to Interactive After the page is Visually Ready for the user, if they were to try to interact with the page (click, scroll, type), when would they have a good experience (i.e. the page responded in a satisfactory amount of time)? We can use some of the signals below, when available: Frame Rate (FPS) Available in all modern browsers: by using requestAnimationFrame we can get a sense of the overall frame rate (FPS) To ensure a \"smooth\" page load experience, ideally the page should never drop below 20 FPS. 20 FPS gives about 50ms of activity to block the main thread at any one time Long Tasks Via the PerformanceObserver, a Long Tasks fires any time the main thread was blocked by a task that took over 50ms such as JavaScript, layout, etc Great indicator both that the page would not have been interact-able and in some cases, attribution as to why Page Busy via setInterval By measuring how long it takes for a regularly-scheduled callback to fire, we can detect other tasks that got in the way Can give an estimate for Page Busy Percentage (%) Available in every browser Delayed interactions If the user interacted with the page and there was a delay in responding to the input The waitAfterOnload option will delay the beacon for up to that many milliseconds if Time to Interactive doesn't happen by the browser's load event. You shouldn't set it too high, or the likelihood that the page load beacon will be lost increases (because of the user navigating away first, or closing their browser). If waitAfterOnload is reached and TTI hasn't happened yet, the beacon will be sent immediately (missing the TTI timer). If you set waitAfterOnload to 0 (or it's not set), Boomerang will send the beacon at the regular page load event. If TTI didn't yet happen, it won't be reported. If you want to set waitAfterOnload, we'd recommend a value between 1000 and 5000 (1 and 5 seconds). Time to Interaction will add c.tti to the beacon. It will also add c.tti.m, which is the higest-accuracy method available for TTI calculation: lt (Long Tasks), raf (FPS), or b (Page Busy). Time to Interaction is only included on regular Page Load and Single Page App Hard navigation beacons. It is not suitable for Single Page App Soft navigation beacons as the page is already interactive at the start of the soft navigation. Algorithm Putting these two timers together, here's how we measure Visually Ready and Time to Interactive: Determine the highest Visually Ready timestamp (VRTS): Largest Contentful Paint (if available) First Contentful Paint (if available) First Paint (if available) domContentLoadedEventEnd Hero Images are loaded (if configured) Framework Ready (if configured) After VRTS, calculate Time to Interactive by finding the first period of 500ms where all of the following are true: There were no Long Tasks The FPS was always above 20 (if available) Page Busy was less than 10% (if the above aren't available) Time to First Interaction Time to First Interaction (TTFI) is the first time a user interacted with the page. This may happen during or after the page's load event. The events that are tracked are: Mouse Clicks Keyboard Presses Scrolls Page Visibility changes Orientation changes Time to First Interaction is not affected by Mouse Movement. Time to First Interaction will add c.ttfi to the beacon. If the user does not interact with the page by the beacon, there will be no c.ttfi on the beacon. First Input Delay If the user interacted with the page by the time the beacon was sent, the Continuity plugin will also measure how long it took for the JavaScript event handler to fire. This can give you an indication of the page being otherwise busy and unresponsive to the user if the callback is delayed. This time (measured in milliseconds) is added to the beacon as c.fid. The polyfill for FirstInputDelay calculation from previous version of this plugin has been updated to match the latest industry standards for FID. This polyfill now evaluates click, mousedown, keydown, touchstart, pointerdown followed by pointerup events as indicators for First Input Delay calculations. Note if the EventTiming plugin is included, this measurement is deferred to the First Input Delay calculated by that plugin. Timelines If sendTimeline is enabled, many of the above options will add bucketed \"timelines\" to the beacon. The Continuity plugin keeps track of statistics, interactions and metrics over time by keeping track of these counts at a granularity of 100-millisecond intervals. As an example, if you are measuring Long Tasks, its timeline will have entries whenever a Long Task occurs. Not every timeline will have data for every interval. As an example, the click timeline will be sparse except for the periods where there was a click. Statistics like DOM Size are captured only once every second. The Continuity plugin is optimized to use as little memory as possible for these cases. Compressed Timeline Format If sendTimeline is enabled, the Continuity plugin will add several timelines as c.t.[name] to the beacon in a compressed format. An example timeline may look like this: c.t.fps = 03*a*657576576566766507575*8*65 c.t.domsz = 11o3,1o4 c.t.mousepct = 2*5*0053*4*00050718 The format of the compressed timeline is as follows: [Compression Type - 1 character][Data - everything else] Compression Type is a single character that denotes how each timeline's bucket numbers are compressed: 0 (for smaller numbers): Each number takes a single character, encoded in Base-64 If a number is &gt;= 64, the number is converted to Base-36 and wrapped in . characters 1 (for larger numbers) Each number is separated by ,s Each number is encoded in Base-36 2 (for percentages) Each number takes two characters, encoded in Base-10 If a number is &lt;= 0, it is 00 If a number is &gt;= 100, it is __ In addition, for repeated numbers, the format is as follows: *[Repeat Count]*[Number] Where: Repeat Count is encoded Base-36 Number is encoded per the rules above From the above example, the data would be decompressed to: c.t.fps = [3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 7, 5, 7, 6, 5, 7, 6, 5, 6, 6, 7, 6, 6, 5, 0, 7, 5, 7, 5, 6, 6, 6, 6, 6, 6, 6, 6, 5]; c.t.domsz = [2163, 2164]; c.t.mousepct = [0, 0, 0, 0, 0, 53, 0, 0, 0, 0, 5, 7, 18]; The timeline can be decompressed via decompressBucketLog (for debug builds). The Continuity Epoch (c.e) and Continuity Last Beacon (c.lb) are timestamps (Base-36) that indicate what timestamp the first bucket represents. If both are given, the Last Beacon timestamp should be used. For example: c.e=j5twmlbv // 1501611350395 c.lb=j5twmlyk // 1501611351212 c.t.domsz=11o3,1o4 // 2163, 2164 using method 1 In the above example, the first value of 2163 (1o3 Base-36) happened at 1501611351212. The second value of 2164 (1o4 Base-36) happened at 1501611351212 + 100 = 1501611351312. For all of the available timelines, see the Beacon Parameters list below. Logs If sendLog is enabled, the Continuity plugin will add a log to the beacon as c.l. The following events will generate a Log entry with the listed parameters: Scrolls (type 0): y: Y pixels Clicks (type 1): x: X pixels y: Y pixels Mouse Movement (type 2): Data is captured at minimum 10 pixel granularity x: X pixels y: Y pixels Keyboard presses (type 3): (no data is captured) Visibility Changes (type 4): s 0: visible 1: hidden 2: prerender 3: unloaded Orientation Changes (type 5): a: Angle The log is put on the beacon in a compressed format. Here is an example log: c.l=214y,xk9,y8p|142c,xk5,y8v|34kh The format of the compressed timeline is as follows: [Type][Timestamp],[Param1 type][Param 1 value],[... Param2 ...]|[... Event2 ...] Type is a single character indicating what type of event it is, per above Timestamp (navigationStart epoch in milliseconds) is Base-36 encoded Each parameter follows, separated by commas: The first character indicates the type of parameter The subsequent characters are the value of the parameter, Base-36 encoded From the above example, the data would be decompressed to: [ { \"type\": \"mouse\", \"time\": 1474, \"x\": 729, \"y\": 313 }, { \"type\": \"click\", \"time\": 5268, \"x\": 725, \"y\": 319 }, { \"type\": \"key\", \"time\": 5921, } ] The plugin will keep track of the last logMaxEntries entries in the log (default 100). The timeline can be decompressed via decompressLog (for debug builds). Overhead When enabled, the Continuity plugin adds new layers of instrumentation to each page load. It also keeps some of this instrumentation enabled after the load event, if configured. By default, these instrumentation \"monitors\" will be turned on: Long Tasks via PerformanceObserver Frame Rate (FPS) via requestAnimationFrame Page Busy via setInterval polling (if Long Tasks aren't supported) Monitoring of interactions such as mouse clicks, movement, keys, and scrolls Page statistics like DOM size/length, memory usage, and mutations Each of these monitors is designed to be as lightweight as possible, but enabling instrumentation will always incur non-zero CPU time. Please read the above sections for overhead information on each monitor. With the Continuity plugin enabled, during page load, you may see the plugin's total CPU usage over the entire length of that page load reach 10-35ms, depending on the hardware and makeup of the host-site. In general, for most modern websites, this means Boomerang should still only account for a few percentage points of overall page CPU usage with the Continuity plugin enabled. The majority of this CPU usage increase is from Page Statistics reporting and FPS monitoring. You can disable either of these monitors individually if desired (monitorStats and monitorFrameRate). During idle periods (after page load), the Continuity plugin will continue monitoring the above items if afterOnload is enabled. This may increase Boomerang JavaScript CPU usage as well. Again, the majority of this CPU usage increase is from Page Statistic reporting and Frame Rate monitoring, and can be disabled. When Long Tasks aren't supported by the browser, Page Busy monitoring via setInterval should only 1-2ms CPU during and after page load. Beacon Parameters The following parameters will be added to the beacon: c.b: Page Busy percentage (Base-10) c.c.r: Rage click count (Base-10) c.c: Click count (Base-10) c.cls: Cumulative Layout Shift score (since last beacon) (Base-10 fraction) c.e: Continuity Epoch timestamp (when everything started measuring) (Base-36) c.f.d: Frame Rate duration (how long it has been measuring) (milliseconds) (Base-10) c.f.l: Number of Long Frames (&gt;= 50ms) (Base-10) c.f.m: Minimum Frame Rate (Base-10) per COLLECTION_INTERVAL c.f.s: Frame Rate measurement start timestamp (Base-36) c.f: Average Frame Rate over the Frame Rate Duration (Base-10) c.fid: First Input Delay (milliseconds) (Base-10) c.i.a: Average interaction delay (milliseconds) (Base-10) c.i.dc: Delayed interaction count (Base-10) c.i.dt: Delayed interaction time (milliseconds) (Base-10) c.k.e: Keyboard ESC count (Base-10) c.k: Keyboard event count (Base-10) c.l: Log (compressed) c.lb: Last Beacon timestamp (Base-36) c.lt.n: Number of Long Tasks (Base-10) c.lt.tt: Total duration of Long Tasks (milliseconds) (Base-10) c.lt: Long Task data (compressed) c.m.n: Mouse movement pixels (Base-10) c.m.p: Mouse movement percentage (Base-10) c.s.d: Distinct scrolls (scrolls that happen 2 seconds after the last) (Base-10) c.s.p: Scroll percentage (Base-10) c.s.y: Scroll y (pixels) (Base-10) c.s: Scroll count (Base-10) c.t.click: Click timeline (compressed) c.t.domln: DOM Length timeline (compressed) c.t.domsz: DOM Size timeline (compressed) c.t.fps: Frame Rate timeline (compressed) c.t.inter: Interactions timeline (compressed) c.t.interdly: Delayed Interactions timeline (compressed) c.t.key: Keyboard press timeline (compressed) c.t.longtask: LongTask timeline (compressed) c.t.mem: Memory usage timeline (compressed) c.t.mouse: Mouse movements timeline (compressed) c.t.mousepct: Mouse movement percentage (of full screen) timeline (compressed) c.t.scroll: Scroll timeline (compressed) c.t.scrollpct:Scroll percentage (of full page) timeline (compressed) c.t.mut: DOM Mutations timeline (compressed) c.ttfi: Time to First Interaction (milliseconds) (Base-10) c.tti.fr: Framework Ready (milliseconds) (Base-10) c.tti.hi: Hero Images ready (milliseconds) (Base-10) c.tti.m: Time to Interactive Method (lt, raf, b) c.tti.vr: Visually Ready (milliseconds) (Base-10) c.tti: Time to Interactive (milliseconds) (Base-10) Methods frameworkReady() Signal that the framework is ready init(config) Initializes the plugin. Parameters: Name Type Description config object Configuration Properties Name Type Argument Default Description Continuity.monitorLongTasks boolean &lt;optional&gt; true Whether or not to monitor Long Tasks. Continuity.monitorPageBusy boolean &lt;optional&gt; true Whether or not to monitor Page Busy. Continuity.monitorFrameRate boolean &lt;optional&gt; true Whether or not to monitor Frame Rate. Continuity.monitorInteractions boolean &lt;optional&gt; true Whether or not to monitor Interactions. Continuity.monitorStats boolean &lt;optional&gt; true Whether or not to monitor Page Statistics. Continuity.monitorLayoutShifts boolean &lt;optional&gt; true Whether or not to monitor Layout Shifts Continuity.afterOnload boolean &lt;optional&gt; false Whether or not to monitor Long Tasks, Page Busy, Frame Rate, interactions and Page Statistics after onload (up to afterOnloadMaxLength). Continuity.afterOnloadMaxLength number &lt;optional&gt; 60000 Maximum time (milliseconds) after onload to monitor. Continuity.afterOnloadMinWait boolean &lt;optional&gt; 5000 Minimum time after an interaction to wait for more interactions before batching the interactions into a beacon. Continuity.waitAfterOnload boolean | number &lt;optional&gt; false If set to a number, how long after onload to wait for Time to Interactive to happen before sending a beacon (without TTI). Continuity.ttiWaitForFrameworkReady boolean &lt;optional&gt; false Whether or not to wait for BOOMR.plugins.Continuity.frameworkReady before Visually Ready (and thus Time to Interactive) can happen. Continuity.ttiWaitForHeroImages boolean | string &lt;optional&gt; false If set to a string, the CSS selector will wait until the specified images have been loaded before Visually Ready (and thus Time to Interactive) can happen. Continuity.sendLog boolean &lt;optional&gt; true Whether or not to send the event log with each beacon. Continuity.logMaxEntries boolean &lt;optional&gt; 100 How many log entries to keep. Continuity.sendTimeline boolean &lt;optional&gt; true Whether or not to send the timeline with each beacon. Returns: BOOMR.plugins.Continuity The Continuity plugin for chaining is_complete() Whether or not this plugin is complete Returns: Type: boolean true if the plugin is complete × Search results Close "},"BOOMR.plugins.CT.html":{"id":"BOOMR.plugins.CT.html","title":"Class: CT","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. CT The CT plugin tests how long an item stays in the browser's cache. Given a URL, this plugin loads the specified URL and measures how long it took to load. You can use the results of this plugin to determine how cacheable a URL is across browsers and over time. For information on how to include this plugin, see the Building tutorial. Usage This plugin requires a server-generated JavaScript file that calls BOOMR.plugins.CT.loaded with the server's timestamp. This file is specified as CT.cached_url and should return an application/javascript file with contents similar to: BOOMR.plugins.CT.loaded(12345); // server-generated timestamp Beacon Parameters This plugin adds the following parameters to the beacon: cch.ce: Time when the cached item started to load cch.lt: Load time of cached item (ms) cch.se: Server timestamp Methods init(config) Initializes the plugin. Parameters: Name Type Description config object Configuration Properties Name Type Description CT.cached_url string URL to load Returns: BOOMR.plugins.CT The CT plugin for chaining × Search results Close "},"BOOMR.plugins.DNS.html":{"id":"BOOMR.plugins.DNS.html","title":"Class: DNS","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. DNS Plugin to measure DNS latency. This code is based on Carlos Bueno's guide to DNS on the Facebook Note For information on how to include this plugin, see the Building tutorial. Setup Measuring DNS requires some server-side set up, as documented in detail by Facebook engineer Carlos Bueno, so go read his post for everything you'll need to set this up. In brief, the points he covers are: Set up a wildcard hostname, perferably one that does not share cookies with your main site. Give it a low TTL, say, 60 seconds, so you don't pollute downstream caches. Set up a webserver for the wildcard hostname that serves the images named A.gif and B.gif (from the images/ subdirectory) as fast as possible. Make sure that KeepAlive, Nagle, and any caching headers are turned off. Include the DNS plugin (see Building) Tell the DNS plugin where to get its images from via DNS.base_url Steps 1 and 2 are complicated, and if you don't have full control over your DNS server, then it may be impossible for you to use this plugin. Beacon Parameters This plugin adds the following parameters to the beacon: dns.t: The worst-case DNS latency from the user's browser to your DNS server. Methods init(config) Initializes the plugin. Parameters: Name Type Description config object Configuration Properties Name Type Description DNS.base_url string The base_url parameter tells the DNS plugin where it can find its DNS testing images. This URL must contain a wildcard character (*) which will be replaced with a random string. The images will be appended to this string without any other modification. If you have any pages served over HTTPS, then this URL should be configured to work over HTTPS as well as HTTP. The protocol part of the URL will be automatically changed to fit the current document. Returns: BOOMR.plugins.DNS The DNS plugin for chaining Example BOOMR.init({ DNS: { base_url: \"http://*.yoursite.com/images/\" } }); is_complete() Whether or not this plugin is complete Returns: Type: boolean true if the plugin is complete × Search results Close "},"BOOMR.plugins.Early.html":{"id":"BOOMR.plugins.Early.html","title":"Class: Early","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. Early Plugin to send early beacons Non-SPA: Send when config is loaded (onconfig event) if: after DOMContentLoaded before onload not in prerender autorun is true not a reload or back/forward navigation If we were in prerender, send when visible (prerender_to_visible event) if config was received and the conditions above are met. If onconfig fired before DOMContentLoaded, try again when DOMContentLoaded fires. SPA: Send when the count of resources we're waiting for drops to 0 for the first time + SPA_EARLY_TIMEOUT (controlled by AutoXHR plugin) and if: not in prerender not a reload or back/forward navigation Current limitations: Does not check if before DOMContentLoaded. Does not retry sending at prerender_to_visible event. × Search results Close "},"BOOMR.plugins.Errors.html":{"id":"BOOMR.plugins.Errors.html","title":"Class: Errors","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. Errors The Errors plugin automatically captures JavaScript and other errors from your web application. This plugin has a corresponding Header Snippets that helps capture errors prior to Boomerang loading. For information on how to include this plugin, see the Building tutorial. Sources of Errors When the Errors plugin is enabled, the following sources of errors are captured: JavaScript runtime errors captured via the onerror global event handler XMLHttpRequest responses that were not successful. Note BOOMR.plugins.AutoXHR is required if using this. Any calls to window.console.error JavaScript runtime errors that happen during a callback for addEventListener (disabled by default, enabled via monitorEvents) JavaScript runtime errors that happen during a callback for setTimeout and setInterval (disabled by default, enabled via monitorTimeout) Manually sent errors via BOOMR.plugins.Errors.send Functions that threw an exception that were wrapped via BOOMR.plugins.Errors.wrap Functions that threw an exception that were run via BOOMR.plugins.Errors.test JavaScript runtime errors captured via the unhandledrejection global event handler (disabled by default, enabled via monitorRejections) JavaScript runtime warnings captured via the Reporting API (disabled by default, enabled via monitorReporting) All of the options above can be manually turned off. Supported Browsers The Errors plugin can be enabled for all browsers, though some older browsers may not be able to capture the full breadth of sources of errors. Due to the lack of error detail on some older browsers, some errors may be reported more than once. Notable browsers: Internet Explorer &lt;= 8: Does not support capturing XMLHttpRequest errors. Manually Sending Errors Besides automatically capturing errors from onerror, XMLHttpRequest, console.error or event handlers such as setTimeout, you can also manually send errors. There are three ways of doing this as follows: BOOMR.plugins.Errors.send: Immediately sends an error. BOOMR.plugins.Errors.wrap: Wraps a function with error tracking BOOMR.plugins.Errors.test: Runs the function and captures any errors. Error callback You can specify an onError function that the Errors plugin will call any time an error is captured on the page. If your onError function returns true, the error will be captured. If your onError function does not return true, the error will be ignored. Example: BOOMR.init({ Errors: { onError: function(err) { if (err.message &amp;&amp; err.message.indexOf(\"internally handled\")) { return false; } return true; } } }); When to Send Errors By default, errors captured during the page load will be sent along with the page load beacon. Errors that happen after the page load will not be captured or sent. To enable capturing of errors after page load, you need to set sendAfterOnload to true. If set, errors that happen after the page load will be sent at most once every sendInterval (which defaults to 1 second) on a new beacon. Example: BOOMR.init({ Errors: { sendAfterOnload: true, sendInterval: 5000 } }); How Many Errors to Capture The Errors plugin will only capture up to maxErrors (defaults to 10) distinct errors on the page. Please note that duplicate errors (those with the same function name, stack, and so on) are tracked as single distinct error, with a count of how many times it was seen. You can increase (or decrease) maxErrors. For example: BOOMR.init({ Errors: { maxErrors: 20 } }); Dealing with Script Error When looking at JavaScript errors, you will likely come across the generic error message: Script error. Script Error. is the message that browsers send to the window.onerror global exception handler when the error was triggered by a script loaded from a different (cross) origin. window.onerror is used by Boomerang so that it gets notified of all unhandled exceptions. The Script Error. string is given instead of the real error message and does not contain any useful information about what caused the error. In addition, there is no stack associated with the message, so it's impossible to know where or why the error occurred. Browsers mask the real error message for cross-origin scripts due to security and privacy concerns - they don't want to leak sensitive information in the message or stack. The only thing that window.onerror knows for cross-origin scripts is that an error occurred, not where or why. Example For an example of where you'd see Script Error., consider the following code that lives on website.com: &lt;html&gt; &lt;head&gt; &lt;title&gt;website.com&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; window.onerror = function(message, url, line, column, error) { console.log(\"window.onerror: \" + message); console.log((error &amp;&amp; error.stack) ? error.stack : \"(no stack)\"); }; &lt;/script&gt; &lt;script src=\"my-script.js\"&gt;&lt;/script&gt; &lt;script src=\"https://anothersite.com/my-script.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Assume my-script.js is the same file being served from both website.com and anothersite.com: function runCode() { a = b + 1; } runCode(); When my-script.js is loaded from website.com, it will be executed twice: First on the same-origin, where we'll see the full error message followed by the stack: window.onerror: Uncaught ReferenceError: b is not defined ReferenceError: b is not defined at runCode (my-script.js:2) at my-script.js:5 Then, it will be loaded from https://anothersite.com/my-script.js, which will be considered cross-origin and only Script Error. will be logged: window.onerror: Script error. (no stack) As you can see, browser shares the full details of the exception when it's served from the same origin as the website, but if it's served from any other origin, it will be considered cross-origin and no details will be shared. Note that while the browser only shares Script Error. to window.onerror for cross-origin scripts, if you have browser developer tools open, the browser will show you the full error message in the Console. This is because there aren't any security or privacy concerns for a developer looking at their own machine's information. When You'll See Script Error Unfortunately Script Error. will be shown in many legitimate use-cases, such as: When serving your website's JavaScript from a CDN (since it will be coming from a different origin) When loading a library such as jQuery or Angular from their CDN, i.e. Google's Hosted Libraries or cdnjs When a third-party script loads from another domain The good news is that in many of these cases, there are changes you can make to ensure the full error message and stack are shared with window.onerror. Fixing Script Error To ensure a cross-origin script shares full error details with window.onerror, you'll need to do two things: Add crossorigin=\"anonymous\" to the &lt;script&gt; tag The crossorigin=\"anonymous\" attribute tells the browser that the script should be fetched without sending any cookies or HTTP authentication Add the Access-Control-Allow-Origin (ACAO) header to the JavaScript file's response. The Access-Control-Allow-Origin header is part of the Cross Origin Resource Sharing (CORS) standard. The ACAO header must be set in the JavaScript's HTTP response headers. An example header that sets ACAO for all calling origins would be: Access-Control-Allow-Origin: * If both conditions are true, cross-origin JavaScript files will report errors to window.onerror with the correct error message and full stack. The biggest challenge to getting this working is that (1) is within the site's control while (2) can only be configured by the owner of the JavaScript. If you're loading JavaScript from a third-party, you will need to encourage them to add the ACAO header if it's not already set. The good news is that many CDNs and third-parties set the ACAO header already. Workarounds for Third Parties that aren't sending ACAO One way to help monitor for errors coming from third-party scripts that aren't setting ACAO (and aren't within your control) is by manually wrapping calls to any of the third-party script's functions in a try {} catch {}. try { // calls a cross-origin script that doesn't have ACAO runThirdPartyCode(); } catch (e) { // report on error with e.message and e.stack } If runThirdPartyCode() causes any errors, the catch {} handler will get the full details of the exception. Unfortunately this won't work for functions that are executed in the third-party script as a result of browser events or callbacks (since you're not wrapping them). When using Boomerang to monitor JavaScript errors, Boomerang automatically wraps some of the built-in browser APIs such as setTimeout, setInterval (via the monitorTimeout option) and addEventListener (via the monitorEvents option) with a minimal-overhead wrapper. It does this to help ensure as many cross-origin exceptions as possible have full stack details. You may also do this manually via BOOMR.plugin.Errors.wrap(function). Note that enabling monitorTimeout or monitorEvents can have side-effects and has caused compatibility issues with JavaScript code on some sites. Enabling those options is only recommended after verifying there are no problems. Why is Boomerang in my Error Stack? When looking at error reports, you may find errors that have a function in boomerang.js (or /boomerang/) on the stack. Why is that? Is Boomerang causing errors on your site? One of the ways that Boomerang is able to monitor and measure your site's performance is by wrapping itself around some of the core browser APIs. Boomerang only does this in a few places, if absolutely necessary -- namely, when the browser doesn't provide a native \"monitoring\" interface for something that needs to be tracked. One example is for XMLHttpRequests, as there are no browser APIs to monitor when XHRs load. To monitor XHRs, Boomerang swaps in its own window.XMLHttpRequest object, wrapping around the native methods. When an XHR is created (via .open()), the lightweight Boomerang wrapper is executed first so it can log a start timestamp. When the XHR finishes (via a readyState change), Boomerang can log the end timestamp and report on the XHR's performance. Examples of Boomerang wrapping native methods include: XMLHttpRequest if the XHR instrumentation is turned on console.error if error tracking is turned on setTimeout and setInterval(if error tracking is turned on (with monitorTimeout) addEventListener and removeEventListener (if error tracking is turned on (with monitorEvents) All of these wrapped functions come into play when you see an error stack with a boomerang.js function in it. Often, the boomerang.js function will be at the bottom of the stack (the first function called). This does not mean Boomerang caused the error, merely that the monitoring code was running before the error occurred. The actual error happens towards the top of the stack -- the function that ran and threw the exception. Let's look at some examples: Cannot read property 'foo' of undefined at thirdPartyTwo (https://thirdparty.com/core.js:1:100) at thirdPartyOne (https://thirdparty.com/core.js:1:101) at runThirdParty (https://thirdparty.com/core.js:1:102) at xhrCallback (http://website.com/site.js:2:200) at XMLHttpRequest.send (https://mysite.com/boomerang.js:3:300) In the above example, Boomerang is monitoring XMLHttpRequests. An XHR was loaded on the site, and during the XHR callback, an exception was thrown. Even though /boomerang/ is listed here, the error was caused by code in the XHR callback (xhrCallback eventually calling thirdPartyTwo). Here's a second example: Reference error: a is not defined at setTimeout (http://website.com/site.js:1:200) at BOOMR_plugins_errors_wrap (http://mysite.com/boomerang.js:3:300) at onclick (http://website.com/site.js:1:100) In the above example, JavaScript Error Reporting is enabled and an exception was thrown in a setTimeout() on the website. You can see the BOOMR_plugins_errors_wrap function is near the top of the stack, but this is merely the error tracking code. All it did was wrap setTimeout to help ensure that cross-origin exceptions are caught. It was not the actual cause of the site's error. Here's a third example: Error: missing argument 1 at BOOMR.window.console.error (https://mysite.com/boomerang.js:3:300) at u/&lt; (https://website.com/site.js:1:100) at tp/this.$get&lt;/&lt; (https://website.com/site.js:1:200) at $digest (https://website.com/site.js:1:300) at $apply (https://website.com/site.js:1:400) at ut (https://website.com/site.js:1:500) at it (https://website.com/site.js:1:600) at vp/&lt;/k.onload (https://website.com/site.js:1:700) In the above example, JavaScript Error Reporting is enabled and has wrapped console.error. The minified function u/&lt; must be logging a console.error, which executes the Boomerang wrapper code, reporting the error. In summary, if you see Boomerang functions in error stacks similar to any of the ones listed below, it's probable that you're just seeing a side-effect of the monitoring code: BOOMR_addError BOOMR_plugins_errors_onerror BOOMR_plugins_errors_onxhrerror BOOMR_plugins_errors_console_error BOOMR_plugins_errors_wrap BOOMR.window.console.error BOOMR_plugins_errors_onrejection Side Effects Enabling wrapping through monitorEvents and monitorTimeout may trigger some side effects: Boomerang's monitoring code will be run first for every callback, which will add minimal (though non-zero) overhead. In browser console logs, errors that are triggered by other libraries that have been wrapped will now look like they come from Boomerang instead, as Boomerang is now on the bottom of the call stack. Browser developer tools such as Chrome's Performance and Profiler tabs may be confused about JavaScript CPU attribution. In other words, they may think Boomerang is the cause of more work than it is. Chrome Lighthouse may be confused about JavaScript CPU attribution, due to the same reasons as above. WebPagetest may be confused about JavaScript CPU attribution, due to the same reasons as above. There are some cases where JavaScript applications may have compatibility issues with the wrapping. Some notable cases include: Use of the global window.event object, see issue. Other libraries that wrap setTimeout, addEventListener, etc such as history.js. Pages that use the &lt;base href=\"...\"&gt; tag. For more details, you can read this article. Beacon Parameters err: The compressed error data structure http.initiator = error (if not part of a Page Load beacon) The compressed error data structure is a JSURL encoded JSON object. Each element in the array is a compressed representation of a JavaScript error: n: Count (if the error was seen more than once) f[]: An array of frames f[].l: Line number f[].c: Colum number f[].f: Function name f[].w: File name (if origin differs from root page) f[].wo: File name without origin (if same as root page) s: Source: 1: Error was triggered by the application 2: Error was triggered by Boomerang v: Via 1: Application (BOOMR.plugins.Errors.send) 2: Global exception handler (window.onerror) 3: Network (XHR) error 4: Console (console.error) 5: Event handler (addEventListener) 6: setTimeout or setInterval t: Type (e.g. SyntaxError or ReferenceError) c: Code (for network errors) m: Error messag x: Extra data d: Timestamp (base 36) Methods init(config) Initializes the plugin. Parameters: Name Type Description config object Configuration Properties Name Type Argument Description Errors.onError function &lt;optional&gt; Callback to fire when an error occurs Errors.monitorGlobal boolean &lt;optional&gt; Monitor window.onerror Errors.monitorNetwork boolean &lt;optional&gt; Monitor XHR errors Errors.monitorConsole boolean &lt;optional&gt; Monitor console.error Errors.monitorEvents boolean &lt;optional&gt; Monitor event callbacks (from addEventListener). NOTE: Enabling this may cause compatibility issues with certain sites. Verifications should be run before enabling in production. Errors.monitorTimeout boolean &lt;optional&gt; Monitor setTimout and setInterval. NOTE: Enabling this may cause compatibility issues with certain sites. Verifications should be run before enabling in production. Errors.monitorRejections boolean &lt;optional&gt; Monitor unhandled promise rejections. Errors.monitorReporting boolean &lt;optional&gt; Monitor Reporting API warnings. Errors.sendAfterOnload boolean &lt;optional&gt; Whether or not to send errors after the page load beacon. If set to false, only errors that happened up to the page load beacon will be captured. Errors.sendInterval boolean &lt;optional&gt; If sendAfterOnload is true, how often to send the latest batch of errors. Errors.maxErrors number &lt;optional&gt; Maximum number of errors to track per page. Returns: BOOMR.plugins.Errors The Errors plugin for chaining is_complete() This plugin is always complete (ready to send a beacon) Returns: Type: boolean true is_supported() Determines if Error tracking is initialized. Returns: Type: boolean true send(error) Sends an error Parameters: Name Type Description error Error | String Error object or message test(fn, that, args) Runs the function, watching for exceptions Parameters: Name Type Description fn function Function that object Target object args Array.&lt;object&gt; Arguments wrap(fn, that, via) Wraps the function in an exception handler that will automatically report exceptions. Parameters: Name Type Description fn function Function that object Target object via number Via (optional) Returns: Type: function Wrapped function × Search results Close "},"BOOMR.plugins.EventTiming.html":{"id":"BOOMR.plugins.EventTiming.html","title":"Class: EventTiming","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. EventTiming The EventTiming plugin collects paint metrics exposed by the WICG Event Timing proposal. For information on how to include this plugin, see the Building tutorial. Beacon Parameters All beacon parameters are prefixed with et.. This plugin adds the following parameters to the beacon: et.e: Compressed EventTiming events et.fid: Observed First Input Delay See: https://github.com/WICG/event-timing/ Members metrics Exported metrics Methods init() Initializes the plugin. This plugin does not have any configuration. Returns: BOOMR.plugins.EventTiming The EventTiming plugin for chaining is_complete() Whether or not this plugin is complete Returns: Type: boolean true if the plugin is complete is_enabled() Whether or not this plugin is enabled and EventTiming is supported. Returns: Type: boolean true if EventTiming plugin is enabled and supported. is_supported() Whether or not EventTiming is supported in this browser. Returns: Type: boolean true if EventTiming is supported. stop() Stops observing × Search results Close "},"BOOMR.plugins.GUID.html":{"id":"BOOMR.plugins.GUID.html","title":"Class: GUID","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. GUID Tag users with a unique GUID. The GUID plugin adds a tracking cookie to the user that will be sent to the beacon-server as cookie. For information on how to include this plugin, see the Building tutorial. Beacon Parameters This plugin adds no parameters to the beacon. (It sets the specified cookie) Methods init(config) Initializes the plugin. Parameters: Name Type Description config object Configuration Properties Name Type Argument Description GUID.cookieName string The name of the cookie to be set in the browser session GUID.expires number &lt;optional&gt; An expiry time for the cookie in seconds. By default 7 days. Returns: BOOMR.plugins.GUID The GUID plugin for chaining is_complete() This plugin is always complete (ready to send a beacon) Returns: Type: boolean true × Search results Close "},"BOOMR.plugins.History.html":{"id":"BOOMR.plugins.History.html","title":"Class: History","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. History The History plugin allows you to automatically monitor Single Page App (SPA) navigations that change their routes via the window.history object. The History plugin can be used for any SPA (eg. Angular, Backbone, Ember, React, Vue, etc.) and replaces the deprecated Angular, Backbone and Ember plugins. Note: This plugin requires the BOOMR.plugins.AutoXHR and BOOMR.plugins.SPA plugins to be loaded first (in that order). For details on how Boomerang Single Page App instrumentation works, see the BOOMR.plugins.SPA documentation. For information on how to include this plugin, see the Building tutorial. Compatibility This plugin should work with any Single Page App, by instrumenting the window.history object to monitor for route changes. The SPA app needs to change the history state or hash before doing the work required to change the route (eg. XHRs, DOM node changes). With frameworks where the history events happen after the route change has completed (e.g. Ember.js 1.x), we can configure the plugin with monitorHistory: false and call BOOMR.plugins.SPA.route_change() manually when the route change begins. Beacon Parameters This plugin does not add any additional beacon parameters beyond the BOOMR.plugins.SPA plugin. Usage Include the BOOMR.plugins.AutoXHR, BOOMR.plugins.SPA and BOOMR.plugins.History plugins. See Building for details. Methods disable() Disables the History plugin Returns: BOOMR.plugins.History The History plugin for chaining enable() Enables the History plugin Returns: BOOMR.plugins.History The History plugin for chaining hook(history [, hadRouteChange] [, options]) Hooks Boomerang into the History events. Parameters: Name Type Argument Description history object Deprecated hadRouteChange boolean &lt;optional&gt; Deprecated event prior to this hook() call options object &lt;optional&gt; Optional options. Can contain routeFilter and/or routeChangeWaitFilter Returns: BOOMR.plugins.History The History plugin for chaining init(config) Initializes the plugin. Parameters: Name Type Description config object Configuration Properties Name Type Argument Description History.auto boolean &lt;optional&gt; Whether or not to automatically instrument the window.history object. If set to false, the React snippet should be used. History.disableHardNav boolean &lt;optional&gt; Whether or not to disable SPA hard beacons History.routeFilter function &lt;optional&gt; Route change filter callback function History.routeChangeWaitFilter function &lt;optional&gt; Route change wait filter callback function History.routeChangeWaitFilterHardNavs boolean &lt;optional&gt; Whether to apply wait filter on hard navs History.monitorReplaceState boolean &lt;optional&gt; Whether or not to hook History.replaceState Returns: BOOMR.plugins.History The History plugin for chaining Example BOOMR.init({ History: { enabled: true }); }); is_complete() This plugin is always complete (ready to send a beacon) Returns: Type: boolean true × Search results Close "},"BOOMR.plugins.IFrameDelay.html":{"id":"BOOMR.plugins.IFrameDelay.html","title":"Class: IFrameDelay","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. IFrameDelay This plugin delays the Page Load beacon until all specified IFRAMEs have also signalled they are also fully loaded. For information on how to include this plugin, see the Building tutorial. Usage In the parent page the following configuration should be used: BOOMR.init({ ... autorun: false, IFrameDelay: { enabled: true, monitoredCount: 1 } }); And in the child IFRAME: BOOMR.init({ ... IFrameDelay: { enabled: true, registerParent: true } }); See the init() function for more details on each parameter. Once all registered IFRAMEs have finished loading, the Page Load time is set with the load time of the final IFRAME. Beacon Parameters This plugin adds the following parameters to the beacon: ifdl.done: When all of the IFRAMEs have finished loading ifdl.ct: Number of finished IFRAMEs ifdl.r: Number of still-running IFRAMEs ifdl.mon: Total number of monitored IFRAMEs Methods init(config) Initializes the plugin. Parameters: Name Type Description config object Configuration Properties Name Type Argument Description IFrameDelay.registerParent boolean &lt;optional&gt; Should be set to true for child IFRAMEs. If true, the parent frame will wait on this child IFRAME. IFrameDelay.monitoredCount number &lt;optional&gt; Should be set by the parent frame to indiciate the number of child IFRAMEs it expects to wait on. Returns: BOOMR.plugins.IFrameDelay The IFrameDelay plugin for chaining is_complete() Whether or not this plugin is complete Returns: Type: boolean true if the plugin is complete is_supported() Whether or not this plugin is supported Returns: Type: boolean true if the plugin has postMessage and JSON support. × Search results Close "},"BOOMR.plugins.IPv6.html":{"id":"BOOMR.plugins.IPv6.html","title":"Class: IPv6","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. IPv6 Plugin to measure various IPv6 related metrics. This plugin tries to do a few things: Check if the client can connect to an IPv6 address Check if the client can resolve DNS that points to an IPv6 address Check latency of connecting to an IPv6 address Check avg latency of doing DNS lookup to an IPv6 address (not worstcase) You'll need a server that has an IPv6 address, and a DNS name to point to it. Additionally, this server needs to be configured to serve content requested from the IPv6 address and should not require a virtual host name. This means that you probably cannot use shared hosting that puts multiple hosts on the same IP address. For information on how to include this plugin, see the Building tutorial. Beacon Parameters All beacon parameters are prefixed with ipv6_. This plugin adds the following parameters to the beacon: ipv6_latency: Latency in milliseconds of getting data from an IPv6 host when connecting to the IP. Set to NA if the client cannot connect to the IPv6 host. ipv6_lookup: Latency of getting data from a hostname that resolves to an IPv6 address. Set to NA if the client cannot resolve or connect to the IPv6 host. Methods init(config) Initializes the plugin. Parameters: Name Type Description config object Configuration Properties Name Type Argument Description IPv6.ipv6_url string An image URL referenced by its IPv6 address, eg, http://fe80::1/image-i.png. If not specified, the test will abort. IPv6.host_url string &lt;optional&gt; An image URL on an IPv6 only host referenced by its DNS hostname. The hostname should not resolve to an IPv4 address. If not specified, the host test will be skipped. IPv6.timeout string &lt;optional&gt; The time, in milliseconds, that boomerang should wait for a network response before giving up and assuming that the request failed. The default is 1200ms. Returns: BOOMR.plugins.IPv6 The IPv6 plugin for chaining is_complete() Whether or not this plugin is complete Returns: Type: boolean true if the plugin is complete × Search results Close "},"BOOMR.plugins.Memory.html":{"id":"BOOMR.plugins.Memory.html","title":"Class: Memory","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. Memory Plugin to collect memory, page construction (DOM), screen, CPU and battery metrics (when available). For information on how to include this plugin, see the Building tutorial. Beacon Parameters Resources: dom.res: Number of resources fetched in the main frame (via ResourceTiming) dom.doms: Number of unique domains in the main page (via ResourceTiming) Memory mem.total: memory.totalJSHeapSize mem.limit: memory.jsHeapSizeLimit mem.used: m.usedJSHeapSize mem.lssz: Number of localStorage bytes used mem.lsln: Number of localStorage keys used mem.sssz: Number of sessionStorage bytes used mem.ssln: Number of sessionStorage keys used Screen scr.xy: screen.width and screen.height (e.g. 100x200) scr.bpp: screen.colorDepth and screen.pixelDepth (e.g. 32/24) scr.dpx: screen.devicePixelRatio scr.orn: screen.orientation.angle and screen.orientation.type (e.g. 90/landscape-primary) scr.sxy: window.scrollX and window.scrollY (e.g. 0x1000) Hardware scr.mtp: navigator.maxTouchPoints cpu.cnc: navigator.hardwareConcurrency DOM dom.ln: Number of DOM nodes in the main frame dom.sz: Number of HTML bytes of of the main frame dom.ck: Number of bytes stored as cookies available to JavaScript on the current domain dom.img: Number of IMG nodes in the main frame dom.img.ext: Number of external (e.g. not data: URI) IMG nodes in the main frame dom.img.uniq: Number of unique IMG src nodes in the main frame dom.script: Number of SCRIPT nodes in the main frame dom.script.ext: Number of external (e.g. not inline or data: URI) SCRIPT nodes in the main frame dom.script.uniq: Number of unique SCRIPT src nodes in the main frame dom.iframe: Number of IFRAME nodes in the main frame dom.iframe.ext: Number of external (e.g. not javascript: or about: URI) IFRAME nodes in the main frame dom.iframe.uniq: Number of unique IFRAME src nodes in the main frame dom.link: Number of LINK nodes in the main frame dom.link.css: Number of rel=\"stylesheet\" LINK nodes in the main frame dom.link.css.uniq: Number of unique rel=\"stylesheet\" LINK nodes in the main frame Net net.sd: Boolean stating whether the user has data saver turned on or not Methods init() Initializes the plugin. is_complete() This plugin is always complete (ready to send a beacon) Returns: Type: boolean true × Search results Close "},"BOOMR.plugins.Mobile.html":{"id":"BOOMR.plugins.Mobile.html","title":"Class: Mobile","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. Mobile Plugin to capture Network Information API on browsers that support it. For information on how to include this plugin, see the Building tutorial. Beacon Parameters This plugin adds the following parameters to the beacon: mob.ct: navigator.connection.type mob.bw: navigator.connection.bandwidth mob.mt: navigator.connection.metered mob.etype: navigator.connection.effectiveType mob.lm: navigator.connection.downlinkMax mob.dl: `navigator.connection.downlink mob.rtt: navigator.connection.rtt mob.sd: navigator.connection.saveData × Search results Close "},"BOOMR.plugins.NavigationTiming.html":{"id":"BOOMR.plugins.NavigationTiming.html","title":"Class: NavigationTiming","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. NavigationTiming The Navigation Timing plugin collects performance metrics collected by modern user agents that support the W3C NavigationTiming specification. This plugin also adds similar ResourceTiming metrics for any XHR beacons. For information on how to include this plugin, see the Building tutorial. Beacon Parameters All beacon parameters are prefixed with nt_. This plugin adds the following parameters to the beacon for Page Loads: nt_red_cnt: performance.navigation.redirectCount nt_nav_type: performance.navigation.type nt_nav_st: performance.timing.navigationStart nt_red_st: performance.timing.redirectStart nt_red_end: performance.timing.redirectEnd nt_fet_st: performance.timing.fetchStart nt_dns_st: performance.timing.domainLookupStart nt_dns_end: performance.timing.domainLookupEnd nt_con_st: performance.timing.connectStart nt_con_end: performance.timing.connectEnd nt_req_st: performance.timing.requestStart nt_res_st: performance.timing.responseStart nt_res_end: performance.timing.responseEnd nt_domloading: performance.timing.domLoading nt_domint: performance.timing.domInteractive nt_domcontloaded_st: performance.timing.domContentLoadedEventStart nt_domcontloaded_end: performance.timing.domContentLoadedEventEnd nt_domcomp: performance.timing.domComplete nt_load_st: performance.timing.loadEventStart nt_load_end: performance.timing.loadEventEnd nt_unload_st: performance.timing.unloadEventStart nt_unload_end: performance.timing.unloadEventEnd nt_ssl_st: performance.timing.secureConnectionStart nt_spdy: 1 if page was loaded over SPDY, 0 otherwise. Only available in Chrome when it doesn't support NavigationTiming2. If NavigationTiming2 is supported, nt_protocol will be added instead. nt_first_paint: The time when the first paint happened. If the browser supports the Paint Timing API, this is the first-paint time in milliseconds since the epoch. Else, on Internet Explorer, this is the msFirstPaint value, in milliseconds since the epoch. On Chrome, this is using loadTimes().firstPaintTime and is converted from seconds.microseconds into milliseconds since the epoch. nt_cinf: Chrome chrome.loadTimes().connectionInfo. Only available in Chrome when it doesn't support NavigationTiming2. If NavigationTiming2 is supported, nt_protocol will be added instead. nt_protocol: NavigationTiming2's nextHopProtocol nt_bad: If we detected that any NavigationTiming metrics looked odd, such as responseEnd in the far future or fetchStart before navigationStart. nt_worker_start: NavigationTiming2 workerStart nt_enc_size: NavigationTiming2 encodedBodySize nt_dec_size: NavigationTiming2 decodedBodySize nt_trn_size: NavigationTiming2 transferSize For XHR beacons, the following parameters are added (via ResourceTiming): nt_red_st: redirectStart nt_red_end: redirectEnd nt_fet_st: fetchStart nt_dns_st: domainLookupStart nt_dns_end: domainLookupEnd nt_con_st: connectStart nt_con_end: connectEnd nt_req_st: requestStart nt_res_st: responseStart nt_res_end: responseEnd nt_load_st: loadEventStart nt_load_end: loadEventEnd nt_ssl_st: secureConnectionStart See: http://www.w3.org/TR/navigation-timing/ https://www.w3.org/TR/resource-timing-1/ Methods init() Initializes the plugin. This plugin does not have any configuration. Returns: BOOMR.plugins.NavigationTiming The NavigationTiming plugin for chaining is_complete() Whether or not this plugin is complete Returns: Type: boolean true if the plugin is complete × Search results Close "},"BOOMR.plugins.PaintTiming.html":{"id":"BOOMR.plugins.PaintTiming.html","title":"Class: PaintTiming","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. PaintTiming The PaintTiming plugin collects paint metrics exposed by the W3C Paint Timing and Largest Contentful Paint specifications. For information on how to include this plugin, see the Building tutorial. Beacon Parameters All beacon parameters are prefixed with pt.. This plugin adds the following parameters to the beacon: pt.fp: first-paint in DOMHighResTimestamp pt.fcp: first-contentful-paint in DOMHighResTimestamp pt.lcp: largest-contentful-paint in DOMHighResTimestamp pt.hid: The document was loaded hidden (at some point), so FP and FCP are user-driven events, and thus won't be added to the beacon. See: https://www.w3.org/TR/paint-timing/ https://wicg.github.io/largest-contentful-paint/ Methods getTimingFor(timingName) Gets the PaintTiming timestamp for the specified name Parameters: Name Type Description timingName string PaintTiming name Returns: Type: DOMHighResTimestamp Timestamp init() Initializes the plugin. This plugin does not have any configuration. Returns: BOOMR.plugins.PaintTiming The PaintTiming plugin for chaining is_complete() Whether or not this plugin is complete Returns: Type: boolean true if the plugin is complete is_enabled() Whether or not this plugin is enabled and PaintTiming is supported. Returns: Type: boolean true if PaintTiming plugin is enabled and supported. is_supported() Whether or not PaintTiming is supported in this browser. Returns: Type: boolean true if PaintTiming is supported. × Search results Close "},"BOOMR.plugins.ResourceTiming.html":{"id":"BOOMR.plugins.ResourceTiming.html","title":"Class: ResourceTiming","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. ResourceTiming Plugin to collect metrics from the W3C ResourceTiming API. For information on how to include this plugin, see the Building tutorial. Beacon Parameters This plugin adds the following parameters to the beacon for Page Loads: restiming: Compressed ResourceTiming data The ResourceTiming plugin adds an object named restiming to the beacon data. restiming is an optimized Trie structure, where the keys are the ResourceTiming URLs, and the values correspond to those URLs' PerformanceResourceTiming timestamps: { \"[url]\": \"[data]\"} The Trie structure is used to minimize the data transmitted from the ResourceTimings. Keys in the Trie are the ResourceTiming URLs. For example, with a root page and three resources: http://abc.com/ http://abc.com/js/foo.js http://abc.com/css/foo.css http://abc.com/css/foo.png (downloaded twice) Then the Trie might look like this: // Example 1 { \"http://abc.com/\": { \"|\": \"0,2\", \"js/foo.js\": \"3a,1\", \"css/\": { \"foo.css\": \"2b,2\", \"foo.png\": \"1c,3|1d,a\" } } } If a resource's URL is a prefix of another resource, then it terminates with a pipe symbol (|). In Example 1, http://abc.com (the root page) is a prefix of http://abc.com/js/foo.js, so it is listed as http://abc.com| in the Trie. If there is more than one ResourceTiming entry for a URL, each entry is separated by a pipe symbol (|) in the data. In Example 1 above, foo.png has been downloaded twice, so it is listed with two separate page loads, 1c,3 and 1d,a. The value of each key is a string, which contains the following components: data = \"[initiatorType][timings]\" initiatorType is a simple map from the PerformanceResourceTiming initiatorType (which is a string) to an integer, according to the BOOMR.plugins.ResourceTiming.INITAITOR_TYPES enum. timings is a string of Base-36 encoded timestamps from the PerformanceResourceTiming interface. The values in the string are separated by commas: timings = \"[startTime],[responseEnd],[responseStart],[requestStart],[connectEnd],[secureConnectionStart],[connectStart],[domainLookupEnd],[domainLookupStart],[redirectEnd],[redirectStart]\" startTime is a DOMHighResTimeStamp from when the resource started (Base 36). All other timestamps are offsets (rounded to milliseconds) from startTime (Base 36). For example, responseEnd is calculated as: responseEnd: base36(round(responseEnd - startTime)) If the resulting timestamp is 0, it is replaced with an empty string (\"\"). All trailing commas are removed from the final string. This compresses the timing string from timestamps that are often 0. For example, here is what a fully-redirected resource might look like: { \"http://abc.com/this-resource-was-redirected\": \"01,1,1,1,1,1,1,1,1,1,1\" } While a resource that was loaded from the cache (and thus only has startTime and responseEnd timestamps) might look like this: { \"http://abc.com/this-resource-was-redirected\": \"01,1\" } Note that some of the metrics are restricted and will not be provided cross-origin unless the Timing-Allow-Origin header permits. Putting this all together, let's look at http://abc.com/css/foo.png in Example 1. We find it was downloaded twice \"1c,3|1d,a\": 1c,3: 1: initiatorType = 1 (IMG) c: startTime = c (12ms) 3: responseEnd = 3 (3ms from startTime, or at 15ms) 1d,a: 1: initiatorType = 1 (IMG) d: startTime = d (13ms) a: responseEnd = a (10ms from startTime, or at 23ms) See: http://www.w3.org/TR/resource-timing/ Members INITIATOR_TYPES :number Type: number Properties: Name Type Default Description other number 0 Unknown type img number 1 IMG element (or IMAGE element inside a SVG for IE, Edge and Firefox) link number 2 LINK element (i.e. CSS) script number 3 SCRIPT element css number 4 Resource referenced in CSS xmlhttprequest number 5 XMLHttpRequest html number 6 The root HTML page itself image number 7 IMAGE element inside a SVG beacon number 8 sendBeacon fetch number 9 Fetch API iframe number a An IFRAME subdocument number a IE11 and Edge (some versions) send \"subdocument\" instead of \"iframe\" body number b BODY element input number c INPUT element frame number a FRAME element object number d OBJECT element video number e VIDEO element audio number f AUDIO element source number g SOURCE element track number h TRACK element embed number i EMBED element eventsource number j EventSource navigation number 6 The root HTML page itself REL_TYPES :number These are the only rel types that might be reference-able from ResourceTiming. https://html.spec.whatwg.org/multipage/links.html#linkTypes Type: number Properties: Name Type Default Description prefetch number 1 preload number 2 prerender number 3 stylesheet number 4 Methods addResources(resources, epoch) Saves an array of PerformanceResourceTiming-shaped objects which we will later insert into the trie. Parameters: Name Type Description resources array.&lt;object&gt; Array of objects that are shaped like PerformanceResourceTimings epoch high-resolution-timestamp Optional epoch for all of the timestamps of all of the resources addResourceTimingToBeacon(from, to) Adds 'restiming' and 'servertiming' to the beacon Parameters: Name Type Description from number Only get timings from to number Only get timings up to calculateResourceTimingUnion(resources) Calculates the union of durations of the specified resources. If any resources overlap, those timeslices are not double-counted. Parameters: Name Type Description resources Array.&lt;ResourceTiming&gt; Resources Returns: Duration, in milliseconds getCompressedResourceTiming(from, to) Gathers performance entries and compresses the result. Parameters: Name Type Description from number Only get timings from to number Only get timings up to Returns: Type: object An object containing the Optimized performance entries trie and the optimized server timing lookup getFilteredResourceTiming(from, to, initiatorTypes) Gathers a filtered list of performance entries. Parameters: Name Type Description from number Only get timings from to number Only get timings up to initiatorTypes Array.&lt;string&gt; Array of initiator types Returns: Type: Array.&lt;ResourceTiming&gt; Matching ResourceTiming entries init(config) Initializes the plugin. Parameters: Name Type Description config object Configuration Properties Name Type Argument Description ResourceTiming.xssBreakWorks Array.&lt;string&gt; &lt;optional&gt; Words that will be broken (by ensuring the optimized trie doesn't contain the whole string) in URLs, to ensure NoScript doesn't think this is an XSS attack. Defaults to DEFAULT_XSS_BREAK_WORDS. ResourceTiming.clearOnBeacon boolean &lt;optional&gt; Whether or not to clear ResourceTiming data on each beacon. ResourceTiming.urlLimit number &lt;optional&gt; URL length limit, after which ... will be used ResourceTiming.trimUrls Array.&lt;string&gt; | Array.&lt;RegExp&gt; &lt;optional&gt; List of strings of RegExps to trim from URLs. ResourceTiming.monitorClearResourceTimings boolean &lt;optional&gt; Whether or not to instrument performance.clearResourceTimings. ResourceTiming.splitAtPath boolean &lt;optional&gt; Whether or not to split the ResourceTiming compressed Trie at the path separator (faster processing, but larger result). ResourceTiming.getSrcsetDimensions boolean &lt;optional&gt; Whether or not to collect physical dimensions of srcset images. Setting this will cause uncacheable images to be re-downloaded. Returns: BOOMR.plugins.ResourceTiming The ResourceTiming plugin for chaining is_complete() Whether or not this plugin is complete Returns: Type: boolean true if the plugin is complete is_enabled() Whether or not this ResourceTiming is enabled and supported. Returns: Type: boolean true if ResourceTiming plugin is enabled. is_supported() Whether or not ResourceTiming is supported in this browser. Returns: Type: boolean true if ResourceTiming is supported. × Search results Close "},"BOOMR.plugins.RT.html":{"id":"BOOMR.plugins.RT.html","title":"Class: RT","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. RT The roundtrip (RT) plugin measures page load time, or other timers associated with the page. For information on how to include this plugin, see the Building tutorial. Beacon Parameters This plugin adds the following parameters to the beacon: t_done: Perceived load time of the page. t_page: Time taken from the head of the page to BOOMR#event:page_ready. t_page.inv: If there was a problem detected with the start/end times of t_page. This can happen due to bugs in NavigationTiming clients, where responseEnd happens after all other NavigationTiming events. t_resp: Time taken from the user initiating the request to the first byte of the response. t_other: Comma separated list of additional timers set by page developer. Each timer is of the format name|value t_load: If the page were prerendered, this is the time to fetch and prerender the page. t_prerender: If the page were prerendered, this is the time from start of prefetch to the actual page display. It may only be useful for debugging. t_postrender: If the page were prerendered, this is the time from prerender finish to actual page display. It may only be useful for debugging. vis.pre: 1 if the page transitioned from prerender to visible r: URL of page that set the start time of the beacon. nu: URL of next page if the user clicked a link or submitted a form rt.start: Specifies where the start time came from. May be one of: cookie for the start cookie navigation for the W3C NavigationTiming API, csi for older versions of Chrome or gtb for the Google Toolbar. manual for XHR beacons none if the start could not be detected rt.tstart: The start time timestamp. rt.nstart: The navigationStart timestamp, if different from rt.tstart. This could happen for XHR beacons, where rt.tstartis the start of the XHR fetch, andnt_nav_st won't be on the beacon. It could also happen for SPA Soft beacons, wherert.tstart` is the start of the Soft Navigation. rt.cstart: The start time stored in the cookie if different from rt.tstart. rt.bstart: The timestamp when boomerang started executing. rt.blstart: The timestamp when the boomerang was added to the host page. rt.end: The timestamp when the t_done timer ended (rt.end - rt.tstart === t_done) rt.bmr: Several parameters that include resource timing information for boomerang itself, ie, how long did boomerang take to load rt.subres: Set to 1 if this beacon is for a sub-resource of a primary page beacon. This is typically set by XHR beacons, and you will need to use a separate identifier to tie the primary beacon and the subresource beacon together on the server-side. rt.quit: This parameter will exist (but have no value) if the beacon was fired as part of the onbeforeunload event. This is typically used to find out how much time the user spent on the page before leaving, and is not guaranteed to fire. rt.abld: This parameter will exist (but have no value) if the onbeforeunload event fires before the onload event fires. This can happen, for example, if the user left the page before it completed loading. rt.ntvu: This parameter will exist (but have no value) if the onbeforeunload event fires before the page ever became visible. This can happen if the user opened the page in a background tab, and closed it without viewing it, and also if the page was pre-rendered, but never made visible. Use this to check your pre-render success ratio. http.method: For XHR beacons, the HTTP method if not GET. http.errno: For XHR beacons, the HTTP result code if not 200. http.hdr: For XHR beacons, headers if available. http.type: For XHR beacons, value of f for fetch API requests. Not set for XHRs. xhr.sync: For XHR beacons, 1 if it was sent synchronously. http.initiator: The initiator of the beacon: (empty/missing) for the page load beacon xhr for XHR beacons spa for SPA Soft Navigations spa_hard for SPA Hard Navigations fetch.bnu: For XHR beacons from fetch API requests, 1 if fetch response body was not used. rt.tt: Sum of load times across session rt.obo: Number of pages in session that did not have a load time xhr.ru: final response URL after any redirects XMLHttpRequest: it will be present if any redirects happened and final URL is not equivalent to the final response URL after any redirects. fetch: it will only be present if any redirects happened Cookie The session information is stored within a cookie. You can customise the name of the cookie where the session information will be stored via the RT.cookie option. By default this is set to RT. This cookie is set to expire in 7 days. You can change its lifetime using the RT.cookie_exp option. During that time, you can also read the value of the cookie on the server side. Its format is as follows: RT=\"ss=nnnnnnn&amp;si=abc-123...\"; The parameters are defined as: ss [string] [timestamp] Session Start (Base36) si [string] [guid] Session ID sl [string] [count] Session Length (Base36) tt [string] [ms] Sum of Load Times across the session (Base36) obo [string] [count] Number of pages in the session that had no load time (Base36) dm [string] [domain] Cookie domain bcn [string] [URL] Beacon URL rl [number] [boolean] Whether or not the session is Rate Limited se [string] [s] Session expiry (Base36) ld [string] [timestamp] Last load time (Base36, offset by ss) ul [string] [timestamp] Last beforeunload time (Base36, offset by ss) hd [string] [timestamp] Last unload time (Base36, offset by ss) cl [string] [timestamp] Last click time (Base36, offset by ss) r [string] [URL] Referrer URL (hashed, only if NavigationTiming isn't supported and if strict_referrer is enabled) nu [string] [URL] Clicked URL (hashed) z [number] [flags] Compression flags Methods addTimersToBeacon(vars, source) Adds all known timers to the beacon Parameters: Name Type Description vars object (unused) source string Source clearTimer(timer_name) Clears (removes) the specified timer Parameters: Name Type Description timer_name string Timer name done(edata, ename) Called when the page has reached a \"usable\" state. This may be when the onload event fires, or it could be at some other moment during/after page load when the page is usable by the user Parameters: Name Type Description edata object Event data ename string Event name Returns: BOOMR.plugins.RT The RT plugin for chaining endTimer(timer_name [, time_value]) Stops the timer named timer_name. It is not necessary for the timer to have been started before you call endTimer(). If a timer with this name was not started, then the unload time of the previous page is used instead. This allows you to measure the time across pages. Parameters: Name Type Argument Description timer_name string The name of the timer to start time_value TimeStamp &lt;optional&gt; If set, the timer's stop time will be set explicitly to this value. If not set, the current timestamp is used. Returns: BOOMR.plugins.RT The RT plugin for chaining getCookie() Gets RT cookie data from the cookie and returns it as an object. Also decompresses the cookie if it has been compressed. Returns: Type: RTCookie | false an object containing RT Cookie data or false if no cookie is available init(config) Initializes the plugin. Parameters: Name Type Description config object Configuration Properties Name Type Argument Description RT.cookie string &lt;optional&gt; The name of the cookie in which to store the start time for measuring page load time. The default name is RT. Set this to a falsy value to ignore cookies and depend completely on the NavigationTiming API for the start time. RT.cookie_exp string &lt;optional&gt; The lifetime in seconds of the roundtrip cookie. This only needs to live for as long as it takes for a single page to load. Something like 10 seconds or so should be good for most cases, but to be safe, and to cover people with really slow connections, or users that are geographically far away from you, keep it to a few minutes. The default is set to 10 minutes. RT.strict_referrer string &lt;optional&gt; By default, boomerang will not measure a page's roundtrip time if the URL in the RT cookie doesn't match the current page's document.referrer. This is because it generally means that the user visited a third page while their RT cookie was still valid, and this could render the page load time invalid. There may be cases, though, when this is a valid flow - for example, you have an SSL page in between and the referrer isn't passed through. In this case, you'll want to set strict_referrer to false. The default is true. Returns: BOOMR.plugins.RT The RT plugin for chaining is_complete() Whether or not this plugin is complete Returns: Type: boolean true if the plugin is complete navigationStart() Gets the Navigation Start time Returns: Type: TimeStamp Navigation start setTimer(timer_name, time_value) Sets the timer named timer_name to an explicit time measurement time_value. You'd use this method if you measured time values within your page before boomerang was loaded and now need to pass those values to the BOOMR.plugins.RT plugin for inclusion in the beacon. It is not necessary to call startTimer() or endTimer() before calling setTimer(). If you do, the old values will be ignored and the value passed in to this function will be used. Parameters: Name Type Description timer_name string The name of the timer to start time_value number The value in milliseconds to set this timer to. Returns: BOOMR.plugins.RT The RT plugin for chaining startTimer(timer_name [, time_value]) Starts the timer named timer_name. Timers count in milliseconds. You must call BOOMR.plugins.RT.endTimer when this timer has completed for the measurement to be recorded in the beacon. If passed in, the optional second parameter time_value is the timestamp in milliseconds to set the timer's start time to. This is useful if you need to record a timer that started before boomerang was loaded. Parameters: Name Type Argument Description timer_name string The name of the timer to start time_value TimeStamp &lt;optional&gt; If set, the timer's start time will be set explicitly to this value. If not set, the current timestamp is used. Returns: BOOMR.plugins.RT The RT plugin for chaining updateCookie() Updates the RT cookie. × Search results Close "},"BOOMR.plugins.SPA.html":{"id":"BOOMR.plugins.SPA.html","title":"Class: SPA","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. SPA Enables Single Page App (SPA) performance monitoring. Note: The SPA plugin requires the BOOMR.plugins.AutoXHR plugin to be loaded before SPA, and one of the following SPA plugins to work: BOOMR.plugins.Angular BOOMR.plugins.Backbone BOOMR.plugins.Ember BOOMR.plugins.History (React and all other SPA support) You also need to disable autorun when enabling SPA support. If you are not using a SPA framework but rely mostly on XMLHttpRequests to build your site, you might be able to skip the SPA plugins and just enable the BOOMR.plugins.AutoXHR plugin to measure your site. For information on how to include this plugin, see the Building tutorial. Approach Boomerang monitors Single Page App (SPA) navigations differently than how it monitors navigations on traditional websites. On traditional websites, the browser completes a full navigation for every page. During this navigation, the browser requests the page's HTML, JavaScript, CSS, etc., from the server, and builds the page from these components. Boomerang monitors this entire process. On SPA websites, only the first page that the visitor loads is a full navigation. All subsequent navigations are handled by the SPA framework itself (i.e. AngularJS), where they dynamically pull in the content they need to render the new page. This is done without executing a full navigation from the browser's point of view. Boomerang was designed for traditional websites, where a full navigation occurs on each page load. During the navigation, Boomerang tracks the performance characteristics of the entire page load experience. However, for SPA websites, only the first page triggers a full navigation. Thus, without any additional help, Boomerang will not track any subsequent interactions on SPA websites. To give visibility into SPA website navigations, there are several Boomerang plugins available for SPA frameworks, such as AngularJS, Ember.js and Backbone.js. When these plugins are enabled, Boomerang is able to track all of the SPA navigations beyond the first, initial navigation. To do so, the Boomerang SPA plugins listen for several life cycle events from the framework, such as AngularJS's $routeChangeStart. Once it gets notified of these events, the Boomerang SPA plugins start monitoring the page's markup (DOM) for changes. If any of these changes trigger a download, such as a XHR, image, CSS, or JavaScript, then the Boomerang SPA plugins monitor those resources as well. Only once all of these new resources have been fetched do the Boomerang SPA plugins consider the SPA navigation complete. For a further explanation of the challenges of measuring SPAs, see our slides or our talk. Hard and Soft Navigations A SPA Hard Navigation is always the first navigation to the site, plus any of the work required to build the initial view. The Hard Navigation will track at least the length of onload, but may also include the additional time required to load the framework (for example, Angular) and the first view. A SPA site will only have a single SPA Hard Navigation, no \"Page Load\" beacons. The http.initiator type is spa_hard A SPA Soft Navigation is any navigation after the Hard Navigation. A soft navigation is an \"in-page\" navigation where the view changes, but the browser does not actually fully navigate. A SPA site could have zero through many Soft Navigations The http.initiator type is spa Navigation Timestamps Hard Navigations The length of a Hard Navigation is calculated from the beginning of the browser navigation (e.g. navigationStart from NavigationTiming) through when the last critical resource has been fetched for the page. Critical resources include Images, IFRAMEs, CSS and Scripts. Soft Navigations The length of a Soft Navigation is calculated from the beginning of the route change event (e.g. when the user clicked somewhere to change the view) through when the last critical resource has been fetched for the page. Front-End vs. Back-End Time For SPA navigations, the Back End time (t_resp) is calculated as any period where a XHR or Script tag was being fetched. The Front End time (t_page) is calculated by taking the total SPA Page Load time (t_done) minus Back End time (t_resp). Beacon Parameters http.initiator spa_hard for Hard Navigations spa for Soft Navigations Methods current_spa_nav() Determine the current SPA navigation type (spa or spa_hard) Returns: Type: string SPA beacon type hook(hadRouteChange [, options]) Called by a framework when it has hooked into the target SPA Parameters: Name Type Argument Description hadRouteChange boolean True if a route change has already fired options object &lt;optional&gt; Additional options Properties Name Type Argument Description routeFilter BOOMR.plugins.SPA.spaRouteFilter &lt;optional&gt; Route filter routeChangeWaitFilter BOOMR.plugins.SPA.spaRouteChangeWaitFilter &lt;optional&gt; Route change wait filter routeChangeWaitFilterHardNavs boolean &lt;optional&gt; Whether to apply wait filter on hard navs disableHardNav boolean &lt;optional&gt; Disable sending SPA hard beacons Returns: BOOMR.plugins.SPA The SPA plugin for chaining init(config) Called to initialize the plugin via BOOMR.init() Parameters: Name Type Description config object Configuration is_complete() Determines if the plugin is complete Returns: Type: boolean True if the plugin is complete isSpaNavInProgress() Determines if a SPA navigation is in progress last_location(url) Called by a framework when the location has changed to the specified URL. This should be called prior to route_change() to use the specified URL. Parameters: Name Type Description url string URL markNavigationComplete() Marks the current navigation as complete and sends a beacon. The spa soft navigation will not wait for other nodes in progress onLoadSpaHardMissed() Fired when onload happens (or immediately if onload has already fired) to monitor for additional resources for a SPA Hard navigation register(pluginName) Registers a framework with the SPA plugin Parameters: Name Type Description pluginName string Plugin name route_change(onComplete, routeFilterArgs) Called by a framework when a route change has started. The SPA plugin will begin monitoring downloadable resources to measure the SPA soft navigation. Parameters: Name Type Description onComplete function Called on completion routeFilterArgs Array.&lt;object&gt; Route Filter arguments array supported_frameworks() Gets a list of supported SPA frameworks Returns: Type: Array.&lt;string&gt; List of supported frameworks wait_complete() Called by the SPA consumer if we have a routeChangeWaitFilter and are manually waiting for a custom event. The spa soft navigation will continue waiting for other nodes in progress Type Definitions spaRouteChangeWaitFilter(data) Callback to let the SPA plugin know whether or not the end of monitoring of the current SPA soft route should be delayed until BOOMR.plugins.SPA.wait_complete is called. If the callback returns false, the route will be monitored as normal. Parameters: Name Type Description data object Route data Returns: Type: boolean true to wait until BOOMR.plugins.SPA.wait_complete is called. spaRouteFilter(data) Callback to let the SPA plugin know whether or not to monitor the current SPA soft route. Any time a route is changed, if set, this callback will be executed with the current framework's route data. If the callback returns false, the route will not be monitored. Parameters: Name Type Description data object Route data Returns: Type: boolean true to monitor the current route × Search results Close "},"BOOMR.plugins.TPAnalytics.html":{"id":"BOOMR.plugins.TPAnalytics.html","title":"Class: TPAnalytics","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. TPAnalytics Captures session IDs and campaign information from third party analytic vendors installed on the same page. Third party analytics vendors currently supported: Google Analytics Adobe Analytics (formerly Omniture Sitecatalyst) IBM Digital Analytics (formerly Coremetrics) Beacon Parameters This plugin adds the following parameters to the beacon: tp.ga.clientid: Google Analytics clientID (unique id per visitor) tp.ga.utm_source: Google Analytics Campaign source tp.ga.utm_medium: Google Analytics Campaign medium tp.ga.utm_term: Google Analytics Campaign term tp.ga.utm_content: Google Analytics Campaign content tp.ga.utm_campaign: Google Analytics Campaign ID tp.aa.aid: Adobe Analytics Analytics ID (AID) tp.aa.mid: Adobe Analytics Marketing ID (MID) tp.aa.campaign: Adobe Analytics Campaign ID tp.aa.purchaseid: Adobe Analytics Purchase ID tp.ia.coreid: IBM Analytics Core ID (unique id per visitor) tp.ia.mmc_vendor: IBM Analytics Campaign vendor tp.ia.mmc_category: IBM Analytics Campaign category tp.ia.mmc_placement: IBM Analytics Campaign placement tp.ia.mmc_item: IBM Analytics Campaign item tp.ia.sp_type: IBM Analytics Site promotion type tp.ia.sp_promotion: IBM Analytics Site promotion tp.ia.sp_link: IBM Analytics Site promotion link tp.ia.re_version: IBM Analytics Real estate version tp.ia.re_pagearea: IBM Analytics Real estate page area tp.ia.re_link: IBM Analytics Real estate link * Methods init(config) Initializes the plugin. Parameters: Name Type Description config object Configuration Properties Name Type Description TPAnalytics.clientids boolean Whether or not to include client IDs. TPAnalytics.dropParams Array.&lt;string&gt; Parameters to not include on the beacon. Returns: BOOMR.plugins.TPAnalytics The TPAnalytics plugin for chaining Example BOOMR.init({ TPAnalytics: { clientids: false } }); is_complete() This plugin is always complete (ready to send a beacon) Returns: Type: boolean true × Search results Close "},"BOOMR.plugins.UserTiming.html":{"id":"BOOMR.plugins.UserTiming.html","title":"Class: UserTiming","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.plugins. UserTiming The UserTiming plugin to collect metrics from the W3C UserTiming API. This plugin can make use of the UserTimingCompression library. In order to use compression, UserTimingCompression must be loaded before this plugin's init() is called. This plugin collects all marks and measures that were added since navigation start or since the last beacon fired for the current navigation. For information on how to include this plugin, see the Building tutorial. Beacon Parameters This plugin adds the following parameters to the beacon: usertiming: UserTiming data The value is either plain json or a compressed string using UserTimingCompression library. A decompression function is also available in the library. Timing data is rounded to the nearest millisecond. Example // mark current timestamp as mark1 performance.mark('mark1'); // mark current timestamp as mark2 performance.mark('mark2'); // measure1 will be the delta between mark1 and mark2 timestamps performance.measure('measure1', 'mark1', 'mark2'); //measure2 will be the delta between the mark2 timestamp and the current time performance.measure('measure2', 'mark2'); When not using compression, data added to the beacon will look similar to the following: usertiming={\"mark\":{\"mark1\":100,\"mark2\":200},\"measure\":{\"measure1\":100,\"measure2\":200}} When using compression, data added to the beacon will look similar to the following: usertiming=~(m~(ark~(1~'2s~2~'5k)~easure~(1~'2s_2s~2~'5k_5k))) Decompressing the above value will give us the original data for the marks and measures collected: [{\"name\":\"mark1\",\"startTime\":100,\"duration\":0,\"entryType\":\"mark\"}, {\"name\":\"measure1\",\"startTime\":100,\"duration\":100,\"entryType\":\"measure\"}, {\"name\":\"mark2\",\"startTime\":200,\"duration\":0,\"entryType\":\"mark\"}, {\"name\":\"measure2\",\"startTime\":200,\"duration\":200,\"entryType\":\"measure\"}] Uncompressed measures only send their duration in contrast to compressed measures, which also send their startTime. Compatibility Many browsers support the UserTiming API, e.g.: Chrome 25+ Edge Firefox 38+ IE 10+ Opera 15+ See Nic Jansma's usertiming.js polyfill library to add UserTiming API support for browsers that don't implement it natively. See: http://www.w3.org/TR/user-timing/ Methods init() Initializes the plugin. Returns: BOOMR.plugins.UserTiming The UserTiming plugin for chaining is_complete() Whether or not this plugin is complete Returns: Type: boolean true if the plugin is complete is_supported() Whether or not UserTiming is supported in this browser. Returns: Type: boolean true if UserTiming is supported. × Search results Close "},"BOOMR.session.html":{"id":"BOOMR.session.html","title":"Class: session","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR. session Session data Members domain :string Session Domain. You can disable all cookies by setting site_domain to a falsy value. Type: string enabled :boolean Session enabled (Are session cookies enabled?) Type: boolean ID :string Session ID. This will be randomly generated in the client but may be overwritten by the server if not set. Type: string length :number Session length (number of pages) Type: number start :TimeStamp Session start time. Type: TimeStamp × Search results Close "},"BOOMR.utils.html":{"id":"BOOMR.utils.html","title":"Class: utils","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR. utils Classes Compression Methods addListener(el, type, fn, passiveOrOpts) Adds an event listener. Parameters: Name Type Description el DOMElement DOM element type string Event name fn function Callback function passiveOrOpts boolean | object Passive mode or Options object addObserver(el, config, timeout, callback, callback_data, callback_ctx) Add a MutationObserver for a given element and terminate after timeoutms. Parameters: Name Type Description el DOMElement DOM element to watch for mutations config MutationObserverInit MutationObserverInit object (https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver#MutationObserverInit) timeout number Number of milliseconds of no mutations after which the observer should be automatically disconnected. If set to a falsy value, the observer will wait indefinitely for Mutations. callback BOOMR~addObserverCallback Callback function to call either on timeout or if mutations are detected. callback_data object Any data to be passed to the callback function as its second parameter. callback_ctx object An object that represents the this object of the callback method. Leave unset the callback function is not a method of an object. Returns: Type: object | null null if a MutationObserver could not be created OR An object containing the observer and the timer object: { observer: &lt;MutationObserver&gt;, timer: &lt;Timeout Timer if any&gt; } The caller can use this to disconnect the observer at any point by calling retval.observer.disconnect() Note that the caller should first check to see if retval.observer is set before calling disconnect() as it may have been cleared automatically. arrayFilter(array, predicate) filter for arrays Parameters: Name Type Description array Array The array to iterate over. predicate function The function invoked per iteration. Returns: Type: Array Returns the new filtered array. arrayFind(array, predicate) find for Arrays Parameters: Name Type Description array Array The array to iterate over predicate function The function invoked per iteration Returns: Type: Array Returns the value of first element that satisfies the predicate cleanupURL(url, urlLimit) Cleans up a URL by removing the query string (if configured), and limits the URL to the specified size. Parameters: Name Type Description url string URL to clean urlLimit number Maximum size, in characters, of the URL Returns: Type: string Cleaned up URL generateId(chars) Generates a random ID based on the specified number of characters. Uses characters a-z0-9. Parameters: Name Type Description chars number Number of characters (max 40) Returns: Type: string Random ID generateUUID() Generates a pseudo-random UUID (Version 4): https://en.wikipedia.org/wiki/Universally_unique_identifier Returns: Type: string UUID getCookie(name) Gets the cached value of the cookie identified by name. Parameters: Name Type Description name string Cookie name Returns: Type: string | undefined Cookie value, if set. getLocalStorage(name) Retrieve items from localStorage Parameters: Name Type Description name string Name of storage Returns: Type: object | null Returns object retrieved from localStorage. Returns undefined if not found or expired. Returns null if parameters are invalid or an error occured getQueryParamValue(param [, url]) Get a query parameter value from a URL's query string Parameters: Name Type Argument Description param string Query parameter name url string | Object &lt;optional&gt; URL containing the query string, or a link object. Defaults to BOOMR.window.location Returns: Type: string | null URI decoded value or null if param isn't a query parameter getRawCookie(name) Gets the value of the cookie identified by name. Parameters: Name Type Description name string Cookie name Returns: Type: string | null Cookie value, if set. getSameSiteAttributeParts() Depending on Boomerang configuration and checks of current protocol and compatible browsers the logic below will provide an array of cookie attributes that are needed for a successful creation of a cookie that contains the SameSite attribute. How it works: We read the Boomerang configuration key same_site_cookie where one of the following values None, Lax or Strict is expected. A configuration value of same_site_cookie will be read in case-insensitive manner. E.g. Lax, lax and lAx will produce same result - SameSite=Lax. If a same_site_cookie configuration value is not specified a cookie will be created with SameSite=Lax. If a same_site_cookie configuration value does't match any of None, Lax or Strict then a cookie will be created with SameSite=Lax. The Secure cookie attribute will be added when a cookie is created with SameSite=None. It's possible that a Boomerang plugin or external code may need cookies to be created with SameSite=None. In such cases we check a special flag forced_same_site_cookie_none. If the value of this flag is equal to true then the same_site_cookie value will be ignored and Boomerang cookies will be created with SameSite=None. SameSite=None - INCOMPATIBILITIES and EXCEPTIONS: There are known problems with older browsers where cookies created with SameSite=None are dropped or created with SameSite=Strict. Reference: https://www.chromium.org/updates/same-site/incompatible-clients If we detect a browser that can't create safely a cookie with SameSite=None then Boomerang will create a cookie without the SameSite attribute. A cookie with SameSite=None can be created only over HTTPS connection. If current connection is HTTP then a cookie will be created without the SameSite attribute. Returns: Type: Array of cookie attributes used for setting a cookie with SameSite attribute getSubCookies(cookie) Parse a cookie string returned by BOOMR.utils.getCookie and split it into its constituent subcookies. Parameters: Name Type Description cookie string Cookie value Returns: Type: object On success, an object of key/value pairs of all sub cookies. Note that some subcookies may have empty values. null if cookie was not set or did not contain valid subcookies. hashQueryString(url, stripHash) Gets the URL with the query string replaced with a hash of its contents. Parameters: Name Type Description url string URL stripHash boolean Whether or not to strip the hash Returns: Type: string URL with query string hashed inArray(val, ary) Determines if the specified value is in the array Parameters: Name Type Description val object Value to check ary object Object in question Returns: Type: boolean True if the value is in the Array isArray(ary) Determines if the specified object is an Array or not Parameters: Name Type Description ary object Object in question Returns: Type: boolean True if the object is an Array isCurrentUASameSiteNoneCompatible() Wrapper of isUASameSiteNoneCompatible() that ensures that we pass correct User Agent string Returns: Type: boolean True if a browser can safely create SameSite=None cookie isInteger(input) Determines if the given input is an Integer. Relies on standard Number.isInteger() function that available is most browsers except IE. For IE, this relies on the polyfill provided by MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill Parameters: Name Type Description input number dat Returns: Type: string Random ID isMutationObserverSupported() MutationObserver feature detection Returns: Type: boolean Returns true if MutationObserver is supported. Always returns false for IE 11 due several bugs in it's implementation that MS flagged as Won't Fix. In IE11, XHR responseXML might be malformed if MO is enabled (where extra newlines get added in nodes with UTF-8 content). Another IE 11 MO bug can cause the process to crash when certain mutations occur. For the process crash issue, see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8137215/ and https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/15167323/ isUASameSiteNoneCompatible(uaString) Parameters: Name Type Description uaString string User agent string Returns: Type: boolean True if a browser can safely create SameSite=None cookie objectToString(o, separator, nest_level) Converts an object to a string. Parameters: Name Type Description o object Object separator string Member separator nest_level number Number of levels to recurse Returns: Type: string String representation of the object pluginConfig(o, config, plugin_name, properties) Sets the object's properties if anything in config matches one of the property names. Parameters: Name Type Description o object The plugin's impl object within which it stores all its configuration and private properties config object The config object passed in to the plugin's init() method. plugin_name string The plugin's name in the BOOMR.plugins object. properties Array.&lt;string&gt; An array containing a list of all configurable properties that this plugin has. Returns: Type: boolean True if a property was set removeCookie(name) Removes the cookie identified by name by nullifying its value, and making it a session cookie. Parameters: Name Type Description name string Cookie name removeListener(el, type, fn) Removes an event listener. Parameters: Name Type Description el DOMElement DOM element type string Event name fn function Callback function removeLocalStorage(name) Remove items from localStorage Parameters: Name Type Description name string Name of storage Returns: Type: boolean True if item was removed from localStorage. setCookie(name, subcookies, max_age) Sets the cookie named name to the serialized value of subcookies. Parameters: Name Type Description name string The name of the cookie subcookies object Key/value pairs to write into the cookie. These will be serialized as an &amp; separated list of URL encoded key=value pairs. max_age number Lifetime in seconds of the cookie. Set this to 0 to create a session cookie that expires when the browser is closed. If not set, defaults to 0. Returns: Type: boolean True if the cookie was set successfully Example BOOMR.utils.setCookie(\"RT\", { s: t_start, r: url }); setLocalStorage(name, items, max_age) Saves items in localStorage The value stored in localStorage will be a JSON string representation of {\"items\": items, \"expiry\": expiry} where items is the object we're saving and expiry is an optional epoch number of when the data is to be considered expired Parameters: Name Type Description name string Name of storage items object Items to be saved max_age number Age in seconds before items are to be considered expired Returns: Type: boolean True if the localStorage was set successfully × Search results Close "},"BOOMR.utils.Compression.html":{"id":"BOOMR.utils.Compression.html","title":"Class: Compression","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR.utils. Compression The Compression plugin adds common compression code that other plugins can use. For information on how to include this plugin, see the Building tutorial. Beacon Parameters This plugin adds no parameters to the beacon. Methods self.jsUrl(v) Converts an object to URL-friendly JSON Adapted from https://github.com/Sage/jsurl Changes: Formatting Removal of Array.map and Object.map for compat with IE 6-8 Change of str[i] syntax to str.charAt(i) for compat with IE 6-7 Parameters: Name Type Description v object Object to convert Returns: Type: string URL-friendly JSON self.jsUrlDecompress(s) Converts from JSURL to JSON. Adapted from https://github.com/Sage/jsurl Parameters: Name Type Description s string JSURL string Returns: Type: object Decompressed object × Search results Close "},"BOOMR_mq.html":{"id":"BOOMR_mq.html","title":"Class: BOOMR_mq","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start BOOMR_mq Plugin to implement the method queue pattern for Boomerang: http://www.lognormal.com/blog/2012/12/12/the-script-loader-pattern/#the_method_queue_pattern For information on how to include this plugin, see the Building tutorial. Beacon Parameters This plugin adds no parameters to the beacon. Usage The BOOMR_mq plugin can be used to call BOOMR methods before boomerang.js has fully loaded on the page. If Boomerang is already on the page when BOOMR_mq.push() is used, the specified function will be called immediatley. Otherwise, the specified function will be called as soon as Boomerang has loaded. Example BOOMR_mq is a global array that lives on the window object. If it doesn't exist, you should create it. To queue BOOMR methods, simply push() arrays onto the object. The first parameter in the array is the BOOMR method name. The rest of the parameters will be passed to that method. Example window.BOOMR_mq = window.BOOMR_mq || []; // add two variables to the beacon once Boomerang has loaded window.BOOMR_mq.push( [\"addVar\", \"var1\", \"value1\"], [\"addVar\", \"var2\", \"value2\"] ); × Search results Close "},"MutationHandler.html":{"id":"MutationHandler.html","title":"Class: MutationHandler","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start MutationHandler Handles the MutationObserver for BOOMR.plugins.AutoXHR. Methods pause() Pauses the MutationObserver. Call resume to start it back up. resume() Resumes the MutationObserver after a pause. start() Initiate MutationHandler.observer on the outer parent document. Uses addObserver to instrument. Our internal handler will be called if something happens. stop() Disable internal MutationObserver instance. Use this when uninstrumenting the site we're on. add_event_resource(resource) Adds a resource to the current event. Might fail (return -1) if: a) There are no pending events b) The current event is complete c) There's no passed-in resource Parameters: Name Type Description resource Resource Returns: Event index, or -1 on failure addEvent(resource) If an event has triggered a resource to be fetched we add it to the list of pending events here and wait for it to eventually resolve. Parameters: Name Type Description resource object Resource object we are waiting for Returns: Type: index If we are already waiting for an event of this type null otherwise index in the queue. calculateSpaTimings(resource) Calculates SPA Back-End and Front-End timings for Hard and Soft SPA navigations. Parameters: Name Type Description resource object Resouce to calculate for clearTimeout(index) If this instance of the MutationHandler has a timer set, clear it Parameters: Name Type Description index number Index of the event in pending_events array completeEvent( [index]) Completes the current event, marking the end time as 'now'. Parameters: Name Type Argument Description index number &lt;optional&gt; Optional Event index, defaults to last event load_finished(index, loadEventEnd) Decrement the number of nodes_to_wait for the PendingEvent Object. If the nodes_to_wait is decremented to 0 and the event type was SPA: When we're finished waiting on the last node, the MVC engine (eg AngularJS) might still be doing some processing (eg on an XHR) before it adds some additional content (eg IMGs) to the page. We should wait a while (1 second) longer to see if this happens. If something else is added, we'll continue to wait for that content to complete. If nothing else is added, the end event will be the timestamp for when this load_finished(), not 1 second from now. Parameters: Name Type Description index number Index of the event found in the pending_events array loadEventEnd TimeStamp TimeStamp at which the resource was finished loading monitorMO(index) Clear the flag preventing DOM mutation monitoring Parameters: Name Type Description index number Index of the event in pending_events array nodesWaitingFor( [index]) Determines how many nodes are being waited on Parameters: Name Type Argument Description index number &lt;optional&gt; Optional Event index, defaults to last event Returns: Type: number Number of nodes being waited on queue_is_empty() Determines if the resources queue is empty Returns: Type: boolean True if there are no outstanding resources sendEvent(index) If called with an event in the pending events list trigger a beacon for this event. When the beacon is sent for this event is depending on either having a crumb, in which case this beacon will be sent immediately. If that is not the case we wait 5 seconds and attempt to send the event again. Parameters: Name Type Description index number Index in event list to send Returns: Type: undefined Returns early if the event already completed sendResource(resource, eventIndex) Creates and triggers sending a beacon for a Resource that has finished loading. Parameters: Name Type Description resource Resource The Resource to send a beacon on eventIndex number index of the event in the pending_events array setTimeout(timeout, index) Will create a new timer waiting for timeout milliseconds to wait until a resources load time has ended or should have ended. If the timeout expires the Resource at index will be marked as timedout and result in an error Resource marked with XHR_STATUS_TIMEOUT as status information. Parameters: Name Type Description timeout number time ot wait for the resource to be loaded index number Index of the Resource in our MutationHandler#pending_events timedout(index) Sends a Beacon for the Resource at index with the status XHR_STATUS_TIMEOUT code, If there are multiple resources attached to the pending_events array at index. Parameters: Name Type Description index number Index of the event in pending_events array wait_for_node(node, index) Determines if we should wait for resources that would be fetched by the specified node. Parameters: Name Type Description node Element DOM node index number Event index Type Definitions load_cb(ev) Once an asset has been loaded and the resource appeared in the page we check if it was part of the interesting events on the page and mark it as finished. Parameters: Name Type Description ev Event Load event Object mutation_cb(mutations) Callback called once Mutation Observer instance noticed a mutation on the page. This method will determine if a mutation on the page is interesting or not. Parameters: Name Type Description mutations Array.&lt;Mutation&gt; Mutation array describing changes to the DOM × Search results Close "},"ProxyXHRImplementation.html":{"id":"ProxyXHRImplementation.html","title":"Class: ProxyXHRImplementation","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start ProxyXHRImplementation Proxy XMLHttpRequest object Methods addListener(ename, stat) Setup an {EventListener} for Event @param{ename}. This function will make sure the timestamp for the resources request is set and calls loadFinished should the resource have finished. See open() for it's usage Parameters: Name Type Description ename String Eventname to listen on via addEventListener stat String if that ename is reached set this as the status of the resource BOOMR.proxy_XMLHttpRequest(method, url [, async]) Open an XMLHttpRequest. If the URL passed as a second argument is in the BOOMR.xhr_exclude list ignore it and move on to request it Otherwise add it to our list of resources to monitor and later beacon on. If an exception is caught will call loadFinished and set resource.status to XHR_STATUS_OPEN_EXCEPTION Should the resource fail to load for any of the following reasons resource.stat status code will be set to: timeout {Event} XHR_STATUS_TIMEOUT error {Event} XHR_STATUS_ERROR abort {Event} XHR_STATUS_ABORT Parameters: Name Type Argument Description method string HTTP request method url string URL to request on async boolean &lt;optional&gt; If true will setup the EventListeners for XHR events otherwise will set the resource to synchronous. If true or undefined will be automatically set to asynchronous req.send() Mark requestStart timestamp and start the request unless the resource has already been marked as having an error code or a result to itself. Returns: Type: Object The data normal XHR.send() would return × Search results Close "},"tutorial-README.template.html":{"id":"tutorial-README.template.html","title":"Tutorial: README.template","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start README.template Copyright (c) 2011, Yahoo! Inc. All rights reserved. Copyright (c) 2011-2012, Log-Normal Inc. All rights reserved. Copyright (c) 2012-2017 SOASTA, Inc. All rights reserved. Copyright (c) 2017-2019, Akamai Technologies, Inc. All rights reserved. Copyrights licensed under the BSD License. See the accompanying LICENSE.txt file for terms. boomerang always comes back, except when it hits something. Summary boomerang is a JavaScript library that measures the page load time experienced by real users, commonly called RUM (Real User Measurement). It has the ability to send this data back to your server for further analysis. With boomerang, you find out exactly how fast your users think your site is. Apart from page load time, boomerang measures performance timings, metrics and characteristics of your user's web browsing experience. All you have to do is include it in your web pages and call the BOOMR.init() method. Once the performance data is captured, it will be beaconed to your chosen URL. boomerang is designed to be a performant and flexible library that can be adapted to your site's needs. It has an extensive plugin architecture, and works with both traditional and modern websites (including Single Page Apps). boomerang's goal is to not affect the load time of the page (avoiding the Observer Effect). It can be loaded in an asynchronous way that will not delay the page load even if boomerang.js is unavailable. Features Supports: IE 6+, Edge, all major versions of Firefox, Chrome, Opera, and Safari Desktop and mobile devices Captures (all optional): Page characteristics such as the URL and Referrer Overall page load times (via NavigationTiming if available) DNS, TCP, Request and Response timings (via NavigationTiming) Browser characteristics such as screen size, orientation, memory usage, visibility state DOM characteristics such as the number of nodes, HTML length, number of images, scripts, etc ResourceTiming data (to reconstruct the page's Waterfall) Bandwidth Mobile connection data DNS latency JavaScript Errors XMLHttpRequest instrumentation Third-Party analytics providers IDs Single Page App interactions Usage boomerang can be included on your page in one of two ways: synchronously or asynchronously. The asynchronous method is recommended. The simple synchronous way &lt;script src=\"boomerang.js\"&gt;&lt;/script&gt; &lt;script src=\"plugins/rt.js\"&gt;&lt;/script&gt; &lt;!-- any other plugins you want to include --&gt; &lt;script&gt; BOOMR.init({ beacon_url: \"http://yoursite.com/beacon/\" }); &lt;/script&gt; Note: You must include at least one plugin (it doesn't have to be RT) or else the beacon will never fire. Each plugin has its own configuration as well -- these configuration options should be included in the BOOMR.init() call: BOOMR.init({ beacon_url: \"http://yoursite.com/beacon/\", ResourceTiming: { enabled: true, clearOnBeacon: true } }); The faster, more involved, asynchronous way Loading boomerang asynchronously ensures that even if boomerang.js is unavailable (or loads slowly), your host page will not be affected. 1. Add a plugin to init your code Create a plugin (or use the sample zzz-last-plugin.js) with a call to BOOMR.init: BOOMR.init({ config: parameters, ... }); BOOMR.t_end = new Date().getTime(); You could also include any other code you need. For example, you could include a timer to measure when boomerang has finished loading (as above). 2. Build boomerang The build process bundles boomerang.js and all of the plugins listed in plugins.json (in that order). To build boomerang with all of your desired plugins, you would run: grunt clean build This creates a deployable boomerang in the build directory, e.g. build/boomerang-&lt;version&gt;.min.js. Install this file on your web server or origin server where your CDN can pick it up. Set a far future max-age header for it. This file will never change. 3. Asynchronously include the script on your page There are two methods of asynchronously including boomerang on your page: by adding it to your main document, or via the IFRAME/Preload method. The former method could block your onload event (affecting the measured performance of your page), so the later method is recommended. 3.1. Adding it to the main document Include the following code at the top of your HTML document: &lt;script&gt; (function(d, s) { var js = d.createElement(s), sc = d.getElementsByTagName(s)[0]; js.src=\"http://your-cdn.host.com/path/to/boomerang-&lt;version&gt;.js\"; sc.parentNode.insertBefore(js, sc); }(document, \"script\")); &lt;/script&gt; Best practices will suggest including all scripts at the bottom of your page. However, that only applies to scripts that block downloading of other resources. Including a script this way will not block other resources, however it will block onload. Including the script at the top of your page gives it a good chance of loading before the rest of your page does, thereby reducing the probability of it blocking the onload event. If you don't want to block onload either, use the following IFRAME/Preload method: 3.2. Adding it via an IFRAME/Preload The method described in 3.1 will still block onload on most browsers. To avoid blocking onload, we can load boomerang in an asynchronous IFRAME or via LINK preload (for browsers that support it). The general process is documented on in this blog post. For boomerang, the asynchronous loader snippet you'll use is: &lt;script&gt; (function() {
	// Boomerang Loader Snippet version 14
	if (window.BOOMR &amp;&amp; (window.BOOMR.version || window.BOOMR.snippetExecuted)) {
		return;
	}

	window.BOOMR = window.BOOMR || {};
	window.BOOMR.snippetStart = new Date().getTime();
	window.BOOMR.snippetExecuted = true;
	window.BOOMR.snippetVersion = 14;

	// NOTE: Set Boomerang URL here
	window.BOOMR.url = &quot;&quot;;

	var // document.currentScript is supported in all browsers other than IE
	    where = document.currentScript || document.getElementsByTagName(&quot;script&quot;)[0],
	    // Parent element of the script we inject
	    parentNode = where.parentNode,
	    // Whether or not Preload method has worked
	    promoted = false,
	    // How long to wait for Preload to work before falling back to iframe method
	    LOADER_TIMEOUT = 3000;

	// Tells the browser to execute the Preloaded script by adding it to the DOM
	function promote() {
		if (promoted) {
			return;
		}

		var script = document.createElement(&quot;script&quot;);
		script.id = &quot;boomr-scr-as&quot;;
		script.src = window.BOOMR.url;

		// Not really needed since dynamic scripts are async by default and the script is already in cache at this point,
		// but some naive parsers will see a missing async attribute and think we're not async
		script.async = true;

		parentNode.appendChild(script);

		promoted = true;
	}

	// Non-blocking iframe loader (fallback for non-Preload scenarios) for all recent browsers.
	// For IE 6/7, falls back to dynamic script node.
	function iframeLoader(wasFallback) {
		promoted = true;

		var dom, doc = document, bootstrap, iframe, iframeStyle, win = window;

		window.BOOMR.snippetMethod = wasFallback ? &quot;if&quot; : &quot;i&quot;;

		// Adds Boomerang within the iframe
		bootstrap = function(parent, scriptId) {
			var script = doc.createElement(&quot;script&quot;);
			script.id = scriptId || &quot;boomr-if-as&quot;;
			script.src = window.BOOMR.url;

			BOOMR_lstart = new Date().getTime();

			parent = parent || doc.body;
			parent.appendChild(script);
		};

		// For IE 6/7, we'll just load the script in the current frame, as those browsers don't support 'about:blank'
		// for an iframe src (it triggers warnings on secure sites).  This means loading on IE 6/7 may cause SPoF.
		if (!window.addEventListener &amp;&amp; window.attachEvent &amp;&amp; navigator.userAgent.match(/MSIE [67]\./)) {
			window.BOOMR.snippetMethod = &quot;s&quot;;

			bootstrap(parentNode, &quot;boomr-async&quot;);
			return;
		}

		// The rest of this function is IE8+ and other browsers that don't support Preload hints but will work with CSP &amp; iframes
		iframe = document.createElement(&quot;IFRAME&quot;);

		// An empty frame
		iframe.src = &quot;about:blank&quot;;

		// We set title and role appropriately to play nicely with screen readers and other assistive technologies
		iframe.title = &quot;&quot;;
		iframe.role = &quot;presentation&quot;;

		// Ensure we're not loaded lazily
		iframe.loading = &quot;eager&quot;;

		// Hide the iframe
		iframeStyle = (iframe.frameElement || iframe).style;
		iframeStyle.width = 0;
		iframeStyle.height = 0;
		iframeStyle.border = 0;
		iframeStyle.display = &quot;none&quot;;

		// Append to the end of the current block
		parentNode.appendChild(iframe);

		// Try to get the iframe's document object
		try {
			win = iframe.contentWindow;
			doc = win.document.open();
		}
		catch (e) {
			// document.domain has been changed and we're on an old version of IE, so we got an access denied.
			// Note: the only browsers that have this problem also do not have CSP support.

			// Get document.domain of the parent window
			dom = document.domain;

			// Set the src of the iframe to a JavaScript URL that will immediately set its document.domain to match the parent.
			// This lets us access the iframe document long enough to inject our script.
			// Our script may need to do more domain massaging later.
			iframe.src = &quot;javascript:var d=document.open();d.domain='&quot; + dom + &quot;';void 0;&quot;;
			win = iframe.contentWindow;

			doc = win.document.open();
		}

		if (dom) {
			// Unsafe version for IE8 compatibility. If document.domain has changed, we can't use win, but we can use doc.
			doc._boomrl = function() {
				this.domain = dom;
				bootstrap();
			};

			// Run our function at load.
			// Split the string so HTML code injectors don't get confused and add code here.
			doc.write(&quot;&lt;bo&quot; + &quot;dy onload='document._boomrl();'&gt;&quot;);
		}
		else {
			// document.domain hasn't changed, regular method should be OK
			win._boomrl = function() {
				bootstrap();
			};

			if (win.addEventListener) {
				win.addEventListener(&quot;load&quot;, win._boomrl, false);
			}
			else if (win.attachEvent) {
				win.attachEvent(&quot;onload&quot;, win._boomrl);
			}
		}

		// Finish the document
		doc.close();
	}

	// See if Preload is supported or not
	var link = document.createElement(&quot;link&quot;);

	if (link.relList &amp;&amp;
	    typeof link.relList.supports === &quot;function&quot; &amp;&amp;
	    link.relList.supports(&quot;preload&quot;) &amp;&amp;
	    (&quot;as&quot; in link)) {
		window.BOOMR.snippetMethod = &quot;p&quot;;

		// Set attributes to trigger a Preload
		link.href = window.BOOMR.url;
		link.rel  = &quot;preload&quot;;
		link.as   = &quot;script&quot;;

		// Add our script tag if successful, fallback to iframe if not
		link.addEventListener(&quot;load&quot;, promote);
		link.addEventListener(&quot;error&quot;, function() {
			iframeLoader(true);
		});

		// Have a fallback in case Preload does nothing or is slow
		setTimeout(function() {
			if (!promoted) {
				iframeLoader(true);
			}
		}, LOADER_TIMEOUT);

		// Note the timestamp we started trying to Preload
		BOOMR_lstart = new Date().getTime();

		// Append our link tag
		parentNode.appendChild(link);
	}
	else {
		// No Preload support, use iframe loader
		iframeLoader(false);
	}

	// Save when the onload event happened, in case this is a non-NavigationTiming browser
	function boomerangSaveLoadTime(e) {
		window.BOOMR_onload = (e &amp;&amp; e.timeStamp) || new Date().getTime();
	}

	if (window.addEventListener) {
		window.addEventListener(&quot;load&quot;, boomerangSaveLoadTime, false);
	}
	else if (window.attachEvent) {
		window.attachEvent(&quot;onload&quot;, boomerangSaveLoadTime);
	}
})();
&lt;/script&gt; Minified: &lt;script&gt;(function(){if(window.BOOMR&amp;&amp;(window.BOOMR.version||window.BOOMR.snippetExecuted)){return}window.BOOMR=window.BOOMR||{};window.BOOMR.snippetStart=(new Date).getTime();window.BOOMR.snippetExecuted=true;window.BOOMR.snippetVersion=14;window.BOOMR.url=&quot;&quot;;var e=document.currentScript||document.getElementsByTagName(&quot;script&quot;)[0],a=e.parentNode,s=false,t=3e3;function n(){if(s){return}var e=document.createElement(&quot;script&quot;);e.id=&quot;boomr-scr-as&quot;;e.src=window.BOOMR.url;e.async=true;a.appendChild(e);s=true}function o(e){s=true;var t,o=document,n,i,d,r=window;window.BOOMR.snippetMethod=e?&quot;if&quot;:&quot;i&quot;;n=function(e,t){var n=o.createElement(&quot;script&quot;);n.id=t||&quot;boomr-if-as&quot;;n.src=window.BOOMR.url;BOOMR_lstart=(new Date).getTime();e=e||o.body;e.appendChild(n)};if(!window.addEventListener&amp;&amp;window.attachEvent&amp;&amp;navigator.userAgent.match(/MSIE [67]\./)){window.BOOMR.snippetMethod=&quot;s&quot;;n(a,&quot;boomr-async&quot;);return}i=document.createElement(&quot;IFRAME&quot;);i.src=&quot;about:blank&quot;;i.title=&quot;&quot;;i.role=&quot;presentation&quot;;i.loading=&quot;eager&quot;;d=(i.frameElement||i).style;d.width=0;d.height=0;d.border=0;d.display=&quot;none&quot;;a.appendChild(i);try{r=i.contentWindow;o=r.document.open()}catch(e){t=document.domain;i.src=&quot;javascript:var d=document.open();d.domain='&quot;+t+&quot;';void 0;&quot;;r=i.contentWindow;o=r.document.open()}if(t){o._boomrl=function(){this.domain=t;n()};o.write(&quot;&lt;bo&quot;+&quot;dy onload='document._boomrl();'&gt;&quot;)}else{r._boomrl=function(){n()};if(r.addEventListener){r.addEventListener(&quot;load&quot;,r._boomrl,false)}else if(r.attachEvent){r.attachEvent(&quot;onload&quot;,r._boomrl)}}o.close()}var i=document.createElement(&quot;link&quot;);if(i.relList&amp;&amp;typeof i.relList.supports===&quot;function&quot;&amp;&amp;i.relList.supports(&quot;preload&quot;)&amp;&amp;&quot;as&quot;in i){window.BOOMR.snippetMethod=&quot;p&quot;;i.href=window.BOOMR.url;i.rel=&quot;preload&quot;;i.as=&quot;script&quot;;i.addEventListener(&quot;load&quot;,n);i.addEventListener(&quot;error&quot;,function(){o(true)});setTimeout(function(){if(!s){o(true)}},t);BOOMR_lstart=(new Date).getTime();a.appendChild(i)}else{o(false)}function d(e){window.BOOMR_onload=e&amp;&amp;e.timeStamp||(new Date).getTime()}if(window.addEventListener){window.addEventListener(&quot;load&quot;,d,false)}else if(window.attachEvent){window.attachEvent(&quot;onload&quot;,d)}})();&lt;/script&gt; Change the boomerangUrl to the location of Boomerang on your server. The id of the script node created by this code MUST be boomr-if-as (for IFRAME mode) or boomr-scr-as (for Preload mode) as boomerang looks for those ids to determine if it's running within an IFRAME and to determine the URL of the script. boomerang will still export the BOOMR object to the parent window if running inside an IFRAME, so the rest of your code should remain unchanged. 3.3. Identifying when boomerang has loaded If you load boomerang asynchronously, there's some uncertainty in when boomerang has completed loading. To get around this, you can subscribe to the onBoomerangLoaded Custom Event on the document object: // Modern browsers if (document.addEventListener) { document.addEventListener(\"onBoomerangLoaded\", function(e) { // e.detail.BOOMR is a reference to the BOOMR global object }); } // IE 6, 7, 8 we use onPropertyChange and look for propertyName === \"onBoomerangLoaded\" else if (document.attachEvent) { document.attachEvent(\"onpropertychange\", function(e) { if (!e) e=event; if (e.propertyName === \"onBoomerangLoaded\") { // e.detail.BOOMR is a reference to the BOOMR global object } }); } Note that this only works on browsers that support the CustomEvent interface, which is Chrome (including Android), Firefox 6+ (including Android), Opera (including Android, but not Opera Mini), Safari (including iOS), IE 6+ (but see the code above for the special way to listen for the event on IE6, 7 &amp; 8). boomerang also fires the onBeforeBoomerangBeacon and onBoomerangBeacon events just before and during beaconing. Installation There are several ways of including Boomerang in your project: Boomerang can be downloaded from the official Boomerang Github repository. NPM: npm install boomerangjs Bower: bower install boomerang Once fetched, see Building Boomerang for more details on how to include the plugins you require. Documentation Documentation is in the docs/ directory. Boomerang documentation is written in Markdown and is built via JSDoc. You can build the current documentation by running Grunt: grunt jsdoc HTML files will be built under build/docs. Open-source Boomerang Documentation is currently published at akamai.github.io/boomerang/. The team at Akamai works on mPulse Boomerang, which contains a few mPulse-specific plugins and may have additional changes being tested before being backported to the open-source Boomerang. mPulse Boomerang usage documentation is available at docs.soasta.com/boomerang/ and mPulse Boomerang API documentation is at developer.akamai.com/tools/boomerang/docs/. Additional documentation: API Documentation: The BOOMR API Building Boomerang: How to build boomerang with plugins Contributing: Contributing to the open-source project Creating Plugins: Creating a plugin Methodology: How boomerang works internally How-Tos: Short recipes on how to do a bunch of things with boomerang Source code The boomerang source code is primarily on GitHub at github.com/akamai/boomerang. Feel free to fork it and contribute to it. You can also get a check out the releases or download a tarball or zip of the code. Support We use GitHub Issues for discussions, feature requests and bug reports. Get in touch at github.com/akamai/boomerang/issues. boomerang is supported by the developers at Akamai, and the awesome community of open-source developers that use and hack it. That's you. Thank you! Contributions Boomerang is brought to you by: the former Exceptional Performance team at the company once known as Yahoo!, aided by the Yahoo! Developer Network, the folks at LogNormal, continued by the mPulse team at SOASTA, ongoing by the mPulse team at Akamai, and many independent contributors whose contributions are cemented in our git history To help out, please read our contributing page. × Search results Close "},"tutorial-building.html":{"id":"tutorial-building.html","title":"Tutorial: Building","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Building Boomerang is split into the main framework (boomerang.js) and plugins (plugins/*.js). boomerang.js on its own will not do anything interesting. To enable performance measurements of your site, you will want to include several plugins. Choosing Plugins Each plugin lives on its own in the plugins/ directory. Plugins are split into core measurement components, though some depend on each other. The default set of plugins for a \"full\" build of Boomerang can be seen in plugins.json in the root directory. You can modify this file to choose which plugins you want for measurement. You can read about each plugin in its documentation. Here is a basic description of each plugin: BOOMR.plugins.Angular enables support for measuring AngularJS websites (now part of the BOOMR.plugins.History plugin) BOOMR.plugins.AutoXHR tracks XMLHttpRequests and other in-page interactions BOOMR.plugins.Backbone enables support for measuring Backbone.js websites (now part of the BOOMR.plugins.History plugin) BOOMR.plugins.BW measures HTTP bandwidth BOOMR.plugins.CACHE_RELOAD forces the browser to update its cached copy of boomerang BOOMR.plugins.Clicks tracks in-page clicks BOOMR.plugins.ConsentInlinedPlugin allows for Opt-In and Opt-Out via user consent BOOMR.plugins.Continuty measures user-experience metrics such as Time to Interactive, Cumulative Layout Shift, Rage Clicks, etc BOOMR.plugins.CT tests whether a script was cached BOOMR.plugins.DNS measures DNS latency BOOMR.plugins.Early allows sending pre-Page Load beacons to ensure all page loads are tracked BOOMR.plugins.Ember enables support for measuring Ember.js websites (now part of the BOOMR.plugins.History plugin) BOOMR.plugins.Errors adds JavaScript error tracking BOOMR.plugins.EventTiming measures user input events via the EventTiming API such as First Input Delay (FID) BOOMR.plugins.GUID adds a unique ID for each session BOOMR.plugins.IPv6 measures various IPv6 metrics BOOMR.plugins.IFrameDelay allows delaying the page load measurements until IFRAMEs are loaded BOOMR.plugins.History enables support for measuring React and other window.history websites BOOMR.plugins.Memory captures browser memory metrics BOOMR.plugins.Mobile captures mobile connection type BOOMR.plugins.MQ adds a \"method queue\" API for Boomerang BOOMR.plugins.NavigationTiming captures NavigationTiming data BOOMR.plugins.PaintTiming captures paint events such as First Contentful Paint (FCP) and Largest Contentful Paint (LCP) BOOMR.plugins.ResourceTiming captures ResoureTiming (waterfall) data BOOMR.plugins.RT captures round-trip (load) performance BOOMR.plugins.SPA is required by any of the SPA plugins BOOMR.plugins.TPAnalytics adds third-party analytics IDs to the beacon BOOMR.plugins.UserTiming captures all UserTiming marks and measures There are also a few utility plugins: plugins/compression.js adds BOOMR.utils.Compression and is used by some plugins for compressing their data To monitor basic page load performance for a traditional website, we would recommend: BOOMR.plugins.RT BOOMR.plugins.NavigationTiming captures NavigationTiming data To monitor a Single Page App website, we would additionally recommend the following: BOOMR.plugins.AutoXHR BOOMR.plugins.SPA BOOMR.plugins.History See the build flavors section below for suggested ways of building Boomerang. Including Boomerang on your site. boomerang can be included on your page in one of two ways: synchronously or asynchronously. The asynchronous method is recommended. After the core JavaScript files are loaded, you will need to call BOOMR.init to initialize Boomerang and all of its plugins. See each plugin's documentation for the available configuration options. The simple synchronous way Simply include boomerang.js and any desired plugins as a &lt;script&gt; tag. &lt;script src=\"boomerang.js\"&gt;&lt;/script&gt; &lt;script src=\"plugins/rt.js\"&gt;&lt;/script&gt; &lt;!-- any other plugins you want to include --&gt; &lt;script&gt; BOOMR.init({ beacon_url: \"http://yoursite.com/beacon/\" }); &lt;/script&gt; Each plugin has its own configuration as well -- these configuration options should be included in the BOOMR.init() call: BOOMR.init({ beacon_url: \"http://yoursite.com/beacon/\", ResourceTiming: { enabled: true, clearOnBeacon: true } }); The faster, more involved, asynchronous way Loading boomerang asynchronously ensures that even if boomerang.js is unavailable (or loads slowly), your host page will not be affected. 1. Add a plugin to init your code Create a plugin (or use the sample zzz-last-plugin.js) with a call to BOOMR.init: BOOMR.init({ config: parameters, ... }); BOOMR.t_end = new Date().getTime(); You could also include any other code you need. For example, you could include a timer to measure when boomerang has finished loading (as above). 2. Build boomerang The build process bundles boomerang.js and all of the plugins listed in plugins.json (in that order). If you want to have a custom set of plugins, you can create a plugins.user.json and that file will be used instead (this file is excluded from this repository's Git). To build boomerang with all of your desired plugins, you would run: grunt clean build This creates a deployable boomerang in the build directory, e.g. build/boomerang-&lt;version&gt;.min.js. Install this file on your web server or origin server where your CDN can pick it up. Set a far future max-age header for it. This file will never change. The Build Process Build requires NodeJS to execute Grunt.js to build Boomerang. To install Grunt globally: npm install -g grunt-cli You can get a full build of boomerang by running the following: grunt clean build The main build targets are: clean cleans the build/ directory build builds a new version of Boomerang from scratch lint runs lint on the project test runs Tests A full list of build targets are avaialble in Gruntfile.js. Grunt build options: --build-number Specifies the minor build number --build-revision Specifies the revision build number Build Numbers Boomerang follows SemVer: major.minor.revision For each build of Boomerang, the major build version is specified in package.json as releaseVersion. The minor version defaults to 0. Each build can then specify its --build-number to change the minor version. The revision defaults to 0. Each build can then specify its --build-revision to change the revision. Build Flavors By default Boomerang will bundle all plugins defined in plugins.json (under the top-level \"plugins\": [] key) into the build. It is recommended that you tune your build to include just the plugins/features you need, so you can reduce the size and complexity of the Boomerang build. Some guidance on choosing plugins is above, but Boomerang also defines a few \"flavors\" of builds that bundle common plugins together. These flavors are also defined in plugins.json under the \"flavors\": {} key. For example, here's a definition of the \"minimal\" build we recommend: \"minimal\": { \"comment\": \"Minimal recommended plugins\", \"revision\": 10, \"plugins\": [ \"plugins/rt.js\", \"plugins/navtiming.js\" ] }, For each flavor, the \"plugins\": [] key lists which plugins apply to that flavor. To build Boomerang with a specific flavor, you can add a --build-flavor= argument to grunt: grunt clean build --build-flavor=minimal --build-number=1000 The resulting output file will be set to the specified Revision in the \"revision\" field above, e.g. 1.1000.10 for the minimal flavor. You can also create a plugins.user.json file and that will be used instead of plugins.json (this file is excluded from this repository's Git). × Search results Close "},"tutorial-contributing.html":{"id":"tutorial-contributing.html","title":"Tutorial: Contributing","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Contributing We welcome all Pull Requests, though we ask that you follow our guidelines for new code: Contribution Check-List Ensure your code passes the lint checks: grunt lint Ensure your code passes all existing tests: grunt test New code must be accompanied by new Unit or End-to-End Tests Open a Pull Request with a thorough description of your change Browser Compatibility Boomerang is compatible with all browsers from Internet Explorer 5.5 through all modern browsers. While not all plugins work in older browsers, Boomerang should still be able to execute in older browsers and not cause any script errors. To ensure Boomerang works in as many browsers as possible, please pay attention to the following guidelines: Boomerang code should not directly rely on any EcmaScript 5 features. Polyfills for utility functions (such as Array.filter) should not be added directly to the page. Instead, add a BOOMR.utils utility function such as BOOMR.utils.arrayFilter that uses native interfaces when available, and when not, executes polyfill-like code. For plugins that depend entirely on newer browser features (such as ResourceTiming for the ResourceTiming plugin), the plugin should attempt to do feature-detection and disable itself if browser support does not exist. × Search results Close "},"tutorial-creating-plugins.html":{"id":"tutorial-creating-plugins.html","title":"Tutorial: Creating Plugins","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Creating Plugins Boomerang plugins can be used for adding core functionality (such as ResourceTiming support) as well as for site-specific custom needs. Use the below example for creating a new Boomerang plugin. Once created, you can add the new plugin to your Boomerang build by adding it to plugins.json. See Building for more details. /** * Skeleton template for all boomerang plugins. * * Use this code as a starting point for your own plugins. */ (function() { // First, make sure BOOMR is actually defined. It's possible that your plugin // is loaded before boomerang, in which case you'll need this. BOOMR = window.BOOMR || {}; BOOMR.plugins = BOOMR.plugins || {}; // A private object to encapsulate all your implementation details // This is optional, but the way we recommend you do it. var impl = { }; // // Public exports // BOOMR.plugins.MyPlugin = { init: function(config) { // list of user configurable properties var properties = [\"prop1\", \"prop2\"]; // This block is only needed if you actually have user configurable properties BOOMR.utils.pluginConfig(impl, config, \"MyPlugin\", properties); // Other initialization code here // Subscribe to any BOOMR events here. // Unless your code will explicitly be called by the developer // or by another plugin, you must to do this. return this; }, // Any other public methods would be defined here is_complete: function() { // This method should determine if the plugin has completed doing what it // needs to do and return true if so or false otherwise } }; }()); × Search results Close "},"tutorial-header-snippets.html":{"id":"tutorial-header-snippets.html","title":"Tutorial: Header Snippets","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Header Snippets Header Snippets are small pieces of JavaScript code that can be injected into a Page's HTML so that even before Boomerang loads, components of the page load experience (such as JavaScript errors) are still fully measured. These Header Snippets should be added as inline &lt;script&gt; tags within the &lt;head&gt; of a document, ideally right before the Non-Blocking Loader Snippet is included. JavaScript Errors (for BOOMR.plugins.Errors) Boomerang listens for JavaScript errors via the BOOMR.plugins.Errors plugin by monitoring the onerror global event handler. However, JavaScript errors that occur prior to Boomerang being loaded will be missed. This Errors Snippet monitors for JavaScript Errors via the onerror event and will \"hand off\" the errors to Boomerang once it has loaded. Source: &lt;script&gt; (function(w){
	w.BOOMR = w.BOOMR || {};

	w.BOOMR.globalOnErrorOrig = w.BOOMR.globalOnError = w.onerror;
	w.BOOMR.globalErrors = [];

	// Gathers a high-resolution timestamp (when available), or falls back to Date.getTime()
	var now = (function() {
		try {
			if (&quot;performance&quot; in w &amp;&amp; w.performance.timing) {
				return function() {
					return Math.round(w.performance.now() + performance.timing.navigationStart);
				};
			}
		}
		catch (ignore) {
			// NOP
		}

		return Date.now || function() {
			return new Date().getTime();
		};
	})();

	// Overwrite the global onerror to listen for errors, but forward all messages to the original one if it exists
	w.onerror = function BOOMR_plugins_errors_onerror(message, fileName, lineNumber, columnNumber, error) {
		if (w.BOOMR.version) {
			// If Boomerang has already loaded, the only reason this function would still be alive would be if
			// we're in the chain from another handler that overwrote window.onerror.  In that case, we should
			// run globalOnErrorOrig which presumably hasn't been overwritten by Boomerang.
			if (typeof w.BOOMR.globalOnErrorOrig === &quot;function&quot;) {
				w.BOOMR.globalOnErrorOrig.apply(w, arguments);
			}

			return;
		}

		// Save this error for when Boomerang loads
		if (typeof error !== &quot;undefined&quot; &amp;&amp; error !== null) {
			error.timestamp = now();
			w.BOOMR.globalErrors.push(error);
		}
		else {
			w.BOOMR.globalErrors.push({
				message: message,
				fileName: fileName,
				lineNumber: lineNumber,
				columnNumber: columnNumber,
				noStack: true,
				timestamp: now()
			});
		}

		// Call the original window.onerror
		if (typeof w.BOOMR.globalOnError === &quot;function&quot;) {
			w.BOOMR.globalOnError.apply(w, arguments);
		}
	};

	// make it easier to detect this is our wrapped handler
	w.onerror._bmr = true;
})(window);
&lt;/script&gt; Minified: &lt;script&gt;(function(i){i.BOOMR=i.BOOMR||{};i.BOOMR.globalOnErrorOrig=i.BOOMR.globalOnError=i.onerror;i.BOOMR.globalErrors=[];var a=function(){try{if(&quot;performance&quot;in i&amp;&amp;i.performance.timing){return function(){return Math.round(i.performance.now()+performance.timing.navigationStart)}}}catch(r){}return Date.now||function(){return(new Date).getTime()}}();i.onerror=function r(n,o,e,t,O){if(i.BOOMR.version){if(typeof i.BOOMR.globalOnErrorOrig===&quot;function&quot;){i.BOOMR.globalOnErrorOrig.apply(i,arguments)}return}if(typeof O!==&quot;undefined&quot;&amp;&amp;O!==null){O.timestamp=a();i.BOOMR.globalErrors.push(O)}else{i.BOOMR.globalErrors.push({message:n,fileName:o,lineNumber:e,columnNumber:t,noStack:true,timestamp:a()})}if(typeof i.BOOMR.globalOnError===&quot;function&quot;){i.BOOMR.globalOnError.apply(i,arguments)}};i.onerror._bmr=true})(window);&lt;/script&gt; Frame Rate (for BOOMR.plugins.Continuity) The BOOMR.plugins.Continuity plugin measures performance and user experience metrics beyond just the traditional Page Load timings. One of the metrics that the BOOMR.plugins.Continuity plugin measures is Frame Rate (FSP) data via requestAnimationFrame. However, FPS data is \"real-time\" and is not available for scripts like Boomerang that may load later in the page load process. This Header Snippet will start monitoring requestAnimationFrame and hand the FPS data off to Boomerang once it has loaded. Source: &lt;script&gt; (function() {
	if (window &amp;&amp; window.requestAnimationFrame) {
		window.BOOMR = window.BOOMR || {};
		window.BOOMR.fpsLog = [];

		function frame(now) {
			// window.BOOMR.fpsLog will get deleted once Boomerang has loaded
			if (window.BOOMR.fpsLog) {
				window.BOOMR.fpsLog.push(Math.round(now));

				// if we've added more than 30 seconds of data, stop
				if (window.BOOMR.fpsLog.length &gt; 30 * 60) {
					return;
				}

				window.requestAnimationFrame(frame);
			}
		}

		window.requestAnimationFrame(frame);
	}
})();
&lt;/script&gt; Minified: &lt;script&gt;(function(){if(window&amp;&amp;window.requestAnimationFrame){window.BOOMR=window.BOOMR||{};window.BOOMR.fpsLog=[];function i(n){if(window.BOOMR.fpsLog){window.BOOMR.fpsLog.push(Math.round(n));if(window.BOOMR.fpsLog.length&gt;30*60){return}window.requestAnimationFrame(i)}}window.requestAnimationFrame(i)}})();&lt;/script&gt; Instrumenting XMLHttpRequests (for BOOMR.plugins.AutoXHR) The BOOMR.plugins.AutoXHR plugin monitors XMLHttpRequests on the page. The performance data of XMLHttpRequests that start before Boomerang is loaded may not be monitored. This Header Snippet will start monitoring XMLHttpRequests and hand the performance data off to Boomerang once it has loaded. Source: &lt;script&gt; (function(w){
	if (!w.XMLHttpRequest || !(new w.XMLHttpRequest()).addEventListener) {
		return;
	}

	var a = document.createElement(&quot;A&quot;),
	    xhrNative = w.XMLHttpRequest,
	    resources = [],
	    sendResource,
	    readyStateMap = [&quot;uninitialized&quot;, &quot;open&quot;, &quot;responseStart&quot;, &quot;domInteractive&quot;, &quot;responseEnd&quot;];

	w.BOOMR = w.BOOMR || {};

	// xhr object is what the AutoXHR plugin will interact with once it's loaded
	BOOMR.xhr = {
		/**
		 * Stops XHR collection and forwards any additional reporting to Boomerang
		 *
		 * @param {function} sendResourceCallback Callback for any ongoing monitoring
		 *
		 * @returns {object} Array of XHRs
		 */
		stop: function(sendResourceCallback) {
			sendResource = sendResourceCallback;

			// swap back in the native XHR function
			w.XMLHttpRequest = xhrNative;

			delete BOOMR.xhr;

			// clear our queue after a moment
			setTimeout(function(){
				resources = [];
			}, 10);

			return resources;
		}
	};

	// Gathers a high-resolution timestamp (when available), or falls back to Date.getTime()
	var now = (function() {
		try {
			if (&quot;performance&quot; in w &amp;&amp; w.performance.timing) {
				return function() {
					return Math.round(w.performance.now() + performance.timing.navigationStart);
				};
			}
		}
		catch (ignore) {
			// NOP
		}

		return Date.now || function() {
			return new Date().getTime();
		};
	})();

	// Overwrite the native XHR with our monitored object
	w.XMLHttpRequest = function() {
		var xhr = new xhrNative(),
		    open = xhr.open;

		xhr.open = function(method, url, async) {
			// Normalize the URL
			a.href = url;

			var resource = {
				timing: {},
				url: a.href,
				method: method
			};

			// Callback when the XHR is finished
			function loadFinished() {
				if (!resource.timing.loadEventEnd) {
					resource.timing.loadEventEnd = now();

					if (&quot;performance&quot; in w &amp;&amp; w.performance &amp;&amp; typeof w.performance.getEntriesByName === &quot;function&quot;) {
						var entries = w.performance.getEntriesByName(resource.url);

						var entry = entries &amp;&amp; entries.length &amp;&amp; entries[entries.length - 1];

						if (entry) {
							var navSt = w.performance.timing.navigationStart;

							if (entry.responseEnd !== 0) {
								resource.timing.responseEnd = Math.round(navSt + entry.responseEnd);
							}
							if (entry.responseStart !== 0) {
								resource.timing.responseStart = Math.round(navSt + entry.responseStart);
							}
							if (entry.startTime !== 0) {
								resource.timing.requestStart = Math.round(navSt + entry.startTime);
							}
						}
					}

					if (sendResource) {
						sendResource(resource);
					}
					else {
						resources.push(resource);
					}
				}
			}

			function addListener(ename, stat) {
				xhr.addEventListener(
					ename,
					function() {
						if (ename === &quot;readystatechange&quot;) {
							resource.timing[readyStateMap[xhr.readyState]] = now();
							if (xhr.readyState === 4) {
								loadFinished();
							}
						}
						else {
							resource.status = (stat === undefined ? xhr.status : stat);
							loadFinished();
						}
					},
					false);
			}

			if (async === true) {
				addListener(&quot;readystatechange&quot;);
			}
			else {
				resource.synchronous = true;
			}

			addListener(&quot;load&quot;);
			addListener(&quot;timeout&quot;, -1001);
			addListener(&quot;error&quot;,   -998);
			addListener(&quot;abort&quot;,   -999);

			try {
				open.apply(xhr, arguments);

				var send = xhr.send;

				xhr.send = function() {
					resource.timing.requestStart = now();

					send.apply(xhr, arguments);
				};
			}
			catch (e) {
				resource.status = -997;

				loadFinished();
			}
		};
		return xhr;
	};
})(window);
&lt;/script&gt; Minified: &lt;script&gt;(function(f){if(!f.XMLHttpRequest||!(new f.XMLHttpRequest).addEventListener){return}var c=document.createElement(&quot;A&quot;),t=f.XMLHttpRequest,p=[],d,m=[&quot;uninitialized&quot;,&quot;open&quot;,&quot;responseStart&quot;,&quot;domInteractive&quot;,&quot;responseEnd&quot;];f.BOOMR=f.BOOMR||{};BOOMR.xhr={stop:function(e){d=e;f.XMLHttpRequest=t;delete BOOMR.xhr;setTimeout(function(){p=[]},10);return p}};var g=function(){try{if(&quot;performance&quot;in f&amp;&amp;f.performance.timing){return function(){return Math.round(f.performance.now()+performance.timing.navigationStart)}}}catch(e){}return Date.now||function(){return(new Date).getTime()}}();f.XMLHttpRequest=function(){var s=new t,u=s.open;s.open=function(e,t,n){c.href=t;var r={timing:{},url:c.href,method:e};function i(){if(!r.timing.loadEventEnd){r.timing.loadEventEnd=g();if(&quot;performance&quot;in f&amp;&amp;f.performance&amp;&amp;typeof f.performance.getEntriesByName===&quot;function&quot;){var e=f.performance.getEntriesByName(r.url);var t=e&amp;&amp;e.length&amp;&amp;e[e.length-1];if(t){var n=f.performance.timing.navigationStart;if(t.responseEnd!==0){r.timing.responseEnd=Math.round(n+t.responseEnd)}if(t.responseStart!==0){r.timing.responseStart=Math.round(n+t.responseStart)}if(t.startTime!==0){r.timing.requestStart=Math.round(n+t.startTime)}}}if(d){d(r)}else{p.push(r)}}}function a(e,t){s.addEventListener(e,function(){if(e===&quot;readystatechange&quot;){r.timing[m[s.readyState]]=g();if(s.readyState===4){i()}}else{r.status=t===undefined?s.status:t;i()}},false)}if(n===true){a(&quot;readystatechange&quot;)}else{r.synchronous=true}a(&quot;load&quot;);a(&quot;timeout&quot;,-1001);a(&quot;error&quot;,-998);a(&quot;abort&quot;,-999);try{u.apply(s,arguments);var o=s.send;s.send=function(){r.timing.requestStart=g();o.apply(s,arguments)}}catch(e){r.status=-997;i()}};return s}})(window);&lt;/script&gt; × Search results Close "},"tutorial-howtos.html":{"id":"tutorial-howtos.html","title":"Tutorial: How-Tos","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start How-Tos Adding additional timers to the beacon Adding arbitrary data to the beacon Delaying the Page Load time Reading data from a beacon Managing the ResourceTiming Buffer Measuring arbitrary events Opt-out or Opt-in × Search results Close "},"tutorial-howto-add-additional-timers-to-the-beacon.html":{"id":"tutorial-howto-add-additional-timers-to-the-beacon.html","title":"Tutorial: Adding additional timers to the beacon","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Adding additional timers to the beacon By default, Boomerang includes several timers on each beacon, such as: Total Page Load time (t_done) Back-End time (t_resp) Front-End time (t_page) You can also add additional timers to a beacon via BOOMR.plugins.RT.startTimer and BOOMR.plugins.RT.setTimer. These timers can be used to track sub-components on the page or other arbitrary events. The timer name given to BOOMR.plugins.RT.startTimer or BOOMR.plugins.RT.setTimer and elapsed time of the timer is added to the t_other beacon parameter. If there are multiple additional timers, they are appended to each other, separated by commas. Example beacon data: t_other=header|1234,ads|500 Example usage: &lt;html&gt; &lt;head&gt; &lt;script&gt; // measure how long it took for this JavaScript to start BOOMR.plugins.RT.setTimer(\"t_js\", BOOMR.now() - performance.timing.navigationStart); // start tracking how long it takes to execute things in the HEAD BOOMR.plugins.RT.startTimer(\"t_head\"); &lt;/script&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\"&gt; &lt;!-- ... --&gt; &lt;script&gt; // stop tracking how long it takes to execute things in the HEAD BOOMR.plugins.RT.endTimer(\"t_head\"); &lt;/script&gt; &lt;/head&gt; &lt;!-- ... --&gt; × Search results Close "},"tutorial-howto-add-arbitrary-data-to-the-beacon.html":{"id":"tutorial-howto-add-arbitrary-data-to-the-beacon.html","title":"Tutorial: Adding arbitrary data to the beacon","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Adding arbitrary data to the beacon You may want to add additional parameters to each beacon. For example, you may want to tag the beacon with a Page Group or you may want to do A/B testing and tag the beacon specifying which bucket this beacon is for. You can achieve all of this using BOOMR.addVar(). Before you use this method, remember that each plugin adds its own parameters and you should avoid overwriting these with your own values. See Boomerang and each plugin for documentation on what data it adds to the beacon. Adding Data to the Beacon BOOMR.addVar can be used to add any arbitrary data you want to the beacon. Example usage: BOOMR.addVar(\"ab_test\", \"a\"); If you need to set multiple parameters, you can supply an object instead: BOOMR.addVar({ \"ab_test\": \"a\" \"customer_id\": 123 }); The beacon will include all variables that you add in the URL. Both keys and values will be URI encoded. Your beacon endpoint will need to understand the data. http://yoursite.com/beacon/?t_done=500&amp;ab_test=1&amp;customer_id=123&amp;... Removing Data from the Beacon You can also remove a parameter that you've added (or that a plugin has added) from the beacon. To do this, call BOOMR.removeVar: // remove a single parameter BOOMR.removeVar(\"ab_test\"); // remove multiple parameters BOOMR.removeVar(\"ab_test\", \"customer_id\", \"something_else\"); × Search results Close "},"tutorial-howto-delay-page-load-time.html":{"id":"tutorial-howto-delay-page-load-time.html","title":"Tutorial: Delaying the Page Load time","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Delaying the Page Load time By default, Boomerang will wait for the window load event before it sends a beacon, and the Page Load timestamp (t_done) will be measured until the end of that load event. For some cases, you may want to have the Page Load time measure to a timestamp other than the window load event. For example, your application may load additional libraries or images at load, and you want the Page Load time to reflect that. To have Boomerang ignore the window load event, you must do two things: Set autorun to false in BOOMR.init When you want to mark the Page Load time done, you need to call BOOMR.page_ready Example code: BOOMR.init({ beacon_url: \"http://yoursite.com/beacon/\", autorun: false }); // ... // at some later point, when the page is loaded: BOOMR.page_ready(); Boomerang will send the Page Load beacon when BOOMR.page_ready is called. × Search results Close "},"tutorial-howto-read-data-from-a-beacon.html":{"id":"tutorial-howto-read-data-from-a-beacon.html","title":"Tutorial: Reading data from a beacon","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Reading data from a beacon While Boomerang excels at collecting Real User Monitoring performance metrics, you'll probably want to do something with the data that it collects. What can you do with the data? Beacon results back to your server For most cases you'll want to send the collected performance data back to your server or to the cloud so you can analyze it in aggregate. The first thing you need to do is configure a url that beacon data will be sent to. The beacon URL can be configured via the beacon_url parameter of BOOMR.init: &lt;script src=\"boomerang.js\"&gt;&lt;/script&gt; &lt;script&gt; BOOMR.init({ beacon_url: \"http://yoursite.com/beacon/\" }); &lt;/script&gt; beacon_url should be a HTTP(s) endpoint that accepts beacon data encoded in the query string (via &lt;IMG&gt; GET requests) and application/x-www-form-urlencoded form data (via POST requests from XMLHttpRequest or navigator.sendBeacon()). Beacon Parameters Boomerang and each plugin adds its own parameters to the beacon. Please refer to those documentation pages for details. Backend Servers There are several open-source projects that can receive and analyze Boomerang data: boomcatch boomerang-express PIWIK Backoffice of Basic RUM Boomerang Beacon Catcher of Basic RUM Boomerang-OpenTelemetry Plugin Boomerang Drupal Module Boomerang OpenACS plugin Here are some articles for putting it all together: A Low Cost Performance Monitoring Setup with Boomerang, Boomcatch, and Datadog End User Monitoring with Ocelot Real User Monitoring using Boomerang, Boomcatch, StatsD, and Graphite — Setup guide Protecting the Beacon from Abuse There are two types of beacon abuse you may need to protect against: Denial of Service (DoS) attacks Fake beacons that do not originate from a page you own Denial of Service (DoS) attacks There's nothing you can do in JavaScript to prevent Denial of Service (DoS) attacks, but you can configure your server to rate limit beacons originating from a single IP. You typically shouldn't be receiving beacons faster than a user can navigate through your website. However, you may need to allow for multiple users originating from the same proxy IP address. You'll also want to do some operating system/web server level configuration to detect abusive access patterns. The majority of these are beyond the scope of this document, but we have a few tips on building your back-end to protect you from an attack. One recommendation is to have a lightweight web server running as your beacon endpoint, and have this server quickly log the request and immediately respond without processing the data. You can send a HTTP 204 No Content response and close the connection so there is minimal overhead. Once the data is logged, you can periodically batch process and analyze the incoming data. More references for preventing DoS attacks: learn-netowrking.com wikipedia.org cert.org Fake beacons that do not originate from a page you own The most common reason for this kind of abuse is that someone liked your page design and copied it to their own server, including the boomerang JavaScript -- only they didn't update the beacon_url, so it still beacons to your server. You probably don't want these beacons. The easiest way to fix this is to just check the HTTP referrer of all requests and block any that don't come from your own domain. This works for the clueless abuser case, but not for the intentional abuser. The intentional abuser is someone who will try to exploit URLs on your site to see if they can get something out of it. What they try isn't really important -- there's only one legitimate way of using your beacon, and you should block all other uses. The best way to do this is through a nonce or a crumb. This is a string that is valid for one use only. It probably includes the current timestamp and a validity period as part of its hash. You generate it on every page request and add it to Boomerang using BOOMR.addVar. On your beacon endpoint, you then validate the nonce before accepting the beacon. You can either include this nonce in your (non-cached) HTML page, or, fetch it from your server via a XMLHttpRequest. The nonce also doesn't protect you from someone pulling the beacon out of your page (with a valid nonce), then modifying the beacon parameters and sending it off to your server. Protecting against this requires you to sign the parameters in the beacon, but this isn't something that you can do in JavaScript in a way that an attacker couldn't replicate. Read beacon data from JavaScript You can get a notification of each beacon before it is sent by subscribing to the before_beacon event: BOOMR.subscribe('before_beacon', function(beaconData) { if (beaconData.u.indexOf(\"/some/page\")) { // take some action based on the page } // you can still add data to the beacon at this point beaconData.someData = 1; }); You can also get a notification of each beacon after it was sent by subscribing to the beacon event: BOOMR.subscribe('beacon', function(beaconData) { // remove beacon data that was only relevant for a single beacon BOOMR.removeVar('someData'); }); References IPC Berlin 2010 talk on MySQL scaling via Philip Tellis ConFoo 2010 talk on the statistics of web performance via Philip Tellis × Search results Close "},"tutorial-howto-resourcetiming-buffer.html":{"id":"tutorial-howto-resourcetiming-buffer.html","title":"Tutorial: Managing the ResourceTiming Buffer","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Managing the ResourceTiming Buffer ResourceTiming is a browser performance API that gathers accurate performance metrics about all of the resources fetched during the page load, such as images, CSS and JavaScript. Boomerang can capture this data automatically. By default, the Resource Timing API only tracks the first 150 resources (per IFRAME). While this limit can be manipulated by the developer in order to track more resources via window.performance.setResourceTimingBufferSize(), there are performance trade-offs (additional memory consumption) when doing this, so Boomerang doesn't make these changes automatically. If you are using one of the Boomerang SPA plugins, the browser might hit the 150 limit quickly, as the browser will not clear the resources for SPA navigations. Therefore, you may want to increase the buffer size or clear the resources every time a beacon is sent. The following code examples show how you can increase the limit, or clear the resources after each Boomerang beacon. Set the Resource Timings Buffer To increase the ResourceTiming buffer size above the default of 150, you can use window.performance.setResourceTimingBufferSize(n): (function(w){ if (!w || !(\"performance\" in w) || !w.performance || !w.performance.setResourceTimingBufferSize) { return; } w.performance.setResourceTimingBufferSize(&lt;size&gt;); })(window); Clear the Resource Timings Buffer To clear the ResourceTimings buffer on each beacon, you can use window.performance.clearResourceTimings(): (function(w){ if (!w || !(\"performance\" in w) || !w.performance || !w.performance.clearResourceTimings) { return; } document.addEventListener(\"onBoomerangBeacon\", w.performance.clearResourceTimings.bind(w.performance)); })(window); × Search results Close "},"tutorial-howto-measure-arbitrary-events.html":{"id":"tutorial-howto-measure-arbitrary-events.html","title":"Tutorial: Measuring arbitrary events","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Measuring arbitrary events Boomerang has utility methods to assist in measuring the elapsed time of any arbitrary event you want to measure. Note: If you want to measure XMLHttpRequests, you should utilize the AutoXHR plugin. There are two ways of measuring events: Call BOOMR.requestStart() to mark the beginning of the event, then call .loaded() to mark when it is complete Call BOOMR.responseEnd() with your own timestamps or elapsed time Both of these methods will trigger a beacon with the Page Group (h.pg) set to the input name. Using BOOMR.requestStart BOOMR.requestStart can be used to have Boomerang track a complete event. When BOOMR.requestStart is called, Boomerang will mark the start time. Once the event is complete, you can call .loaded() on the returned object to mark the end timestamp. Example: var timer = BOOMR.requestStart(\"my-timer\"); setTimeout(function() { // will send a beacon with the page group of \"my-timer\" // and an elapsed time of approximately 1 second timer.loaded(); }, 1000); Using BOOMR.responseEnd BOOMR.responseEnd can be used to immediately send a beacon based on the given start time (and optional end time). Example: var startTime = BOOMR.now(); setTimeout(function() { // immediately sends a beacon with the page group of \"my-timer\" and // measured from the startTime to now. BOOMR.responseEnd(\"my-timer\", startTime); // you can also specify the end time, i.e. 500ms ago BOOMR.responseEnd(\"my-other-timer\", startTime, {}, BOOMR.now() - 500); }, 1000); × Search results Close "},"tutorial-howto-opt-out-or-opt-in.html":{"id":"tutorial-howto-opt-out-or-opt-in.html","title":"Tutorial: Opt-out or Opt-in","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Opt-out or Opt-in Disclaimer: This tutorial does not constitute legal advice or a legal opinion on any matter discussed. This tutorial is for educational purposes only. If you have a specific legal question, please consult with an attorney of your own choice. Boomerang is an open source JavaScript library that measures a web site’s performance. As such it is considered in some countries in the EU and Asia as “cookie technology” and triggers certain data protection requirements. Such requirements vary depending on the categorization of cookie technology used for website performance measurement by local authorities. Some authorities require consent by end users to the cookie technology prior to its placement on a website (\"opt-in\"). According to GDPR and other applicable laws, such consent must be freely given, specific, informed and unambiguous. Some authorities accept the placement of cookie technology on a website without consent and require the implementation of a mechanism to stop the cookie usage once the end user requests so (\"opt-out\"). Such setup is e.g. accepted under CCPA, the California Consumer Privacy Act that entered into force January 1, 2020. This tutorial describes techniques and configurations that help Boomerang users to instrument opt-out and opt-in scenarios. In addition the tutorial describes how to instrument 3 different consent management techniques via special Consent Inlined Plugin, a Boomerang Loader Wrapper and the Osano Cookies Consent library. Tutorial structure: Opt-out and Opt-in scenarios Cookies and Local Storage Consent Inline Plugin Overview Opt-out example Opt-in example Opt-in with Boomerang Loader Wrapper Cookie Consent library and Consent Inline Plugin example Opt-out example Opt-in example 1. Opt-out and Opt-in scenarios We identified 3 common scenarios how Boomerang could be loaded to comply with the applicable data protection requirements. Opt-out from Boomerang: By default Boomerang is loaded on the page and sends performance data. Boomerang will be disabled and the Boomerang cookies will be deleted if a visitor opts-out from Boomerang through Cookie Consent popup. Before opt-out After opt-out Boomerang Loaded Yes Yes Beacons Sent Yes No RT Cookie exists Yes No BA Cookie exists Yes No BOOMR_CONSENT Cookie exists No Yes (value opted-out) Extra beacon params No No Opt-in to Boomerang (Boomerang loaded before opt-in): By default Boomerang is loaded on the page and does NOT send performance data. Performance data will be sent after a visitor opts-in to Boomerang through a Cookie Consent popup. Before opt-in After opt-in Boomerang Loaded Yes Yes Beacons Sent No Yes RT Cookie exists Yes Yes BA Cookie exists Yes Yes BOOMR_CONSENT Cookie exists No Yes (value opted-in) Extra beacon params No cip.in, cip.v * cip.in, cip.v parameters are being sent on first beacon after opt-in and they indicate that visitor opted-in and Consent Inlined Plugin version. Opt-in to Boomerang (Boomerang loaded after opt-in): Boomerang will be loaded and performance data sent after only after a visitor opts-in to Boomerang through the Cookie Consent popup. Before opt-in After opt-in Boomerang Loaded No Yes Beacons Sent No Yes RT Cookie exists No Yes BA Cookie exists No Yes Extra beacon params No No 2. Cookies and Local Storage 2.1 Cookies List of cookies created and used by Boomerang: Name Expires Type Description RT 7 days First-party Doesn't contain personal information but it contains various pieces of information about the visitor's session, such as number of visited pages, session start time, last visited url and etc. BA 7 days First-party Used by Bandwidth Boomerang plugin. Doesn't contain personal information. BOOMR_CONSENT 1 year First-party Contains information about visitor's choice for opt-out or opt-in. For detailed information about what data is kept on the cookies listed above, please read the \"Cookies\" section of Boomerang documentation page. 2.2 Local Storage (mPulse users specific) For mPulse customers, in some instances Boomerang will persist data in Browser's Local Storage. In these instances a Local Storage is used for performance optimization and reduction of network round trips. List of local storage keys used by Boomerang: Key Plugin Description _boomr_LOGN LOGN Persists Boomerang JSON configuration. Helps for faster Boomerang initialization. Doesn't contain personal information. _boomr_akamaiXhrRetry Akamai Persists a flag that instructs the Akamai plugin when to perform requests. Doesn't contain personal information. 3. Consent Inline Plugin The Consent Inline Plugin is not part of the Boomerang build but it could be easily injected before Boomerang code which will make the plugin available. The plugin provides 2 helper functions window.BOOMR_OPT_OUT() and window.BOOMR_OPT_IN() that can be used for instrumenting opt-out and opt-in. When window.BOOMR_OPT_OUT() is called Boomerang will stop sending beacon data, RT and BA cookies will be deleted and the new special BOOMR_CONSENT cookie with value opted-out will be created. Consent Inline Plugin has the capability to instruct Boomerang to hold beacon sending until window.BOOMR_OPT_IN() is called. When window.BOOMR_OPT_IN() is called a cookie BOOMR_CONSENT with value opted-in will be created. The purpose of BOOMR_CONSENT cookie is to \"tell\" Boomerang what was the visitor's consent choice when a visitor navigates to a new page. 3.1 Opt-out allowed example In case we would like to allow website visitors to opt-out from Boomerang we must follow the steps in this order: Inject Consent Inline Plugin configuration: &lt;script&gt; window.BOOMR_CONSENT_CONFIG = { enabled: true }; &lt;/script&gt; Inject Consent Inline Plugin code: &lt;script&gt; !function(o){&quot;use strict&quot;;if(void 0!==o.BOOMR_CONSENT_CONFIG&amp;&amp;!0===o.BOOMR_CONSENT_CONFIG.enabled){o.BOOMR=void 0!==o.BOOMR?o.BOOMR:{};var i=o.BOOMR;i.plugins=void 0!==i.plugins?i.plugins:{};if(!i.plugins.ConsentInlinedPlugin){var n={v:&quot;1&quot;,OPT_COOKIE:&quot;BOOMR_CONSENT&quot;,OPT_IN_COOKIE_VAL:&quot;opted-in&quot;,OPT_OUT_COOKIE_VAL:&quot;opted-out&quot;,COOKIE_EXP:31536e3,complete:!1,enabled:!0,firedPageReady:!1,deferredOptIn:!1,deferredOptOut:!1,rtCookieFromConfig:!1,bwCookieFromConfig:!1,optOut:function(){if(!i.utils.setCookie(n.OPT_COOKIE,n.OPT_OUT_COOKIE_VAL,n.COOKIE_EXP)){i.error(&quot;Can not set Opt Out cookie&quot;,&quot;ConsentInlinedPlugin&quot;);return!1}&quot;function&quot;==typeof i.disable&amp;&amp;i.disable();n.complete=!1;n.removeBoomerangCookies();return!0},optIn:function(){if(!0===n.complete)return!0;if(!i.utils.setCookie(n.OPT_COOKIE,n.OPT_IN_COOKIE_VAL,n.COOKIE_EXP)){i.error(&quot;Can not set Opt In value&quot;,&quot;ConsentInlinedPlugin&quot;);return!1}&quot;function&quot;==typeof i.wakeUp&amp;&amp;i.wakeUp();n.complete=!0;i.addVar(&quot;cip.in&quot;,&quot;1&quot;,!0);i.addVar(&quot;cip.v&quot;,n.v,!0);i.sendBeacon();return!0},removeBoomerangCookies:function(){var e=n.rtCookieFromConfig||&quot;RT&quot;,o=n.bwCookieFromConfig||&quot;BA&quot;;i.utils.removeCookie(e);i.utils.removeCookie(o)},onPageReady:function(){n.firedPageReady=!0;n.deferredOptIn&amp;&amp;n.optIn();n.deferredOptOut&amp;&amp;n.optOut()}};o.BOOMR_OPT_OUT=function(){n.firedPageReady?n.optOut():n.deferredOptOut=!0};o.BOOMR_OPT_IN=function(){n.firedPageReady?n.optIn():n.deferredOptIn=!0};i.plugins.ConsentInlinedPlugin={init:function(e){void 0!==e.RT&amp;&amp;void 0!==e.RT.cookie&amp;&amp;(n.rtCookieFromConfig=e.RT.cookie);void 0!==e.BW&amp;&amp;void 0!==e.BW.cookie&amp;&amp;(n.bwCookieFromConfig=e.BW.cookie);i.subscribe(&quot;page_ready&quot;,n.onPageReady,null,n);if(o.BOOMR_CONSENT_CONFIG.optInRequired&amp;&amp;i.utils.getCookie(n.OPT_COOKIE)!==n.OPT_IN_COOKIE_VAL){n.complete=!1;return this}if(i.utils.getCookie(n.OPT_COOKIE)===n.OPT_OUT_COOKIE_VAL){void 0===e.RT&amp;&amp;(e.RT={});e.RT.cookie=&quot;&quot;;void 0===e.BW&amp;&amp;(e.BW={});e.BW.cookie=&quot;&quot;;n.complete=!1;return this}n.complete=!0;return this},is_complete:function(){return n.complete}}}}}(window); &lt;/script&gt; Load Boomerang via loader snippet. Call window.BOOMR_OPT_OUT() when visitor opts-out via Cookie consent popup or other UI element. 3.2 Opt-in required example When we would like to not send Beacon data until visitor opts-in to Boomerang we must follow the steps in this order: Inject Consent Inline Plugin configuration: &lt;script&gt; window.BOOMR_CONSENT_CONFIG = { enabled: true, optInRequired: true }; &lt;/script&gt; Inject Consent Inline Plugin code: &lt;script&gt; !function(o){&quot;use strict&quot;;if(void 0!==o.BOOMR_CONSENT_CONFIG&amp;&amp;!0===o.BOOMR_CONSENT_CONFIG.enabled){o.BOOMR=void 0!==o.BOOMR?o.BOOMR:{};var i=o.BOOMR;i.plugins=void 0!==i.plugins?i.plugins:{};if(!i.plugins.ConsentInlinedPlugin){var n={v:&quot;1&quot;,OPT_COOKIE:&quot;BOOMR_CONSENT&quot;,OPT_IN_COOKIE_VAL:&quot;opted-in&quot;,OPT_OUT_COOKIE_VAL:&quot;opted-out&quot;,COOKIE_EXP:31536e3,complete:!1,enabled:!0,firedPageReady:!1,deferredOptIn:!1,deferredOptOut:!1,rtCookieFromConfig:!1,bwCookieFromConfig:!1,optOut:function(){if(!i.utils.setCookie(n.OPT_COOKIE,n.OPT_OUT_COOKIE_VAL,n.COOKIE_EXP)){i.error(&quot;Can not set Opt Out cookie&quot;,&quot;ConsentInlinedPlugin&quot;);return!1}&quot;function&quot;==typeof i.disable&amp;&amp;i.disable();n.complete=!1;n.removeBoomerangCookies();return!0},optIn:function(){if(!0===n.complete)return!0;if(!i.utils.setCookie(n.OPT_COOKIE,n.OPT_IN_COOKIE_VAL,n.COOKIE_EXP)){i.error(&quot;Can not set Opt In value&quot;,&quot;ConsentInlinedPlugin&quot;);return!1}&quot;function&quot;==typeof i.wakeUp&amp;&amp;i.wakeUp();n.complete=!0;i.addVar(&quot;cip.in&quot;,&quot;1&quot;,!0);i.addVar(&quot;cip.v&quot;,n.v,!0);i.sendBeacon();return!0},removeBoomerangCookies:function(){var e=n.rtCookieFromConfig||&quot;RT&quot;,o=n.bwCookieFromConfig||&quot;BA&quot;;i.utils.removeCookie(e);i.utils.removeCookie(o)},onPageReady:function(){n.firedPageReady=!0;n.deferredOptIn&amp;&amp;n.optIn();n.deferredOptOut&amp;&amp;n.optOut()}};o.BOOMR_OPT_OUT=function(){n.firedPageReady?n.optOut():n.deferredOptOut=!0};o.BOOMR_OPT_IN=function(){n.firedPageReady?n.optIn():n.deferredOptIn=!0};i.plugins.ConsentInlinedPlugin={init:function(e){void 0!==e.RT&amp;&amp;void 0!==e.RT.cookie&amp;&amp;(n.rtCookieFromConfig=e.RT.cookie);void 0!==e.BW&amp;&amp;void 0!==e.BW.cookie&amp;&amp;(n.bwCookieFromConfig=e.BW.cookie);i.subscribe(&quot;page_ready&quot;,n.onPageReady,null,n);if(o.BOOMR_CONSENT_CONFIG.optInRequired&amp;&amp;i.utils.getCookie(n.OPT_COOKIE)!==n.OPT_IN_COOKIE_VAL){n.complete=!1;return this}if(i.utils.getCookie(n.OPT_COOKIE)===n.OPT_OUT_COOKIE_VAL){void 0===e.RT&amp;&amp;(e.RT={});e.RT.cookie=&quot;&quot;;void 0===e.BW&amp;&amp;(e.BW={});e.BW.cookie=&quot;&quot;;n.complete=!1;return this}n.complete=!0;return this},is_complete:function(){return n.complete}}}}}(window); &lt;/script&gt; Load Boomerang via loader snippet. Call window.BOOMR_OPT_IN() when a visitor opted in via Cookie consent popup or other UI element. 4. Opt-in with Boomerang Loader Wrapper Users of Boomerang open source and some mPulse customers have to manually inject Boomerang on the page. This opens a possibility of waiting for the Boomerang loader snippet to be executed until after a visitor opts-in to Boomerang through Cookie Consent popup. By doing so, Boomerang won't be loaded until after opt-in has been chosen. This technique is simple and can be done in 2 steps: Wrap Boomerang loader snippet in BOOMERANG_LOADER_SNIPPET_WRAPPER() function. The example below doesn't include the full loader snippet source code but you can get the full code of the loader snippet from here: Non-Blocking Loader Snippet &lt;script&gt; var BOOMERANG_LOADER_SNIPPET_WRAPPER = function() { (function() { // Boomerang Loader Snippet if (window.BOOMR &amp;&amp; (window.BOOMR.version || window.BOOMR.snippetExecuted)) { return; } // ... // ... // ... })(); } &lt;/script&gt; Call BOOMERANG_LOADER_SNIPPET_WRAPPER() function when visitor opts-in. Usually Cookie Consent popup libraries provide callback functions that help us to instrument opt-out and opt-in procedures. For simplicity we will define a callback function with example name onOptIn() where we will run the code needed for opt-in. In our case we have to place BOOMERANG_LOADER_SNIPPET_WRAPPER() in our callback function onOptIn(). &lt;script&gt; function onOptIn() { BOOMERANG_LOADER_SNIPPET_WRAPPER(); } &lt;/script&gt; 5. Cookie Consent library and Consent Inline Plugin example We prepared Boomerang opt-out and opt-in examples with the popular open source project - Osano Cookie Consent popup library. For the given examples below we assume that the needed Cookie Consent popup script and Boomerang Consent Inline Plugin are loaded on the page. 5.1 Opt-out // Setup Osano Cookie popup function onCookieConsentChange(consent) { if (consent === \"deny\") { window.BOOMR_OPT_OUT(); } } window.addEventListener(\"load\", function() { window.cookieconsent.initialise({ \"type\": \"opt-out\", \"content\": { \"href\": \"https://www.example.com/policies/\" }, onInitialise: onCookieConsentChange, onStatusChange: onCookieConsentChange, onRevokeChoice: onCookieConsentChange }); }); 5.2 Opt-in // Setup Osano Cookie popup function onCookieConsentChange(consent) { if (consent === \"allow\") { window.BOOMR_OPT_IN(); } } window.addEventListener(\"load\", function() { window.cookieconsent.initialise({ \"type\": \"opt-in\", \"content\": { \"href\": \"https://www.example.com/policies/\" }, onInitialise: onCookieConsentChange, onStatusChange: onCookieConsentChange, onRevokeChoice: onCookieConsentChange }); }); × Search results Close "},"tutorial-loader-snippet.html":{"id":"tutorial-loader-snippet.html","title":"Tutorial: Non-Blocking Loader Snippet","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Non-Blocking Loader Snippet If you are loading boomerang.js separately from your main application bundle, i.e. from a CDN or a third-party service (such as mPulse), we recommend loading boomerang.js using the CSP-compliant non-blocking script loader pattern. The methodology, developed by Philip Tellis and others, and further improved in 2018, ensures Boomerang (or any third-party JavaScript) loads asynchronously and non-blocking. This means that the browser will not pause while the JavaScript is loading, nor will it block the onload event. The Boomerang Loader Snippet is currently around 210 lines of code (with comments), and minifies to around 2500 bytes. The snippet does the following: It checks whether or not the snippet has already been run or Boomerang has already been loaded. If so, it exits. It adds a window load event handler, to ensure that Boomerang can measure the Page Load time in non-NavigationTiming browsers, even if boomerang.js loads after the load event. For browsers that support Preload &lt;link rel=\"preload\" as=\"script\"&gt;, Boomerang will add a &lt;link&gt; node to tell the browser to fetch Boomerang.js. Once the Preload has finished, Boomerang adds a regular &lt;script&gt; node to the page with the same Boomerang URL, which tells the browser to execute Boomerang. For browsers that do not support Preload, or if Preload fails or doesn't trigger within the defined timeframe (default 3 seconds), the non-blocking IFRAME loader method is used. A hidden &lt;iframe&gt; is injected into the page. The snippet attempts to read the IFRAME's contentWindow.document. If it can't, it updates the IFRAME's src to add JavaScript that sets the IFRAME's document.domain to the current page's document.domain. This ensures the anonymous IFRAME can communicate with the host page. It writes a function _l() to the IFRAME's document which will add a &lt;script&gt; tag that loads boomerang.js. It sets the IFRAME's &lt;body onload=\"document._l()\"&gt; to run the function above, so the &lt;script&gt; tag is loaded after the IFRAME's onload event has fired. For IE 6 and IE 7, which don't support the non-blocking IFRAME loader method (due to problems they have with about:blank URLs in secure contexts), a dynamic &lt;script&gt; node is added to the page. Note this means that in IE 6 and 7, Boomerang could be a SPOF (Single Point of Failure) if the script is delayed, potentially delaying the Page Load. Note: We split the &lt;body tag insertion into &lt;bo and dy to avoid server-side output filters that may replace &lt;body tags with their own code. For proof that the non-blocking script loader pattern does not affect page load, you can look at this test case that delays JavaScript from loading by 5 seconds or these WebPagetest results. The Snippet Here's the snippet: &lt;script&gt; (function() {
	// Boomerang Loader Snippet version 14
	if (window.BOOMR &amp;&amp; (window.BOOMR.version || window.BOOMR.snippetExecuted)) {
		return;
	}

	window.BOOMR = window.BOOMR || {};
	window.BOOMR.snippetStart = new Date().getTime();
	window.BOOMR.snippetExecuted = true;
	window.BOOMR.snippetVersion = 14;

	// NOTE: Set Boomerang URL here
	window.BOOMR.url = &quot;&quot;;

	var // document.currentScript is supported in all browsers other than IE
	    where = document.currentScript || document.getElementsByTagName(&quot;script&quot;)[0],
	    // Parent element of the script we inject
	    parentNode = where.parentNode,
	    // Whether or not Preload method has worked
	    promoted = false,
	    // How long to wait for Preload to work before falling back to iframe method
	    LOADER_TIMEOUT = 3000;

	// Tells the browser to execute the Preloaded script by adding it to the DOM
	function promote() {
		if (promoted) {
			return;
		}

		var script = document.createElement(&quot;script&quot;);
		script.id = &quot;boomr-scr-as&quot;;
		script.src = window.BOOMR.url;

		// Not really needed since dynamic scripts are async by default and the script is already in cache at this point,
		// but some naive parsers will see a missing async attribute and think we're not async
		script.async = true;

		parentNode.appendChild(script);

		promoted = true;
	}

	// Non-blocking iframe loader (fallback for non-Preload scenarios) for all recent browsers.
	// For IE 6/7, falls back to dynamic script node.
	function iframeLoader(wasFallback) {
		promoted = true;

		var dom, doc = document, bootstrap, iframe, iframeStyle, win = window;

		window.BOOMR.snippetMethod = wasFallback ? &quot;if&quot; : &quot;i&quot;;

		// Adds Boomerang within the iframe
		bootstrap = function(parent, scriptId) {
			var script = doc.createElement(&quot;script&quot;);
			script.id = scriptId || &quot;boomr-if-as&quot;;
			script.src = window.BOOMR.url;

			BOOMR_lstart = new Date().getTime();

			parent = parent || doc.body;
			parent.appendChild(script);
		};

		// For IE 6/7, we'll just load the script in the current frame, as those browsers don't support 'about:blank'
		// for an iframe src (it triggers warnings on secure sites).  This means loading on IE 6/7 may cause SPoF.
		if (!window.addEventListener &amp;&amp; window.attachEvent &amp;&amp; navigator.userAgent.match(/MSIE [67]\./)) {
			window.BOOMR.snippetMethod = &quot;s&quot;;

			bootstrap(parentNode, &quot;boomr-async&quot;);
			return;
		}

		// The rest of this function is IE8+ and other browsers that don't support Preload hints but will work with CSP &amp; iframes
		iframe = document.createElement(&quot;IFRAME&quot;);

		// An empty frame
		iframe.src = &quot;about:blank&quot;;

		// We set title and role appropriately to play nicely with screen readers and other assistive technologies
		iframe.title = &quot;&quot;;
		iframe.role = &quot;presentation&quot;;

		// Ensure we're not loaded lazily
		iframe.loading = &quot;eager&quot;;

		// Hide the iframe
		iframeStyle = (iframe.frameElement || iframe).style;
		iframeStyle.width = 0;
		iframeStyle.height = 0;
		iframeStyle.border = 0;
		iframeStyle.display = &quot;none&quot;;

		// Append to the end of the current block
		parentNode.appendChild(iframe);

		// Try to get the iframe's document object
		try {
			win = iframe.contentWindow;
			doc = win.document.open();
		}
		catch (e) {
			// document.domain has been changed and we're on an old version of IE, so we got an access denied.
			// Note: the only browsers that have this problem also do not have CSP support.

			// Get document.domain of the parent window
			dom = document.domain;

			// Set the src of the iframe to a JavaScript URL that will immediately set its document.domain to match the parent.
			// This lets us access the iframe document long enough to inject our script.
			// Our script may need to do more domain massaging later.
			iframe.src = &quot;javascript:var d=document.open();d.domain='&quot; + dom + &quot;';void 0;&quot;;
			win = iframe.contentWindow;

			doc = win.document.open();
		}

		if (dom) {
			// Unsafe version for IE8 compatibility. If document.domain has changed, we can't use win, but we can use doc.
			doc._boomrl = function() {
				this.domain = dom;
				bootstrap();
			};

			// Run our function at load.
			// Split the string so HTML code injectors don't get confused and add code here.
			doc.write(&quot;&lt;bo&quot; + &quot;dy onload='document._boomrl();'&gt;&quot;);
		}
		else {
			// document.domain hasn't changed, regular method should be OK
			win._boomrl = function() {
				bootstrap();
			};

			if (win.addEventListener) {
				win.addEventListener(&quot;load&quot;, win._boomrl, false);
			}
			else if (win.attachEvent) {
				win.attachEvent(&quot;onload&quot;, win._boomrl);
			}
		}

		// Finish the document
		doc.close();
	}

	// See if Preload is supported or not
	var link = document.createElement(&quot;link&quot;);

	if (link.relList &amp;&amp;
	    typeof link.relList.supports === &quot;function&quot; &amp;&amp;
	    link.relList.supports(&quot;preload&quot;) &amp;&amp;
	    (&quot;as&quot; in link)) {
		window.BOOMR.snippetMethod = &quot;p&quot;;

		// Set attributes to trigger a Preload
		link.href = window.BOOMR.url;
		link.rel  = &quot;preload&quot;;
		link.as   = &quot;script&quot;;

		// Add our script tag if successful, fallback to iframe if not
		link.addEventListener(&quot;load&quot;, promote);
		link.addEventListener(&quot;error&quot;, function() {
			iframeLoader(true);
		});

		// Have a fallback in case Preload does nothing or is slow
		setTimeout(function() {
			if (!promoted) {
				iframeLoader(true);
			}
		}, LOADER_TIMEOUT);

		// Note the timestamp we started trying to Preload
		BOOMR_lstart = new Date().getTime();

		// Append our link tag
		parentNode.appendChild(link);
	}
	else {
		// No Preload support, use iframe loader
		iframeLoader(false);
	}

	// Save when the onload event happened, in case this is a non-NavigationTiming browser
	function boomerangSaveLoadTime(e) {
		window.BOOMR_onload = (e &amp;&amp; e.timeStamp) || new Date().getTime();
	}

	if (window.addEventListener) {
		window.addEventListener(&quot;load&quot;, boomerangSaveLoadTime, false);
	}
	else if (window.attachEvent) {
		window.attachEvent(&quot;onload&quot;, boomerangSaveLoadTime);
	}
})();
&lt;/script&gt; Minified: &lt;script&gt;(function(){if(window.BOOMR&amp;&amp;(window.BOOMR.version||window.BOOMR.snippetExecuted)){return}window.BOOMR=window.BOOMR||{};window.BOOMR.snippetStart=(new Date).getTime();window.BOOMR.snippetExecuted=true;window.BOOMR.snippetVersion=14;window.BOOMR.url=&quot;&quot;;var e=document.currentScript||document.getElementsByTagName(&quot;script&quot;)[0],a=e.parentNode,s=false,t=3e3;function n(){if(s){return}var e=document.createElement(&quot;script&quot;);e.id=&quot;boomr-scr-as&quot;;e.src=window.BOOMR.url;e.async=true;a.appendChild(e);s=true}function o(e){s=true;var t,o=document,n,i,d,r=window;window.BOOMR.snippetMethod=e?&quot;if&quot;:&quot;i&quot;;n=function(e,t){var n=o.createElement(&quot;script&quot;);n.id=t||&quot;boomr-if-as&quot;;n.src=window.BOOMR.url;BOOMR_lstart=(new Date).getTime();e=e||o.body;e.appendChild(n)};if(!window.addEventListener&amp;&amp;window.attachEvent&amp;&amp;navigator.userAgent.match(/MSIE [67]\./)){window.BOOMR.snippetMethod=&quot;s&quot;;n(a,&quot;boomr-async&quot;);return}i=document.createElement(&quot;IFRAME&quot;);i.src=&quot;about:blank&quot;;i.title=&quot;&quot;;i.role=&quot;presentation&quot;;i.loading=&quot;eager&quot;;d=(i.frameElement||i).style;d.width=0;d.height=0;d.border=0;d.display=&quot;none&quot;;a.appendChild(i);try{r=i.contentWindow;o=r.document.open()}catch(e){t=document.domain;i.src=&quot;javascript:var d=document.open();d.domain='&quot;+t+&quot;';void 0;&quot;;r=i.contentWindow;o=r.document.open()}if(t){o._boomrl=function(){this.domain=t;n()};o.write(&quot;&lt;bo&quot;+&quot;dy onload='document._boomrl();'&gt;&quot;)}else{r._boomrl=function(){n()};if(r.addEventListener){r.addEventListener(&quot;load&quot;,r._boomrl,false)}else if(r.attachEvent){r.attachEvent(&quot;onload&quot;,r._boomrl)}}o.close()}var i=document.createElement(&quot;link&quot;);if(i.relList&amp;&amp;typeof i.relList.supports===&quot;function&quot;&amp;&amp;i.relList.supports(&quot;preload&quot;)&amp;&amp;&quot;as&quot;in i){window.BOOMR.snippetMethod=&quot;p&quot;;i.href=window.BOOMR.url;i.rel=&quot;preload&quot;;i.as=&quot;script&quot;;i.addEventListener(&quot;load&quot;,n);i.addEventListener(&quot;error&quot;,function(){o(true)});setTimeout(function(){if(!s){o(true)}},t);BOOMR_lstart=(new Date).getTime();a.appendChild(i)}else{o(false)}function d(e){window.BOOMR_onload=e&amp;&amp;e.timeStamp||(new Date).getTime()}if(window.addEventListener){window.addEventListener(&quot;load&quot;,d,false)}else if(window.attachEvent){window.attachEvent(&quot;onload&quot;,d)}})();&lt;/script&gt; Delaying the Snippet You may want to delay loading Boomerang until after the onload event. This would ensure that no Boomerang code is executed in the critical-path of the page load. The main downside to doing this is that you are more likely to lose beacons from some users. The longer it takes Boomerang to load on the page, the higher chance that the user will have navigated away, or closed the browser, before boomerang.js is loaded. Here is a modification of the Boomerang Loader Snippet to delay until after onload: &lt;script&gt; (function() {
	// Boomerang Loader Snippet version 14
	if (window.BOOMR &amp;&amp; (window.BOOMR.version || window.BOOMR.snippetExecuted)) {
		return;
	}

	window.BOOMR = window.BOOMR || {};
	window.BOOMR.snippetStart = new Date().getTime();
	window.BOOMR.snippetExecuted = true;
	window.BOOMR.snippetVersion = 14;

	// NOTE: Set Boomerang URL here
	window.BOOMR.url = &quot;&quot;;

	var // document.currentScript is supported in all browsers other than IE
	    where = document.currentScript || document.getElementsByTagName(&quot;script&quot;)[0],
	    // Parent element of the script we inject
	    parentNode = where.parentNode,
	    // Whether or not Preload method has worked
	    promoted = false,
	    // How long to wait for Preload to work before falling back to iframe method
	    LOADER_TIMEOUT = 3000;

	// Tells the browser to execute the Preloaded script by adding it to the DOM
	function promote() {
		if (promoted) {
			return;
		}

		var script = document.createElement(&quot;script&quot;);
		script.id = &quot;boomr-scr-as&quot;;
		script.src = window.BOOMR.url;

		// Not really needed since dynamic scripts are async by default and the script is already in cache at this point,
		// but some naive parsers will see a missing async attribute and think we're not async
		script.async = true;

		parentNode.appendChild(script);

		promoted = true;
	}

	// Non-blocking iframe loader (fallback for non-Preload scenarios) for all recent browsers.
	// For IE 6/7, falls back to dynamic script node.
	function iframeLoader(wasFallback) {
		promoted = true;

		var dom, doc = document, bootstrap, iframe, iframeStyle, win = window;

		window.BOOMR.snippetMethod = wasFallback ? &quot;if&quot; : &quot;i&quot;;

		// Adds Boomerang within the iframe
		bootstrap = function(parent, scriptId) {
			var script = doc.createElement(&quot;script&quot;);
			script.id = scriptId || &quot;boomr-if-as&quot;;
			script.src = window.BOOMR.url;

			BOOMR_lstart = new Date().getTime();

			parent = parent || doc.body;
			parent.appendChild(script);
		};

		// For IE 6/7, we'll just load the script in the current frame, as those browsers don't support 'about:blank'
		// for an iframe src (it triggers warnings on secure sites).  This means loading on IE 6/7 may cause SPoF.
		if (!window.addEventListener &amp;&amp; window.attachEvent &amp;&amp; navigator.userAgent.match(/MSIE [67]\./)) {
			window.BOOMR.snippetMethod = &quot;s&quot;;

			bootstrap(parentNode, &quot;boomr-async&quot;);
			return;
		}

		// The rest of this function is IE8+ and other browsers that don't support Preload hints but will work with CSP &amp; iframes
		iframe = document.createElement(&quot;IFRAME&quot;);

		// An empty frame
		iframe.src = &quot;about:blank&quot;;

		// We set title and role appropriately to play nicely with screen readers and other assistive technologies
		iframe.title = &quot;&quot;;
		iframe.role = &quot;presentation&quot;;

		// Ensure we're not loaded lazily
		iframe.loading = &quot;eager&quot;;

		// Hide the iframe
		iframeStyle = (iframe.frameElement || iframe).style;
		iframeStyle.width = 0;
		iframeStyle.height = 0;
		iframeStyle.border = 0;
		iframeStyle.display = &quot;none&quot;;

		// Append to the end of the current block
		parentNode.appendChild(iframe);

		// Try to get the iframe's document object
		try {
			win = iframe.contentWindow;
			doc = win.document.open();
		}
		catch (e) {
			// document.domain has been changed and we're on an old version of IE, so we got an access denied.
			// Note: the only browsers that have this problem also do not have CSP support.

			// Get document.domain of the parent window
			dom = document.domain;

			// Set the src of the iframe to a JavaScript URL that will immediately set its document.domain to match the parent.
			// This lets us access the iframe document long enough to inject our script.
			// Our script may need to do more domain massaging later.
			iframe.src = &quot;javascript:var d=document.open();d.domain='&quot; + dom + &quot;';void 0;&quot;;
			win = iframe.contentWindow;

			doc = win.document.open();
		}

		if (dom) {
			// Unsafe version for IE8 compatibility. If document.domain has changed, we can't use win, but we can use doc.
			doc._boomrl = function() {
				this.domain = dom;
				bootstrap();
			};

			// Run our function at load.
			// Split the string so HTML code injectors don't get confused and add code here.
			doc.write(&quot;&lt;bo&quot; + &quot;dy onload='document._boomrl();'&gt;&quot;);
		}
		else {
			// document.domain hasn't changed, regular method should be OK
			win._boomrl = function() {
				bootstrap();
			};

			if (win.addEventListener) {
				win.addEventListener(&quot;load&quot;, win._boomrl, false);
			}
			else if (win.attachEvent) {
				win.attachEvent(&quot;onload&quot;, win._boomrl);
			}
		}

		// Finish the document
		doc.close();
	}

	function boomerangLoad() {
		// See if Preload is supported or not
		var link = document.createElement(&quot;link&quot;);

		if (link.relList &amp;&amp;
		    typeof link.relList.supports === &quot;function&quot; &amp;&amp;
		    link.relList.supports(&quot;preload&quot;) &amp;&amp;
		    (&quot;as&quot; in link)) {
			window.BOOMR.snippetMethod = &quot;p&quot;;

			// Set attributes to trigger a Preload
			link.href = window.BOOMR.url;
			link.rel  = &quot;preload&quot;;
			link.as   = &quot;script&quot;;

			// Add our script tag if successful, fallback to iframe if not
			link.addEventListener(&quot;load&quot;, promote);
			link.addEventListener(&quot;error&quot;, function() {
				iframeLoader(true);
			});

			// Have a fallback in case Preload does nothing or is slow
			setTimeout(function() {
				if (!promoted) {
					iframeLoader(true);
				}
			}, LOADER_TIMEOUT);

			// Note the timestamp we started trying to Preload
			BOOMR_lstart = new Date().getTime();

			// Append our link tag
			parentNode.appendChild(link);
		}
		else {
			// No Preload support, use iframe loader
			iframeLoader(false);
		}
	}

	// Save when the onload event happened, in case this is a non-NavigationTiming browser
	function boomerangSaveLoadTime(e) {
		window.BOOMR_onload = (e &amp;&amp; e.timeStamp) || new Date().getTime();
	}

	if (window.addEventListener) {
		window.addEventListener(&quot;load&quot;, boomerangSaveLoadTime, false);
	}
	else if (window.attachEvent) {
		window.attachEvent(&quot;onload&quot;, boomerangSaveLoadTime);
	}

	// Run at onload
	function windowOnLoad(e) {
		boomerangSaveLoadTime(e);
		setTimeout(boomerangLoad, 0);
	}

	// If we think the load event has already fired, load Boomerang now
	if ((&quot;performance&quot; in win &amp;&amp; win.performance &amp;&amp; win.performance.timing &amp;&amp; win.performance.timing.loadEventStart) ||
		(document.readyState === &quot;complete&quot;)) {
		boomerangLoad();
	}
	else {
		// Wait until onload
		if (win.addEventListener) {
			win.addEventListener(&quot;load&quot;, windowOnLoad, false);
		}
		else if (win.attachEvent) {
			win.attachEvent(&quot;onload&quot;, windowOnLoad);
		}
	}
})();
&lt;/script&gt; Minified: &lt;script&gt;(function(){if(window.BOOMR&amp;&amp;(window.BOOMR.version||window.BOOMR.snippetExecuted)){return}window.BOOMR=window.BOOMR||{};window.BOOMR.snippetStart=(new Date).getTime();window.BOOMR.snippetExecuted=true;window.BOOMR.snippetVersion=14;window.BOOMR.url=&quot;&quot;;var e=document.currentScript||document.getElementsByTagName(&quot;script&quot;)[0],r=e.parentNode,s=false,n=3e3;function t(){if(s){return}var e=document.createElement(&quot;script&quot;);e.id=&quot;boomr-scr-as&quot;;e.src=window.BOOMR.url;e.async=true;r.appendChild(e);s=true}function i(e){s=true;var n,i=document,t,o,d,a=window;window.BOOMR.snippetMethod=e?&quot;if&quot;:&quot;i&quot;;t=function(e,n){var t=i.createElement(&quot;script&quot;);t.id=n||&quot;boomr-if-as&quot;;t.src=window.BOOMR.url;BOOMR_lstart=(new Date).getTime();e=e||i.body;e.appendChild(t)};if(!window.addEventListener&amp;&amp;window.attachEvent&amp;&amp;navigator.userAgent.match(/MSIE [67]\./)){window.BOOMR.snippetMethod=&quot;s&quot;;t(r,&quot;boomr-async&quot;);return}o=document.createElement(&quot;IFRAME&quot;);o.src=&quot;about:blank&quot;;o.title=&quot;&quot;;o.role=&quot;presentation&quot;;o.loading=&quot;eager&quot;;d=(o.frameElement||o).style;d.width=0;d.height=0;d.border=0;d.display=&quot;none&quot;;r.appendChild(o);try{a=o.contentWindow;i=a.document.open()}catch(e){n=document.domain;o.src=&quot;javascript:var d=document.open();d.domain='&quot;+n+&quot;';void 0;&quot;;a=o.contentWindow;i=a.document.open()}if(n){i._boomrl=function(){this.domain=n;t()};i.write(&quot;&lt;bo&quot;+&quot;dy onload='document._boomrl();'&gt;&quot;)}else{a._boomrl=function(){t()};if(a.addEventListener){a.addEventListener(&quot;load&quot;,a._boomrl,false)}else if(a.attachEvent){a.attachEvent(&quot;onload&quot;,a._boomrl)}}i.close()}function o(){var e=document.createElement(&quot;link&quot;);if(e.relList&amp;&amp;typeof e.relList.supports===&quot;function&quot;&amp;&amp;e.relList.supports(&quot;preload&quot;)&amp;&amp;&quot;as&quot;in e){window.BOOMR.snippetMethod=&quot;p&quot;;e.href=window.BOOMR.url;e.rel=&quot;preload&quot;;e.as=&quot;script&quot;;e.addEventListener(&quot;load&quot;,t);e.addEventListener(&quot;error&quot;,function(){i(true)});setTimeout(function(){if(!s){i(true)}},n);BOOMR_lstart=(new Date).getTime();r.appendChild(e)}else{i(false)}}function d(e){window.BOOMR_onload=e&amp;&amp;e.timeStamp||(new Date).getTime()}if(window.addEventListener){window.addEventListener(&quot;load&quot;,d,false)}else if(window.attachEvent){window.attachEvent(&quot;onload&quot;,d)}function a(e){d(e);setTimeout(o,0)}if(&quot;performance&quot;in win&amp;&amp;win.performance&amp;&amp;win.performance.timing&amp;&amp;win.performance.timing.loadEventStart||document.readyState===&quot;complete&quot;){o()}else{if(win.addEventListener){win.addEventListener(&quot;load&quot;,a,false)}else if(win.attachEvent){win.attachEvent(&quot;onload&quot;,a)}}})();&lt;/script&gt; Known Issues Websites using Google Tag Manager (GTM) to inject the Loader Snippet may not see beacons from Firefox &lt;= 74 These versions of Firefox do not support Preload, so fallback to using the IFRAME loader boomerang.js is not fetched due to a Firefox bug with setting the iframe.src = \"about:blank\", which is done for Content Security Policies (CSP) compatibility Websites that are not using Content Security Policies can change:// An empty frame iframe.src = \"about:blank\"; to// An empty frame iframe.src = \"javascript:void(0)\"; Websites that are using Content Security Policies should use a &lt;script async&gt; tag to load boomerang.js instead of the Loader Snippet × Search results Close "},"tutorial-methodology.html":{"id":"tutorial-methodology.html","title":"Tutorial: Methodology","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Methodology How does Boomerang work? 1. Measuring Navigations We define Page Load Time (PLT) or Round Trip Time (RTT) as the time taken from the user initiating a navigation to when that page is completely available for the user to interact with. Modern browsers support the NavigationTiming API, which provides high-resolution timestamps for each stage of the navigation. Boomerang uses the NavigationTiming API when available to measure Page Load performance. In older browsers that do not support the NavigationTiming API, Boomerang is able to measure inter-site navigations by calculating the difference between when the old page is about to be unloaded (onbeforeunload) to when the new page is loaded (onload). This is how Boomerang measures Page Load in older browsers: On the current page (before the navigation), attach a callback to the window.onbeforeunload event. When onbeforeunload fires, log the timestamp and store it into a session cookie along with the URL of the current page. On the new page, attach a function to the window.onload event. When onload fires, log the timestamp. Look for the cookie where we set the start time and referrer Check the URL stored in the cookie with the document.referrer of the current document. If these two differ, it means that the user possibly visited a third party page in between the two pages from our site and the measurement is invalid, so we abort. If the above rules pass, we pull the time out of the cookie and remove the cookie. We measure the difference in the two times and this is the Page Load time for the current page. Note that in browsers that do not support NavigationTiming, Boomerang is unable to measure the Page Load time of the first navigation to a domain, since it is not running on the referrer page. For example, if a visitor comes from a search engine, the total Page Load time cannot be determined. 2. Measuring XMLHttpRequests See BOOMR.plugins.AutoXHR for more details. 3. Measuring Single Page Apps See BOOMR.plugins.SPA for more details. 4. Measuring Bandwidth &amp; Latency See BOOMR.plugins.BW for more details. 5. Measuring DNS See BOOMR.plugins.DNS for more details. 6. Measuring Waterfall See BOOMR.plugins.ResourceTiming for more details. 6. Measuring Other Arbitrary Events See Measuring arbitrary events for more details. × Search results Close "},"tutorial-page-overrides.html":{"id":"tutorial-page-overrides.html","title":"Tutorial: Page Overrides","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Page Overrides Boomerang may override (wrap) native DOM functions for monitoring purposes, depending on the plugins and features that are enabled. Generally, Boomerang wraps these functions to add a small amount of custom instrumentation, prior to executing the original function. The following is a list of known DOM overrides: Method Plugin Option Purpose XMLHttpRequest constructor BOOMR.plugins.AutoXHR instrument_xhr Monitor timing for XHRs (individual and during SPA navigations) fetch BOOMR.plugins.AutoXHR AutoXHR.monitorFetch Monitor timing for fetches (individual and during SPA navigations) window.onerror BOOMR.plugins.Errors Errors.monitorGlobal Monitor global exceptions console.error BOOMR.plugins.Errors Errors.monitorConsole Monitor app-generated error messages addEventListener BOOMR.plugins.Errors Errors.monitorEvents Wrapped so messages from cross-origin frames have a full stack removeEventListener BOOMR.plugins.Errors Errors.monitorEvents Wrapped so messages from cross-origin frames have a full stack setTimeout BOOMR.plugins.Errors Errors.monitorTimeout Wrapped so messages from cross-origin frames have a full stack setInterval BOOMR.plugins.Errors Errors.monitorTimeout Wrapped so messages from cross-origin frames have a full stack history.back BOOMR.plugins.History When BOOMR.plugins.History is enabled SPA Soft Navigation monitoring history.forward BOOMR.plugins.History When BOOMR.plugins.History is enabled SPA Soft Navigation monitoring history.pushState BOOMR.plugins.History When BOOMR.plugins.History is enabled SPA Soft Navigation monitoring history.replaceState BOOMR.plugins.History When BOOMR.plugins.History is enabled SPA Soft Navigation monitoring history.go BOOMR.plugins.History When BOOMR.plugins.History is enabled SPA Soft Navigation monitoring × Search results Close "},"tutorial-perf-tests.html":{"id":"tutorial-perf-tests.html","title":"Tutorial: Performance Tests","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Performance Tests Boomerang has a suite of performance tests to ensure code changes do not introduce performance regressions. The performance tests reside in tests/perf/. Running To run the performance tests: grunt perf This should run all suites in tests/perf/ and will save the results in tests/perf/results/: tests/perf/results/metrics.json: Results of each test tests/perf/results/[scenario].[test]: Raw results for each test tests/perf/results/baseline.json: Baseline comparison file (grunt perf:baseline) Example results: { \"00-basic\": { \"00-empty\": { \"page_load_time\": 27.5, \"boomerang_javascript_time\": 29.5, \"total_javascript_time\": 43, \"mark_startup_called\": 1, \"mark_check_doc_domain_called\": 4, ... } Comparing to a Baseline To compare performance results to a baseline, you first need to run this on the \"before\" codebase: grunt perf This will create tests/perf/results/baseline.json. Then, you can run performance tests against the \"current\" code by executing: grunt perf:compare This will create a new tests/perf/results/metrics.json each run, and will compare those results to tests/perf/results/baseline.json: $ grunt perf-compare --diff-only Running \"perf-compare\" task Results comparison to baseline: 00-basic.00-empty.page_load_time : 28 -1 (-4%) 00-basic.00-empty.mark_fire_event_before_beacon_called : [missing in baseline] Done. × Search results Close "},"tutorial-tests.html":{"id":"tutorial-tests.html","title":"Tutorial: Tests","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Tests Boomerang has extensive test coverage in the form of Unit Tests and End-to-End (E2E) Test suites. Test Environment To configure the test environment, you will need to install all of the required NPM and Bower dependencies: npm install bower install node node_modules/protractor/bin/webdriver-manager update In addition, you should map the following two domains to 127.0.0.1: boomerang-test.local boomerang-test2.local e.g. # /etc/hosts or C:\\windows\\system32\\drivers\\etc\\hosts 127.0.0.1 boomerang-test.local boomerang-test2.local Unit Tests Boomerang's Unit Tests validate Boomerang's public APIs and utility functions. Unit Tests should not depend on the environment (e.g. HTML structure, a specific browser, or other environment setup). If you need a specific environment, you should create an End-to-End (E2E) test. Unit Tests are located in tests/unit/*.js. They are loosely organized into components or plugins. Boomerang's Unit Tests can be run from your local browser or in headless mode: grunt test To build, run or debug the Unit Tests in your local browser, you will need to spawn a local webserver to host the tests/unit/* files. You can do this by running the following: grunt test:debug Once the webserver has started, you should be able to visit the following URL in your browser: http://boomerang-test.local:4002/unit/ All Unit Test files are manually included via tests/unit/index.html. In addition, you can run any of the following combinations to automatically run all tests/unit/*.js files via Grunt and Karma: grunt test:unit grunt test:unit:all grunt test:unit:allHeadless grunt test:unit:Chrome grunt test:unit:ChromeHeadless grunt test:unit:Firefox grunt test:unit:FirefoxHeadless grunt test:unit:Edge grunt test:unit:IE grunt test:unit:Opera grunt test:unit:Safari grunt test:unit:PhantomJS The Unit Tests utilize Chai Assert for validations. End-to-End (E2E) Tests Boomerang's End-to-End (E2E) Tests validate how Boomerang behaves in various scenarios and environments: user actions (e.g. navigating between pages), page constructions (e.g. with specific DOM elements), frameworks (e.g. SPAs), etc. E2E Tests are located in tests/page-templates/**/*.[js|html]. They are loosely organized into subdirectories of scenarios or plugins. Each E2E test has two files: 01-name.html contains the scenario (e.g. what is happening in the test) while 01-name.js contains the test validations. When grunt test or grunt build:test is called, the tests/page-templates/**/* files are processed (templates applied) and output into tests/pages/, whose files are loaded by the browser during test execution. Some of the templates live in tests/page-templates/*. The E2E Tests utilize Chai Assert for validations. Boomerang's E2E Tests can be run from your local browser or in headless mode. To build, run or debug the E2E Tests in your local browser, you will need to spawn a local webserver to host the tests/pages/* files. You can do this by running the following: grunt test:debug In addition, you can run any of the following combinations to automatically run all E2E tests files via Grunt and Protractor: grunt test:e2e grunt test:e2e:browser grunt test:e2e:debug - will only run tests in tests/e2e/e2e-debug.json grunt test:e2e:PhantomJS grunt test:e2e:Chrome grunt test:e2e:ChromeHeadless grunt test:e2e:Firefox grunt test:e2e:FirefoxHeadless grunt test:e2e:Edge grunt test:e2e:IE grunt test:e2e:Safari × Search results Close "},"tutorial-version-history.html":{"id":"tutorial-version-history.html","title":"Tutorial: Version History","body":" Boomerang Classes BOOMRBOOMR.browserBOOMR.constantsBOOMR.pluginsBOOMR.plugins.AutoXHRBOOMR.plugins.BWBOOMR.plugins.CACHE_RELOADBOOMR.plugins.ClicksBOOMR.plugins.ConsentInlinedPluginBOOMR.plugins.ContinuityBOOMR.plugins.CTBOOMR.plugins.DNSBOOMR.plugins.EarlyBOOMR.plugins.ErrorsBOOMR.plugins.EventTimingBOOMR.plugins.GUIDBOOMR.plugins.HistoryBOOMR.plugins.IFrameDelayBOOMR.plugins.IPv6BOOMR.plugins.MemoryBOOMR.plugins.MobileBOOMR.plugins.NavigationTimingBOOMR.plugins.PaintTimingBOOMR.plugins.ResourceTimingBOOMR.plugins.RTBOOMR.plugins.SPABOOMR.plugins.TPAnalyticsBOOMR.plugins.UserTimingBOOMR.sessionBOOMR.utilsBOOMR.utils.CompressionBOOMR_mqMutationHandlerProxyXHRImplementation Events BOOMR#event:beaconBOOMR#event:before_beaconBOOMR#event:before_early_beaconBOOMR#event:before_unloadBOOMR#event:clickBOOMR#event:configBOOMR#event:dom_loadedBOOMR#event:errorBOOMR#event:form_submitBOOMR#event:netinfoBOOMR#event:page_load_beaconBOOMR#event:page_readyBOOMR#event:page_unloadBOOMR#event:prerender_to_visibleBOOMR#event:rage_clickBOOMR#event:spa_cancelBOOMR#event:spa_initBOOMR#event:spa_navigationBOOMR#event:visibility_changedBOOMR#event:xhr_errorBOOMR#event:xhr_initBOOMR#event:xhr_loadBOOMR#event:xhr_senddocument#event:onBeforeBoomerangBeacondocument#event:onBoomerangBeacondocument#event:onBoomerangLoaded Tutorials README.templateBuildingContributingCreating PluginsHeader SnippetsHow-TosNon-Blocking Loader SnippetMethodologyPage OverridesPerformance TestsTestsVersion History Global BOOMR_check_doc_domainBOOMR_lstartBOOMR_onloadBOOMR_start Version History Boomerang Release Notes 1.737.0 (Apr 16, 2021) New Features AutoXHR: Allow SPA to start from clicks SPA: Option to apply Wait Filter for Hard Navs AutoXHR: Ignore opacity:0, 0px-dimension DOM elements, custom filters Build: Support for build flavors Bug Fixes Unblock Early beacon during missed SPA Hard Nav Boomerang: Always ensure Session Length is at least 1 Documentation Doc: Loader Snippet Known Issues and other JSDoc changes 1.725.0 (November 3, 2020) Breaking Changes Boomerang will no longer send an \"XHR Beacon\" when an XMLHttpRequest does not result in any interesting DOM modifications (i.e. no new images, stylesheets, IFRAMEs or other XHRs were added). This change can be reverted to the previous behavior (of still sending an XHR Beacon) by setting the AutoXHR.xhrRequireChanges=false flag. Bug Fixes AutoXHR: Don't send XHR beacons if there were no DOM mutations AutoXHR: Don't wait on lazy-loaded images AutoXHR: For XHR beacons that happen before Page Load, ResourceTiming data is properly added to the XHR beacon when it is fired Continuity: Only add Time To Visually Ready (TTVR) to the Page Load beacon Errors: Avoid loop in Memory plugin for some pages EventTiming: Observe entries from top-level frame (e.g. for First Input Delay) ResourceTiming: Include the Boomerang and Config URL (for mPulse) 1.720.0 (July 29, 2020) Bug Fixes Boomerang: Added support for SameSite and Secure cookie attributes 1.715.0 (June 26, 2020) Bug Fixes History: Correctly forward arguments to routeFilter Documentation Docs: Release notes updated Docs: Continuity Cumulative Layout Shift docs Docs: Added additional Back-end Servers and integration guides 1.711.0 (June 8, 2020) Bug Fixes EventTiming: Change firstInput type to first-input per spec change 1.710.0 (May 6, 2020) Breaking Changes Errors: The monitorEvents and monitorTimeout options are now disabled by default. As a result, some cross-origin JavaScript Errors may not report the full message (and instead will only show Script Error.), and the stack will not be available. Please see the Errors plugin documentation for details on the side-effects of re-enabling those options. Continuity: First Input Delay calculations have changed slightly. The plugin will now use the Event Timing plugin (if available and the browser supports it) for First Input Delay calculation. If not, mousedown, touchstart and pointerdown events are now used for First Input Delay calculations, while Scroll, Visibility and Orientation changes are not. Only cancelable events are now tracked. First Input Delay should be more accurate, though there may be less overall measurements (due to not tracking Scroll for First Input). New Features Event Timing plugin (enabled by default) ResourceTiming: Service Worker timing capture at resource level PaintTiming: Expose Largest Contentful Paint via BOOMR.plugins.PaintTiming.metrics.lcp() Bug Fixes Continuity: Scroll Log: Trim decimals Documentation Docs: Include minified snippets in built documentation Docs: Add Header Snippets section Docs: Fixed reference from c.t.lt to c.t.longtask Boomerang: Document additional beacon vars Tests Tests: Ensure /delay path roots requested files to wwwRoot 1.700.0 (January 29, 2020) New Features: Issue 1027: PaintTiming: Largest Contentful Paint Issue 1030: Consent Inline Plugin and Docs Issue 1040: Continuity: Add the ability to track Cumulative Layout Shift Bug Fixes: OS Issue 251: Add support for background image detection for c.tti.hi OS Issue 261: NPM: Allow running grunt build Issue 990: SPA: Only subtract SPA timeout when the timeout fires Issue 1026: Update Snippet to have its own reference to the parentNode 1.687.0 (October 10, 2019) New Features: Issue 1019: Boomerang: Replace MD5 with FNV for better performance Bug Fixes: OS Issue 273: rt.si not working as expected OS Issue 275: UserTiming: Update usertiming-compression package to latest version Issue 1020: RT: Error wrapping when we have NS_ERROR_FAILURE for Firefox 31 Issue 1021: AutoXHR: Handle removing src attribute from monitored resource 1.681.0 (September 11, 2019) Bug Fixes: Issue 823: History SPA v2 Issue 1001: Continuity: Don't track interaction times in Safari if loaded in iframe Issue 998: Docs: Document rt.si, rt.ss, rt.sl, rt.tt, rt.obo Issue 997: ResTiming: Disable srcset physical dimension collection by default Issue 1003: Continuity: Turn monitorStats off by default Issue 987: Memory: Add support for navigator.connection.saveData OS Issue 197: Navigation Timing: Plugin sends twice per page Issue 1005: Continuity: Don't disable collection when API beacons are sent 1.672.0 (August 22, 2019) Bug Fixes: Issue 999: RT: Cleanup beacon parameter cleanup 1.669.0 (June 28, 2019) Bug Fixes: Issue 992: Errors: Ensure message.indexOf is a function Issue 993: Early Beacon: Fix for SPA events 1.667.0 (June 12, 2019) New Features: Issue 637: Early Beacons Bug Fixes: Issue 976: AutoXHR: XHR abort status fix for FireFox Issue 980: Memory: Remove reference to BatteryManager API as this API is obsolete Issue 812: ResourceTiming: More initiatorTypes Issue 983: NavigationTiming: Don't use chrome.loadTimes() when there are no paints Issue 982: Boomerang: Fix empty-beacon check Issue 939: Optimize cookie access Issue 991: Continuity: ceil duration times Issue 990: Boomerang: Don't set cookie if domain is null, fallback to current 1.650.0 (May 14, 2019) New Features: Issue 782: Boomerang Loader Snippet v12 Issue 966: History: Add config option to disable monitoring of replaceState Bug Fixes: Issue 969: AutoXHR: Make routeChangeWaitFilter wait_complete calls wait for other pending nodes Issue 972: IFrameDelay: Listen for postMessage calls on the correct window Issue 973: LOGN: Use HTTP for XDomainRequest for IE8-10 if on HTTP site Docs: Issue 968: Continuity: Document events for TTFI Tests: Issue 975: IFrameDelay: Force tests to load Boomerang in an IFRAME when using the snippet Issue 974: Grunt: Allow specifying multiple webdriver-version 1.643.0 (April 9, 2019) Performance Improvements: Issue 933: Performance: Boomerang Performance Tests Issue 936: Performance: Strips out BOOMR.debug and related messages for production builds Issue 937: Performance: Grunt: Use UglifyJS-3 Issue 953: Performance: ResourceTiming: Allow for non-optimal Trie to improve performance Bug Fixes: Issue 941: AutoXHR: Track uninteresting timeout per event instead of per page Issue 931: AutoXHR: Cleanup listeners on observed nodes Issue 947: AutoXHR: Track Fetch the same way as XHR during SPA navigations Issue 946: AutoXHR: Track LINK stylesheets as interesting nodes Issue 943: AutoXHR: Add XHRs to pending events at send instead of load finished Issue 947: AutoXHR: Include Fetch requests in SPA backend time Issue 952: Boomerang: Ensure only a single beacon is being sent at once Issue 959: IFrameDelay: Gracefully handle different load orders 1.630.0 (January 15, 2019) Bug Fixes: Issue 928: SPA: Ignore route changes if a routeChangeWaitFilter has not yet completed Issue 929: History: Ignore replaceState() if a SPA nav is in progress and no URL change Issue 930: SPA: Only apply routeFilter and routeChangeWaitFilter on SPA Soft Navigations 1.629.0 (December 3, 2018) Bug Fixes: Issue 906: Cleanup leaked global vars Issue 907: Added .npmignore for OS NPM package Issue 908: README: Notes on download / npm / bower Issue 910: TPAnalytics: Add data to spa_hard beacons Issue 913: UserTiming: Update to vanilla UserTimingCompression Issue 923: Boomerang: Keep track of all unload handlers to know when to send unload Issue 925: AutoXHR: Don't track &lt;SCRIPT&gt; tags for XHR beacons OS Issue 196: Optionally depend on usertiming-compression OS Issue 218: Boomerang: Optionally send XHR with credentials OS Issue 219: Clicks: Fix plugin config OS Issue 220: SPA: Clarify route_change comment OS Issue 221: Tests: Move webdriver-manager from package.json install script to tests OS Issue 223: JSDoc: Clarify SPA plugin load-order requirements OS Issue 224: Fix issue related to screen orientation in iPhone and iPad OS Issue 231: Add missing bracket after \"Observer effect\" link OS Issue 236: Continuity: Update documentation of beacon parameters 1.626.0 (November 12, 2018) Bug Fixes: Issue 905: Errors / AutoXHR: Un-register wrapped functions at unload Issue 903: SPA: Make markNavigationComplete only apply to SPA events 1.624.0 (November 2, 2019) Bug Fixes: Issue 892: Errors: Timing issue causing page load beacon to get tagged with the error type initiator marker Issue 899: AutoXHR: Try to use native MutationObserver when running on a page with Zone.js 1.621.0 (October 24, 2018) New Features: Session tracking via cookies Issue 890: Errors: Support Reporting API warnings Issue 840: Errors: Monitor Unhandled PromiseRejectionEvents Bug Fixes: Issue 886: Errors: Allow onerror to be called with an ErrorEvent object Issue 893: Continuity: Disable MutationObserver usage for monitorStats for IE11 Issue 895: AutoXHR: Don't track pixels or IFRAMEs that change src OS Issue 206: Fallback to use XHR if data store requires auth OS Issue 211: Fix getBeaconURL() error using AutoXHR plugin 1.615.0 (September 25, 2018) Bug Fixes: Issue 879: Protect against undefined nodeName Issue 877: Boomerang: Add beacon number param Issue 769: NavTiming: Don't look at chrome.loadTimes() if nextHopProtocol is empty Issue 883: Cookie Compression 1.612.0 (September 18, 2019) Bug Fixes: Issue 869: PaintTiming: Don't add FP/FCP if document is hidden or for SPA Soft/XHRs Issue 873: Continuity: Don't fail if Screen Orientation API is not supported Issue 876: Boomerang: Don't use polyfilled sendBeacon() 1.609.0 (August 29, 2018) Bug Fixes: Issue 847: Don't use the navigator.sendBeacon API when beacon_type is set to GET Issue 853: Verify that the Battery value is a valid number before adding it to the beacon Issue 864: SPA: Fix regression in SPA timings with disableHardNav Issue 865: AutoXHR: Fix regression in XHR monitoring for non-NT browsers Issue 866: AutoXHR: don't mistakenly clear monitorFetch flag Issue 863: AutoXHR: alwaysSendXhr accepts a function or list of strings/regexs 1.602.0 (August 17, 2018) Bug Fixes: Issue 858: Fix localStorage expiry time Issue 854: Run page ready only after config arrives Issue 861: If the cookie is set to null, rt.si, rt.sl, rt.ss, should not be written 1.598.0 (July 27, 2018) New Features Issue 851: EXPERIMENTAL: AutoXHR: Delay checking RT if fetch response body is not used Bug Fixes: Issue 850: EXPERIMENTAL: AutoXHR: Do not instrument polyfilled fetch API Tests: Issue 841: Remove CT16 'slowest' from Resource Groups Docs: Issue 820: ResourceTiming: JSDoc fixes 1.593.0 (July 23, 2018) New Features: Issue 824: EXPERIMENTAL: AutoXHR: Add Fetch API instrumentation Bug Fixes: Issue 843: AutoXHR: Handle XHRs that are aborted after readyState 4 Issue 844: SPA: Fixes URL for SPA navigations after XHR beacons 1.590.0 (July 16, 2018) New Features: Issue 813: Add cookie length and localStorage length as beacon parameters Issue 818: Trap clearResourceTimings() Bug Fixes: Issue 835: Protect access to localStorage variable Issue 838: AutoXHR: Only save XHR request and response payloads if configured to Issue 817: Replace undefined parameter values with empty string in beacon query OS Issue 198: Fix TypeError: undefined is not an object Tests: Issue 828: Test server: Add support for customizable status codes in all cases Issue 802: Test fixes for test #111096 Issue 839: Clean sessionStorage in e2e tests Issue 842: Fix for 11-restiming/12-clearResourceTiming Docs: Issue 830: Continuity: Docs update for missing parameters Issue 836: Docs for Boomerang Tests 1.579.0 (May 7, 2018) New Features: Issue 792: Use currentSrc for images (PICTURE support) Issue 814: SVG:IMAGE and srcset support for Continuity Hero Images Bug Fixes: Issue 809: Errors: unbound removeEventListener Issue 750: History: react to popstate events and allow aborted beacons 1.571.0 (April 10, 2018) New Features: Issue 528: Continuity plugin Bug Fixes: Issue 804: OS Repo sync and fixes 2018 Issue 801: Add array bounds check to getQueryParamValue() Issue 790: ResourceGroups: Run at same time as other handlers instead of at before_beacon Issue 793: Boomerang: Ensure we don't console.log a BOOMR.debug message in production Issue 805: Continuity: Fix busy calculation for late periods Issue 775: Errors: Check context in wrapFn Issue 777: Errors: Call removeEventListener before addEventListener Issue 784: getMyURL() fix for PhantomJS 1 Issue 776: Correctly detect our url on IE using non-standard loader Issue 799: Move alwaysSendXhr into the pluginConfig section to make it clearer that this is an AutoXHR config 1.566.0 (March 21, 2019 - restricted use) New Features: Issue 759: Update to new server timing header syntax Bug Fixes: Issue 774: Disable MutationObserver in IE 11 due to browser bugs Issue 761: Prevent unload confirmation popup in tests Issue 772: Make self url detection work when loaded in primary window as well Issue 756: Errors: Support capture flag in options object passed in Tests: Issue 752: Upgrade express-middleware-server-timing Issue 771: Edge, IE and Safari e2e test support Issue 737: Headless modern browser support (Chrome + Firefox) Issue 768: Improve localStorage tests Issue 767: Revive the SauceLabs code Issue 751: Gruntfile: Split apart build steps 1.552.0 (February 9, 2018) New Features: Issue 748: PaintTiming plugin; NavTiming: Deprecate chrome.loadTimes() 1.543.0 (January 25, 2018) New Features: Issue 728: Override the load end-time with BOOMR_page_ready or a param to BOOMR.page_ready() Bug Fixes: Issue 726: NavTiming: Fix nt_nav_type Issue 726: Boomerang: Add timeout to requestIdleCallback in BOOMR.setImmediate Issue 726: AutoXHR: fix for IMGs with changing src Issue 726: NavTiming: Get msFirstPaint only from performance.timing Issue 726: AutoXHR: When a SPA Hard beacon is ready but onload hasn't fired, run after other onload handlers Issue 738: Configuration for locking beacon_url to specific patterns Issue 730: Compare marks/measures to performance.now mark Issue 727: Navtiming: Fix nt_nav_st Issue 723: CrossDomain: Disable if URL is blank or whitespace Issue 722: Work around minification that breaks in IE8 and quirks mode Issue 718: Errors: Wrap addEventListener at the end of the protocol chain 1.532.0 (December 18, 2017) Bug Fixes: Issue 714: Fix Custom Timers for SPA navigations Issue 699: NavigationTiming: Don't include timestamps for events that haven't happened 1.527.0 (December 12, 2017) New Features: Issue 695: BOOMR.sendAll() Bug Fixes: Issue 701: CrossDomain: Validate cross-domain URL Issue 710: Workaround for document.write changing readyState after onload 1.522.0 (November 10, 2017) Bug Fixes: Issue 693: Add BOOMR.utils.arrayFind (fixes ResourceTiming in IE11) Issue 696: Better string checking for Boolean Custom Metrics Issue 700: Capture BOOMR.page_ready() time after onload; BOOMR.addVar() for single beacons 1.517.0 (October 20, 2017) New Features: Issue 635: ServerTiming support Bug Fixes: Issue 691: XHR Filtering: Fixes for match option Issue 686: Force beacons to HTTPS Issue 670: Handle latest netinfo spec Issue 671: Add nocookie flag if we couldn't set cookies Issue 678: Resource Groups: Fixes for IE 10 Issue 685: ResourceTiming: Add iframe and subdocument to initiatorType Issue 683: CrossDomain: Abort when cross-domain URL isn't specified 1.511.0 (September 7, 2017) Bug Fixes: Issue 621: CrossDomain: Reliability fixes Issue 665: AutoXHR: Wait once up to 1,000ms after an uninteresting mutation Issue 666: SPA.markNavigationComplete() support 1.506.0 (August 30, 2017) Bug Fixes: Issue 663: AutoXHR: If we don't instrument XHR open() due to exclude filter then don't instrument send() Issue 664: AutoXHR: Do not extend the event timeout with each uninteresting mutation 1.500.0 (August 15, 2017) Bug Fixes: Issue 602: SPA: Aborted load beacons Issue 647: RT: Fix t_page and t_resp missing from the beacon Issue 648: RT: Always use loadEventEnd as the end load time 1.495.0 (July 24, 2017 - restricted use) Bug Fixes: Issue 598: NavigationTiming: Add a few NavigationTiming2 fields if available Issue 599: ResourceGroup: Support for SPA navigations Issue 614: ResourceGroups: Match all CSS selector elements instead of just first one 1.489.0 (July 7, 2017 - restricted use) Bug Fixes: Issue 624: BOOMR.sendMetric/Timer: Include rt.end Issue 633: BOOMR.sendMetric/Timer: Append session start time to rt.si 1.486.0 (June 16, 2017) Bug Fixes: Issue 610: BOOMR.log: Add timestamp Issue 612: SPA: Don't send beacons for SPA soft navs that don't change the URL and no resources are triggered Issue 608: ResourceTiming: Additional checks and fixes for non-supported browsers Issue 607: ResourceTiming: If there are no entries, ensure the parameter is {} Issue 609: Angular: Don't trigger Route Change on $locationChangeStart if other events fire Issue 618: BOOMR.sendTimer/sendMetric: Set the location so dimensions work properly 1.483.0 (May 15, 2017) Bug Fixes: Issue 594: AutoXHR: Don't wait for XHRs that .open() but don't .send() Issue 579: BOOMR_mq method queue Issue 588: Add support for delaying page_load beacon with instrumented iframes Issue OSS 139: ResTiming: Resource type filter 1.479.0 (May 12, 2017) Bug Fixes: Issue 591: sendBeacon: x-www-form-urlencoded 1.477.0 (May 11, 2017 - restricted use) Bug Fixes: Issue 586: Don't report IE error for freed script in event and timeout handlers Issue 585: Angular: Track navigations when only a $locationChangeStart fires Issue 587: Miscellaneous cleanup Issue 577: Warn on window and document overrides (debug builds only) Issue 583: Don't send boomerang error on TPAnalytics third party errors Issue 559: Errors: Loader Snippet to capture errors before Boomerang arrives Issue 561: Errors: Re-throw caught exceptions Issue 563: BOOMR.sendTimer() / BOOMR.sendMetric() and sendBeacon() support Issue 582: UserTiming disabled by default Issue 581: Add usertiming feature flag Issue OSS 77: Plugin to beacon User Timing API mark and measure entries Issue 562: Minor fixes to sync with OS repo Issue OSS 138: Make the errors plugin work without the Compression plugin 1.463.1493220061 (April 26, 2017) Bug Fixes: Issue 570: History: Option to disable hard navigation in favor of BOOMR.page_ready() Issue 560: Errors: Include dimensions (page groups, AB, custom) on error beacons Issue 558: Errors: Send during onload if autorun=false Issue 564: AutoXHR: Fixes XHR after click missing beacon Issue 567: Update copyrights 1.452.1492175627 (April 14, 2017) Bug Fixes: Issue 556: Deduplicate calls to addEventListener() with the same arguments 1.451.1491334204 (April 4, 2017) Bug Fixes: Issue 555: Ensure we don't clobber cross_domain_url if it has a query param already Issue 557: AutoXHR: Only capture reponseText or responseXML if the type is set 1.449.1490889765 (March 30, 2017) Bug Fixes: Issue 553: Prevent Errors plugin from accessing a function of a potentially undefined error message Issue 547: Only use performance.now() if it is a native function Issue 554: Replace isArray with hasOwnProperty check for backward compatibility Issue 551: Remove calls for timepoint calculations 1.446.1490635326 (March 27, 2017) Bug Fixes: Issue 549: Fix typo in NavigationTiming (push of undefined) 1.445.1489625641 (March 15, 2017) Bug Fixes: Issue 525: Grunt: Re-run specific tasks Issue 531: Check that scrollX &amp; scrollY are numbers Issue 532: Make sure n.getBattery is a function before calling it Issue 537: ResourceTiming: Ignore IE's res: urls Issue 536: Add downlinkMax for browsers that support it. Issue 533: ResourceTiming: Exports .addResourceTimingToBeacon() Issue 524: Warn on buggy responseEnd Issue 538: Normalize cross_domain_url Issue 535: Add support for requestIdleCallback() Issue 542: Gruntfile: Uglify debug-test-min after applying templates Issue 529: Add ResourceTiming timepoints Issue 526: History bugs and XHR beacon handling changes Misc: Jump to newer versions of eslint so that jenkins matches reality 1.435.1487783301 (February 22, 2017) Bug Fixes: Issue 520: Test fix Issue 521: Bind forEach contexts this to calling mutationHandler instance context 1.432.1486768074 (February 10, 2017) Bug Fixes: Issue 509: Adds Page ID and refactored random ID generation Issue 513: XHR fixes when ResourceTiming is available Issue 515: SPA Hard: Use navigationStart instead of fetchStart for start time Issue 516: SPA navigations: Remove timers from hard nav Issue 517: Remove rt.sh and rt.srst (Session History debug) Issue 519: CrossDomain: Ensure a beacon is sent, wait up to 5s for timeout Issue 371: Handle SVG IMAGE types Issue 495: Add support for PageGroups based XHR Instrumentation filters Issue 348: Count unique urls in dom.img and dom.script Issue 455: t_page &lt; 0 on some SPA beacons Issue 518: Protect against browser bugs for t_page and t_resp 1.429.1485448661 (January 26, 2017) Bug Fixes: Issue 456: Errors: Filter boomerang functions from stack in minified version Issue 508: Errors: Errors.wrap: Run BOOMR_check_doc_domain first 1.426.1484362995 (January 13, 2017) Bug Fixes: Issue 496: ESlint: Enable space-in-parens Issue 499: boomerang: Fix XHR Authorization check 1.423.1483643196 (January 5, 2017) Bug Fixes: Issue 479: Prevent XHR Beacons before SPA Hard if alwaysSendXHR not enabled Issue 481: SPA: Don't enable MutationObserver / AutoXHR until asked to Issue 483: Capture Adobe s.purchaseID var Issue 482: Add support for PageGroups based on XHR Payload Issue 485: Use Boomerang IFRAME XHR as backup if window XHR fails Issue 491: Add support for Custom Filters in AutoXHR Issue 497: Ensure removeChild() is only called when iframe exists, ensure indexOf() Issue 498: Move origin check up before parsing JSON Misc: Updated mocha dependency Misc: Update README to account for changed build procedure OS 112: POST &amp; Auth Token Support 1.413.1477614597 (October 27, 2016) Bug Fixes: Issue 470: SPA: Recalculate SPA Hard timings before capturing ResourceTiming Issue 471: ResourceTiming: Ensure entries are sorted correctly so all are captured Issue 476: Add rt.nstart to to beacon Issue 477: Avoid IE10 / IE11 bug with MutationObserver and XHR.responseXML 1.407.1476482714 (October 14, 2016) New Features: Support for Resource Groups Bug Fixes: Issue 465: SPA Hard navigation timing calculation changes 1.405.1475087321 (September 28, 2016) Bug Fixes: Issue 451: Session length incrementing for XHR subresource beacons before onload Issue 452: Session length incrementing for Boomerang in IFRAME when autorun=false Issue 453: scrollX and scrollY undefined in IE Issue 477: Ensure window is available when sending a Beacon 1.402.1473440808 (September 9, 2016) Bug Fixes: Issue 434: Boomerang: Wrap dispatchEvent() / fireEvent() in try/catch Issue 440: AutoXHR: Improve tracking with multiple outstanding XHRs Issue 443: TPAnalytics: Skip calling ga.getAll() if it's not a function 1.400.1470878703 (August 10, 2016) Bug Fixes: Issue 412: BOOMR.now was always using Date.now Issue 413: Allow XMLHttpRequest.open() twice Issue 427: Add errors-monitor-other feature Issue 429: Support Classic GA and named trackers Issue 430: Fix xhr negative t_page in prerender Issue 431: Ensure our MutationObserver is created in the page's context, not our IFRAME 1.399.1469784094 (July 29, 2016) Bug Fixes: Issue 416: Fixes capturing of ResourceTiming2 sizes Issue 418: Sanity check Image works before using to send a beacon Issue 419: Ensure r and r2 parameters are redacted Issue 420: Do not send Third Party Analytics client IDs if disabled in config Issue 421: Errors limit the maximum captured stack length Issue 422: AutoXHR: Click events should always use the URL of the fetched resource Issue 423: Errors: monitorConsole bug fixed 1.394.1467954210 (July 7, 2016) Bug Fixes: Issue 400: Wraps removeEventListener() to work with the wrapped functions 1.390.1467244673 (June 29, 2016) New Features: Cross-domain session tracking support ResourceTiming: Allow a list of URLs to trim all data from (e.g. analytics beacons) TPAnalytics: Add support for IBM Site Promotion Analysis and Real Estate Analysis Bug Fixes: Issue 363: Fixes bug with duplicate XHR URLs returning incorrect timing Issue 385: Fix for Errors plugin with setInterval() using string parameters Issue 372: ResourceTiming no longer tracks beacon URLs Issue 386: ResourceTiming fixes bugs for browsers that have NT but no RT support Issue 389: Fix missing data on pre-rendered pages when another beacon is sent before 1.381.1463423250 (May 16, 2019) New Features: TPAnalytics: Plugin captures IDs from other third-party analytics scripts Bug Fixes: Issue 357: Fixes a warning when window.performance doesn't exist Issue 374: Fixes a warning when the browser doesn't implement getBattery() properly Issue 376, 377, 378: Fixes warnings when window doesn't exist due to the page unloading Issue 378, 380: Fixes warnings when JSON doesn't exist 1.376.1462309808 (May 3, 2016) Bug Fixes: Issue 366: Fixes a bug where a beacon might not be sent if an IMG is modified several times in a Single Page App nav 1.371.1461863625 (April 28, 2016) New Features: Errors plugin: JavaScript Error Reporting Support for Boolean Custom Metrics International currency formatting support Large beacons (for example, those containing ResourceTiming data) are now sent using XHR instead of a FORM POST scr.sxy parameter added to the beacon (scroll X and Y in pixels at the time of the beacon) 1.345.1458593666 (March 21, 2016) Bugs Fixes: Issue 328: Fix race condition causing No Page Groups Issue 329: Fix for History plugin when using auto in custom SPA frameworks Issue 331: Protect against user agents that throw errors on window.performance access 1.334.1456175784 (February 23, 2016) New Features: XHR instrumentation uses ResourceTiming if available for more accurate performance metrics ResourceTiming can be configured to clear ResourceTiming entries after each beacon Single Page App navigations now calculate Front-End (t_page) and Back-End (t_resp) metrics Single Page App navigations can be configured tell Boomerang to hold the SPA beacon until the page has completed other non-network activity XHR instrumentation can be configured to send XHR beacons for every XHR, instead of combining them during SPA navigations Custom Metric JavaScript variables can be configured to only be captured on specific URLs XHR instrumentation has a new optional snippet that helps instrument XHR before boomerang.js has been loaded Single Page App navigations now include NavigationTiming and/or ResourceTiming metrics for hard and soft navigations Angular ui-router support URLs captured via ResourceTiming are now limited to 1,000 characters React support Other Single Page App support via window.History and onhashchange monitoring ResourceTiming2 encoded, decoded and transfer sizes are collected Configurable option to override the name of the RT cookie Bug Fixes: Issue 196: Fixes t_done merging when two XHRs complete at the same time Issue 231: SPA navigations might wait indefinitely for IFRAMEs that were removed from the DOM Issue 249: Don't fire a non-SPA beacon when SPA support is enabled Issue 250: Wait for page onload before firing a SPA Hard Nav Issue 260: Revert form.submit() behavior back to original style Issue 271: Ensure we don't send bad t_page values from responseStart / responseEnd inversions on iOS Issue 299: Fixes race condition with manual beacons Issue 305: Wrap all sub-frame accesses in try/catch to avoid \"Permission Denied\" errors Issue 307: Fixes XHR error codes were not being tracked in some cases Issue 313: Fixes conflict with other third-party XHR instrumentation Issue 315: SPA navigation beacons being sent when autorun=false for prerender 1.246.1441122062 (September 1, 2015) Bug Fixes: Issue 174: Allow for quotes in cookies Issue 189: Only fire beacons during prerender to visible transition if beyond page load Issue 191: Check for Backbone existence on the correct IFRAME 1.235.1439916634 (August 18, 2015) Bug Fixes: Bug 95730: Support static function members on JavaScript classes and strings for dimensions, timers and metrics Bug 95904: Microsoft Edge browser hang on form.submit() on some pages Issue 176: Fix for browsers that don't have native support for Array.filter Issue 181: Fix to stop sending two beacons when SPA is disabled in app configuration but hook code is still on the page Issue 179: Enable QuerySelectors for Custom Timers with ResourceTiming 0.9.1437148526 (July 17, 2015) New Features: Optional parameter to await completion in bandwidth plugin before sending beacon Better support for tag managers and loading after onload New dom.script.ext beacon parameter reports the number of external scripts New dom.img.ext beacon parameter reports the number of external images New ua.plt beacon parameter reports the current platform New ua.vnd beacon parameter reports the current vendor QuerySelector support for Custom Metrics, Timers and Dimensions AngularJS, Ember.js and Backbone.js support Bug 93814: Allow array subscript for variables Bug Fixes: Bug 87109: Sessions were not being reset in some cases, resulting in very long sessions that skew average session duration Bug 88717: Auto-XHR: Always use original XHR .open() arguments Bug 91178: Page Groups using JavaScript variables always need to return the value so we can terminate on match Bug 92121: For Cookie Custom Metrics, if the cookie wasn't defined, we were using the current URL as the value Bug 92542: Ensure getEntriesByName() / getEntriesByType() exists in the frame before using Bug 92302: Change ResourceTiming optimized trie to avoid strings that trigger a XSS warning from NoScript Bug 92560: Auto-XHR: Exclude list not honored in IE Bug 92924: Auto-XHR: Not working with IE9 Bug 94388: Use rt.start=none only if we don't have a start time Bug 94400: Page Group matching failing on IE (pre-IE11) IE Xpath parser: Allow single or double quotes rt.js: validateLoadTimestamp(): In an XHR event, trust the end ('now') timestamp auto_xhr.js: Only watch IMGs that have a new src attribute or the src attribute has changed × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
